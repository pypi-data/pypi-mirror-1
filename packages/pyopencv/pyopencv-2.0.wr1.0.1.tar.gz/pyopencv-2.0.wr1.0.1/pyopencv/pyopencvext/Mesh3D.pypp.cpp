// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "opencv_extra.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "Mesh3D.pypp.hpp"

namespace bp = boost::python;

static void computeNormals_0372659dbb67ca1f98a084bb3e33c861( ::cv::Mesh3D & inst, bp::sequence subset, float normalRadius, int minNeighbors=20 ){
    std::vector<int, std::allocator<int> > subset2;
    convert_seq_to_vector(subset, subset2);
    inst.computeNormals(subset2, normalRadius, minNeighbors);
}

static void writeAsVrml_8e53a52859ed45ddf6fdddd9bce7a16a( ::cv::Mesh3D const & inst, ::cv::String const & file, bp::sequence colors=convert_vector_to_seq(std::vector<cv::Scalar>()) ){
    std::vector<cv::Scalar_<double>, std::allocator<cv::Scalar_<double> > > colors2;
    convert_seq_to_vector(colors, colors2);
    inst.writeAsVrml(file, colors2);
}

static boost::shared_ptr<cv::Mesh3D> Mesh3D_init1( bp::sequence const &vtx)
{
    std::vector<cv::Point3f> vtx2;
    convert_seq_to_vector(vtx, vtx2);
    return boost::shared_ptr<cv::Mesh3D>(new cv::Mesh3D(vtx2));
}

static bp::sequence get_vtx(cv::Mesh3D const &inst) { return convert_vector_to_seq(inst.vtx); }
static bp::sequence get_normals(cv::Mesh3D const &inst) { return convert_vector_to_seq(inst.normals); }

void register_Mesh3D_class(){

    { //::cv::Mesh3D
        typedef bp::class_< cv::Mesh3D > Mesh3D_exposer_t;
        Mesh3D_exposer_t Mesh3D_exposer = Mesh3D_exposer_t( "Mesh3D", bp::init< >() );
        bp::scope Mesh3D_scope( Mesh3D_exposer );
        Mesh3D_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D >() );
        bp::class_< cv::Mesh3D::EmptyMeshException >( "EmptyMeshException" )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D::EmptyMeshException >() );
        { //::cv::Mesh3D::buildOctree
        
            typedef void ( ::cv::Mesh3D::*buildOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "buildOctree"
                , buildOctree_function_type( &::cv::Mesh3D::buildOctree ) );
        
        }
        { //::cv::Mesh3D::clearOctree
        
            typedef void ( ::cv::Mesh3D::*clearOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "clearOctree"
                , clearOctree_function_type( &::cv::Mesh3D::clearOctree ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( ::cv::Mesh3D::*computeNormals_function_type )( float,int ) ;
            
            Mesh3D_exposer.def( 
                "computeNormals"
                , computeNormals_function_type( &::cv::Mesh3D::computeNormals )
                , ( bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( *computeNormals_function_type )( ::cv::Mesh3D &,bp::sequence,float,int );
            
            Mesh3D_exposer.def( 
                "computeNormals"
                , computeNormals_function_type( &computeNormals_0372659dbb67ca1f98a084bb3e33c861 )
                , ( bp::arg("inst"), bp::arg("subset"), bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) ) );
        
        }
        { //::cv::Mesh3D::estimateResolution
        
            typedef float ( ::cv::Mesh3D::*estimateResolution_function_type )( float ) ;
            
            Mesh3D_exposer.def( 
                "estimateResolution"
                , estimateResolution_function_type( &::cv::Mesh3D::estimateResolution )
                , ( bp::arg("tryRatio")=1.00000001490116119384765625e-1f ) );
        
        }
        { //::cv::Mesh3D::writeAsVrml
        
            typedef void ( *writeAsVrml_function_type )( ::cv::Mesh3D const &,::cv::String const &,bp::sequence );
            
            Mesh3D_exposer.def( 
                "writeAsVrml"
                , writeAsVrml_function_type( &writeAsVrml_8e53a52859ed45ddf6fdddd9bce7a16a )
                , ( bp::arg("inst"), bp::arg("file"), bp::arg("colors")=convert_vector_to_seq(std::vector<cv::Scalar>()) ) );
        
        }
        Mesh3D_exposer.def_readonly( "allzero", cv::Mesh3D::allzero );
        Mesh3D_exposer.def_readwrite( "octree", &cv::Mesh3D::octree );
        Mesh3D_exposer.def_readwrite( "resolution", &cv::Mesh3D::resolution );
        Mesh3D_exposer.def("__init__", bp::make_constructor(&Mesh3D_init1, bp::default_call_policies(), ( bp::arg("vtx") ))  );
        Mesh3D_exposer.add_property("vtx", &get_vtx);
        Mesh3D_exposer.add_property("normals", &get_normals);
    }

}
