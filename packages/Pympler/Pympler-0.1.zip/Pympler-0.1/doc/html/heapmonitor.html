<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Heapmonitor Documentation &mdash; Pympler v0.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:   '',
          VERSION:    '0.1',
          COLLAPSE_MODINDEX: false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/interface.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html" />
    <link rel="index" title="Global index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="Pympler v0.1 documentation" href="index.html" />
    <link rel="up" title="Sitemap" href="detailed_toc.html" />
    <link rel="next" title="Muppy Documentation" href="muppy/muppy.html" />
    <link rel="prev" title="asizeof Documentation" href="asizeof.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
				</li>
				<li class="right" style="margin-right: 10px">Quick Search:</li>
				<li class="right" style="margin-right: 10px"> |</li>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="muppy/muppy.html" title="Muppy Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="asizeof.html" title="asizeof Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pympler v0.1 documentation</a> &raquo;</li>
          <li><a href="detailed_toc.html" accesskey="U">Sitemap</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="heapmonitor-documentation">
<span id="heapmonitor"></span><h1>Heapmonitor Documentation<a class="headerlink" href="#heapmonitor-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pympler.heapmonitor">
<h2>Introduction<a class="headerlink" href="#module-pympler.heapmonitor" title="Permalink to this headline">¶</a></h2>
<p>The Heapmonitor is a facility delivering insight into the memory distribution of
a Python program. It can introspect memory consumption of certain classes and
objects. Facilities are provided to track and size individual objects or all
instances of certain classes. Tracked objects are sized recursively to provide
an overview of memory distribution between the different tracked objects.</p>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s start with a simple example. Suppose you have this module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Factory</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">create_factory</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">factory</span> <span class="o">=</span> <span class="n">Factory</span><span class="p">()</span>
<span class="gp">... </span>   <span class="n">factory</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Assembly Line Unlimited&quot;</span>
<span class="gp">... </span>   <span class="n">factory</span><span class="o">.</span><span class="n">employees</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">factory</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">populate_factory</span><span class="p">(</span><span class="n">factory</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1000</span><span class="p">):</span>
<span class="gp">... </span>       <span class="n">worker</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">()</span>
<span class="gp">... </span>       <span class="n">worker</span><span class="o">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">name</span>
<span class="gp">... </span>       <span class="n">factory</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span> <span class="o">=</span> <span class="n">create_factory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">populate_factory</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
</pre></div>
</div>
<p>The basic tools of the Heapmonitor are tracking objects or classes, taking
snapshots, and printing or dumping statistics. The first step is to decide what
to track. Then spots of interest for snapshot creation have to be identified.
Finally, the gathered data can be printed or saved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span> <span class="o">=</span> <span class="n">create_factory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pympler</span> <span class="kn">import</span> <span class="n">heapmonitor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_object</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_class</span><span class="p">(</span><span class="n">Employee</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">populate_factory</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapmonitor</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="n">detailed</span><span class="o">=</span><span class="mf">0</span><span class="p">)</span>
<span class="go">---- SUMMARY ------------------------------------------------------------------</span>
<span class="go">                                         active      1.22 MB      average   pct</span>
<span class="go">  Factory                                     1    344     B    344     B    0%</span>
<span class="go">  __main__.Employee                           0      0     B      0     B    0%</span>
<span class="go">                                         active      1.42 MB      average   pct</span>
<span class="go">  Factory                                     1      4.75 KB      4.75 KB    0%</span>
<span class="go">  __main__.Employee                        1000    195.38 KB    200     B   13%</span>
<span class="go">-------------------------------------------------------------------------------</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-functionality">
<h2>Basic Functionality<a class="headerlink" href="#basic-functionality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="instance-tracking">
<h3>Instance Tracking<a class="headerlink" href="#instance-tracking" title="Permalink to this headline">¶</a></h3>
<p>The purpose of instance tracking is to observe the size and lifetime of an
object of interest. Creation and destruction timestamps are recorded and the
size of the object is sampled when taking a snapshot.</p>
<p>To track the size of an individual object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pympler</span> <span class="kn">import</span> <span class="n">heapmonitor</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_object</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<dl class="function">
<dt id="pympler.heapmonitor.track_object">
<!--[pympler.heapmonitor.track_object]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">track_object</tt><big>(</big><em>instance</em>, <em>name=None</em>, <em>resolution_level=0</em>, <em>keep=0</em>, <em>trace=0</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.track_object" title="Permalink to this definition">¶</a></dt>
<dd>Track object &#8216;instance&#8217; and sample size and lifetime information.
Not all objects can be tracked; trackable objects are class instances and
other objects that can be weakly referenced. When an object cannot be
tracked, a TypeError is raised.
The &#8216;resolution_level&#8217; is the recursion depth up to which referents are
sized individually. Resolution level 0 (default) treats the object as an
opaque entity, 1 sizes all direct referents individually, 2 also sizes the
referents of the referents and so forth.
To prevent the object&#8217;s deletion a (strong) reference can be held with
&#8216;keep&#8217;.</dd></dl>

</div>
<div class="section" id="class-tracking">
<h3>Class Tracking<a class="headerlink" href="#class-tracking" title="Permalink to this headline">¶</a></h3>
<p>Most of the time, it&#8217;s cumbersome to manually track individual instances. All
instances of a class can automatically be tracked with <em>track_class</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_class</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>
</pre></div>
</div>
<p>All instances of <cite>MyClass</cite> (or a class that inherits from <cite>MyClass</cite>) created
hereafter are tracked.</p>
<dl class="function">
<dt id="pympler.heapmonitor.track_class">
<!--[pympler.heapmonitor.track_class]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">track_class</tt><big>(</big><em>cls</em>, <em>name=None</em>, <em>resolution_level=0</em>, <em>keep=0</em>, <em>trace=0</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.track_class" title="Permalink to this definition">¶</a></dt>
<dd>Track all objects of the class <cite>cls</cite>. Objects of that type that already
exist are <em>not</em> tracked. If <cite>track_class</cite> is called for a class already
tracked, the tracking parameters are modified. Instantiation traces can be
generated by setting <cite>trace</cite> to True. 
A constructor is injected to begin instance tracking on creation
of the object. The constructor calls <cite>track_object</cite> internally.</dd></dl>

</div>
<div class="section" id="tracked-object-snapshot">
<h3>Tracked Object Snapshot<a class="headerlink" href="#tracked-object-snapshot" title="Permalink to this headline">¶</a></h3>
<p>Tracking alone will not reveal the size of an object. The idea of the
Heapmonitor is to sample the sizes of all tracked objects at configurable
instants in time. The <cite>create_snapshot</cite> function computes the size of all
tracked objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">(</span><span class="s">&#39;Before juggling with tracked objects&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">(</span><span class="s">&#39;Juggling aftermath&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>With this information, the distribution of the allocated memory can be
apportioned to tracked classes and instances.</p>
<dl class="function">
<dt id="pympler.heapmonitor.create_snapshot">
<!--[pympler.heapmonitor.create_snapshot]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">create_snapshot</tt><big>(</big><em>description=''</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd>Collect current per instance statistics.
Save total amount of memory consumption reported by asizeof and by the
operating system. The overhead of the Heapmonitor structure is also
computed.</dd></dl>

</div>
<div class="section" id="print-statistics">
<h3>Print Statistics<a class="headerlink" href="#print-statistics" title="Permalink to this headline">¶</a></h3>
<p>The gathered data can be investigated with <cite>print_stats</cite>. This prints all
available data. To filter and limit the output the more powerful &#8220;Off-line
analysis&#8221; API can be used instead.</p>
<dl class="function">
<dt id="pympler.heapmonitor.print_stats">
<!--[pympler.heapmonitor.print_stats]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">print_stats</tt><big>(</big><em>fobj=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0xb7ec0068&gt;</em>, <em>detailed=1</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Write tracked objects by class to stdout. The size for each tracked object
is printed and a per-snapshot summary is printed. If <cite>detailed</cite> is set to
false, the per object statistics are omitted.</p>
<p>If background monitoring is activated, stop asynchronous snapshots to
prevent the data of changing while being printed. The side effect can be
lags, especially when a long period has been set.</p>
</dd></dl>

</div>
</div>
<div class="section" id="advanced-functionality">
<h2>Advanced Functionality<a class="headerlink" href="#advanced-functionality" title="Permalink to this headline">¶</a></h2>
<div class="section" id="per-referent-sizing">
<h3>Per-referent Sizing<a class="headerlink" href="#per-referent-sizing" title="Permalink to this headline">¶</a></h3>
<p>It may not be enough to know the total memory consumption of an object.
Detailed per-referent statistics can be gathered recursively up to a given
resolution level. Resolution level 1 means that all direct referents of an
object will be sized. Level 2 also include the referents of the direct
referents, and so forth. Note that the member variables of an instance are
typically stored in a dictionary and are therefore second order referents.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">resolution_level</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The resolution level can be changed if the object is already tracked:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_change</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">resolution_level</span><span class="o">=</span><span class="mf">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The new setting will become effective for the next snapshot. This can help to
raise the level of detail for a specific instance of a tracked class without
logging all the class&#8217; instances with a high verbosity level. Nevertheless, the
resolution level can also be set for all instances of a class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_class</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span> <span class="n">resolution_level</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Please note the per-referent sizing is very memory and computationally
intensive. The recorded meta-data must be stored for each referent of a tracked
object which might easily quadruplicate the memory footprint of the build.
Handle with care and don&#8217;t use too high resolution levels, especially if set
via <cite>track_class</cite>.</p>
</div>
</div>
<div class="section" id="instantiation-traces">
<h3>Instantiation traces<a class="headerlink" href="#instantiation-traces" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is not trivial to observe where an object was instantiated. The
Heapmonitor can remember the instantiation stack trace for later evaluation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_class</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This only works with tracked classes, and <strong>not</strong> with individual objects.</p>
</div>
<div class="section" id="background-monitoring">
<h3>Background Monitoring<a class="headerlink" href="#background-monitoring" title="Permalink to this headline">¶</a></h3>
<p>The Heapmonitor can be configured to take periodic snapshots automatically. The
following example will take 10 snapshots a second (approximately) until the
program has exited or the periodic snapshots are stopped with
<cite>stop_periodic_snapshots</cite>. Background monitoring also works if no object is
tracked. In this mode, the Heapmonitor will only record the total virtual
memory associated with the program. This can be useful in combination with
background monitoring to detect memory usage which is transient or not
associated with any tracked object.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">start_periodic_snapshots</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Take care if you use automatic snapshots with tracked objects. The sizing
of individual objects might be inconsistent when memory is allocated or freed
while the snapshot is being taken.</p>
</div>
<dl class="function">
<dt id="pympler.heapmonitor.start_periodic_snapshots">
<!--[pympler.heapmonitor.start_periodic_snapshots]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">start_periodic_snapshots</tt><big>(</big><em>interval=1.0</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.start_periodic_snapshots" title="Permalink to this definition">¶</a></dt>
<dd>Start a thread which takes snapshots periodically. The <cite>interval</cite> specifies
the time in seconds the thread waits between taking snapshots. The thread is
started as a daemon allowing the program to exit. If periodic snapshots are
already active, the interval is updated.</dd></dl>

<dl class="function">
<dt id="pympler.heapmonitor.stop_periodic_snapshots">
<!--[pympler.heapmonitor.stop_periodic_snapshots]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">stop_periodic_snapshots</tt><big>(</big><big>)</big><a class="headerlink" href="#pympler.heapmonitor.stop_periodic_snapshots" title="Permalink to this definition">¶</a></dt>
<dd>Post a stop signal to the thread that takes the periodic snapshots. The
function waits for the thread to terminate which can take some time
depending on the configured interval.</dd></dl>

</div>
<div class="section" id="off-line-analysis">
<h3>Off-line Analysis<a class="headerlink" href="#off-line-analysis" title="Permalink to this headline">¶</a></h3>
<p>The more data is gathered by the Heapmonitor the more noise is produced on the
console. The acquired Heapmonitor log data can also be saved to a file for
off-line analysis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s">&#39;heap-profile.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>MemStats</cite> class of the Heapmonitor provides means to evaluate the collected
data. The API is inspired by the <a class="reference" href="http://docs.python.org/lib/profile-stats.html">Stats class</a> of the Python profiler. It is
possible to sort the data based on user preferences, filter by class and limit
the output noise to a manageable magnitude.</p>
<p>The following example reads the dumped data and prints the ten largest Node
objects to the standard output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pympler.heapmonitor</span> <span class="kn">import</span> <span class="n">MemStats</span>

<span class="n">stats</span> <span class="o">=</span> <span class="n">MemStats</span><span class="p">()</span>
<span class="n">stats</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;heap.dat&#39;</span><span class="p">)</span>
<span class="n">stats</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mf">10</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="s">&#39;Node&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="pympler.heapmonitor.MemStats">
<!--[pympler.heapmonitor.MemStats]-->class <tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">MemStats</tt><big>(</big><em>filename=None</em>, <em>stream=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0xb7ec0068&gt;</em>, <em>tracked=None</em>, <em>snapshots=None</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats" title="Permalink to this definition">¶</a></dt>
<dd><p>Presents the gathered memory statisitics based on user preferences.</p>
<dl class="method">
<dt id="pympler.heapmonitor.MemStats.load_stats">
<!--[pympler.heapmonitor.MemStats.load_stats]--><tt class="descname">load_stats</tt><big>(</big><em>fdump</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats.load_stats" title="Permalink to this definition">¶</a></dt>
<dd>Load the data from a dump file.
The argument <cite>fdump</cite> can be either a filename or a an open file object
that requires read access.</dd></dl>

<dl class="method">
<dt id="pympler.heapmonitor.MemStats.sort_stats">
<!--[pympler.heapmonitor.MemStats.sort_stats]--><tt class="descname">sort_stats</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats.sort_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the tracked objects according to the supplied criteria. The
argument is a string identifying the basis of a sort (example: &#8216;size&#8217; or
&#8216;classname&#8217;). When more than one key is provided, then additional keys
are used as secondary criteria when there is equality in all keys
selected before them. For example, sort_stats(&#8216;name&#8217;, &#8216;size&#8217;) will sort
all the entries according to their class name, and resolve all ties
(identical class names) by sorting by size.  The criteria are fields in
the tracked object instances. Results are stored in the <cite>self.sorted</cite>
list which is used by <cite>MemStats.print_stats()</cite> and other methods. The
fields available for sorting are:</p>
<blockquote>
&#8216;classname&#8217; : the name with which the class was registered
&#8216;name&#8217;      : the classname
&#8216;birth&#8217;     : creation timestamp
&#8216;death&#8217;     : destruction timestamp
&#8216;size&#8217;      : the maximum measured size of the object
&#8216;tsize&#8217;     : the measured size during the largest snapshot
&#8216;repr&#8217;      : string representation of the object</blockquote>
<p>Note that sorts on size are in descending order (placing most memory
consuming items first), whereas name, repr, and creation time searches
are in ascending order (alphabetical).</p>
<p>The function returns self to allow calling functions on the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stats</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reverse_order</span><span class="p">()</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pympler.heapmonitor.MemStats.print_stats">
<!--[pympler.heapmonitor.MemStats.print_stats]--><tt class="descname">print_stats</tt><big>(</big><em>filter=None</em>, <em>limit=1.0</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats.print_stats" title="Permalink to this definition">¶</a></dt>
<dd>Write tracked objects to stdout.  The output can be filtered and pruned.
Only objects are printed whose classname contain the substring supplied
by the <cite>filter</cite> argument.  The output can be pruned by passing a limit
value. If <cite>limit</cite> is a float smaller than one, only the supplied
percentage of the total tracked data is printed. If <cite>limit</cite> is bigger
than one, this number of tracked objects are printed. Tracked objects
are first filtered, and then pruned (if specified).</dd></dl>

<dl class="method">
<dt id="pympler.heapmonitor.MemStats.dump_stats">
<!--[pympler.heapmonitor.MemStats.dump_stats]--><tt class="descname">dump_stats</tt><big>(</big><em>fdump</em>, <em>close=1</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats.dump_stats" title="Permalink to this definition">¶</a></dt>
<dd>Dump the logged data to a file.
The argument <cite>file</cite> can be either a filename or a an open file object
that requires write access. <cite>close</cite> controls if the file is closed
before leaving this method (the default behaviour).</dd></dl>

<dl class="method">
<dt id="pympler.heapmonitor.MemStats.reverse_order">
<!--[pympler.heapmonitor.MemStats.reverse_order]--><tt class="descname">reverse_order</tt><big>(</big><big>)</big><a class="headerlink" href="#pympler.heapmonitor.MemStats.reverse_order" title="Permalink to this definition">¶</a></dt>
<dd>Reverse the order of the tracked instance index <cite>self.sorted</cite>.</dd></dl>

</dd></dl>

</div>
<div class="section" id="html-statistics">
<h3>HTML Statistics<a class="headerlink" href="#html-statistics" title="Permalink to this headline">¶</a></h3>
<p>The Heapmonitor data can also be emitted in HTML format together with a number
of charts (needs python-matplotlib). HTML statistics can be emitted directly,
by specifying a file with the extension <em>.html</em> file as the profiling output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">heapmonitor</span><span class="o">.</span><span class="n">dump_stats</span><span class="p">(</span><span class="s">&#39;heap-profile.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>However, you can also reprocess a previously generated dump:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pympler.heapmonitor</span> <span class="kn">import</span> <span class="n">HtmlStats</span>

<span class="n">stats</span> <span class="o">=</span> <span class="n">HtmlStats</span><span class="p">(</span><span class="s">&#39;heap-profile.dat&#39;</span><span class="p">)</span>
<span class="n">stats</span><span class="o">.</span><span class="n">create_html</span><span class="p">(</span><span class="s">&#39;heap-profile.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="pympler.heapmonitor.HtmlStats">
<!--[pympler.heapmonitor.HtmlStats]-->class <tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">HtmlStats</tt><big>(</big><em>filename=None</em>, <em>stream=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0xb7ec0068&gt;</em>, <em>tracked=None</em>, <em>snapshots=None</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.HtmlStats" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the Heapmonitor statistics as HTML pages and graphs.</p>
<dl class="method">
<dt id="pympler.heapmonitor.HtmlStats.create_html">
<!--[pympler.heapmonitor.HtmlStats.create_html]--><tt class="descname">create_html</tt><big>(</big><em>fname</em>, <em>title='Heapmonitor Statistics'</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.HtmlStats.create_html" title="Permalink to this definition">¶</a></dt>
<dd>Create HTML page <cite>fname</cite> and additional files in a directory derived
from <cite>fname</cite>.</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="tracking-garbage">
<h2>Tracking Garbage<a class="headerlink" href="#tracking-garbage" title="Permalink to this headline">¶</a></h2>
<p>Garbage occurs if objects refer too each other in a circular fashion. Such
reference cycles cannot be freed automatically and must be collected by the
garbage collector. While it is sometimes hard to avoid creating reference
cycles, preventing such cycles saves garbage collection time and limits the
lifetime of objects. Moreover, some objects cannot be collected by the garbage
collector.</p>
<p>The Heapmonitor provides functions to analyze reference cycles of collectable
objects. When the garbage collector is turned off, the garbage can be kept for
debugging purposes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pympler</span> <span class="kn">import</span> <span class="n">heapmonitor</span>

<span class="n">heapmonitor</span><span class="o">.</span><span class="n">start_debug_garbage</span><span class="p">()</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="c"># produce cycle</span>

<span class="n">heapmonitor</span><span class="o">.</span><span class="n">print_garbage_stats</span><span class="p">()</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">end_debug_garbage</span><span class="p">()</span>
</pre></div>
</div>
<p>Reference cycles can be visualized with <a class="reference" href="http://www.graphviz.org">graphviz</a>.
A graphviz input file is generated when <cite>visualize_ref_cycles</cite> is invoked:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pympler</span> <span class="kn">import</span> <span class="n">heapmonitor</span>

<span class="n">heapmonitor</span><span class="o">.</span><span class="n">start_debug_garbage</span><span class="p">()</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="c"># produce cycle</span>

<span class="n">heapmonitor</span><span class="o">.</span><span class="n">visualize_ref_cycles</span><span class="p">(</span><span class="s">&#39;leakgraph.txt&#39;</span><span class="p">)</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">end_debug_garbage</span><span class="p">()</span>
</pre></div>
</div>
<p>On Linux, the graph file can be turned into a PDF with the following commands:</p>
<div class="highlight-python"><pre>dot -o leakgraph.dot leakgraph.txt
dot leakgraph.dot -Tps -o leakgraph.eps
epstopdf leakgraph.eps</pre>
</div>
<dl class="function">
<dt id="pympler.heapmonitor.start_debug_garbage">
<!--[pympler.heapmonitor.start_debug_garbage]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">start_debug_garbage</tt><big>(</big><big>)</big><a class="headerlink" href="#pympler.heapmonitor.start_debug_garbage" title="Permalink to this definition">¶</a></dt>
<dd>Turn off garbage collector to analyze <em>collectable</em> reference cycles.</dd></dl>

<dl class="function">
<dt id="pympler.heapmonitor.end_debug_garbage">
<!--[pympler.heapmonitor.end_debug_garbage]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">end_debug_garbage</tt><big>(</big><big>)</big><a class="headerlink" href="#pympler.heapmonitor.end_debug_garbage" title="Permalink to this definition">¶</a></dt>
<dd>Turn garbage collection on and disable debug output.</dd></dl>

<dl class="function">
<dt id="pympler.heapmonitor.print_garbage_stats">
<!--[pympler.heapmonitor.print_garbage_stats]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">print_garbage_stats</tt><big>(</big><em>fobj=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0xb7ec0068&gt;</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.print_garbage_stats" title="Permalink to this definition">¶</a></dt>
<dd>Print statistics related to garbage/leaks.
This function collects the reported garbage. Therefore, subsequent
invocations of <cite>print_garbage_stats</cite> will not report the same objects again.</dd></dl>

<dl class="function">
<dt id="pympler.heapmonitor.visualize_ref_cycles">
<!--[pympler.heapmonitor.visualize_ref_cycles]--><tt class="descclassname">pympler.heapmonitor.</tt><tt class="descname">visualize_ref_cycles</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#pympler.heapmonitor.visualize_ref_cycles" title="Permalink to this definition">¶</a></dt>
<dd>Print reference cycles of collectable garbage to a file which can be
processed by Graphviz.
This function collects the reported garbage. Therefore, subsequent
invocations of <cite>print_garbage_stats</cite> will not report the same objects again.</dd></dl>

</div>
<div class="section" id="limitations-and-corner-cases">
<h2>Limitations and Corner Cases<a class="headerlink" href="#limitations-and-corner-cases" title="Permalink to this headline">¶</a></h2>
<div class="section" id="inheritance">
<h3>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h3>
<p>Class tracking allows to observe multiple classes that might have an
inheritance relationship. An object is only tracked once. Thus, the tracking
parameters of the most specialized tracked class control the actual tracking of
an instance.</p>
</div>
<div class="section" id="morphing-objects">
<h3>Morphing objects<a class="headerlink" href="#morphing-objects" title="Permalink to this headline">¶</a></h3>
<p>SCons instates the pattern of changing an instance&#8217; class at runtime, for
example to morph abstract Node objects into File or Directory nodes. The
pattern looks like the following in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">obj</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">OtherClass</span>
</pre></div>
</div>
<p>If the instance which is morphed is already tracked, the instance will continue
to be tracked by the Heapmonitor. If the target class is tracked but the
instance is not, the instance will only be tracked if the constructor of the
target class is called as part of the morphing process. The object will not be
re-registered to the new class in the tracked object index. However, the new
class is stored in the representation of the object as soon as the object is
sized.</p>
</div>
<div class="section" id="shared-data">
<h3>Shared Data<a class="headerlink" href="#shared-data" title="Permalink to this headline">¶</a></h3>
<p>Data shared between multiple tracked object won&#8217;t lead to overestimations.
Shared data will be assigned to the first (evaluated) tracked object it is
referenced from, but is only counted once. Tracked objects are evaluated in the
order they were announced to the Heapmonitor. This should make the assignment
deterministic from one run to the next, but has two known problems. If the
Heapmonitor is used concurrently from multiple threads, the announcement order
will likely change and may lead to random assignment of shared data to
different objects. Shared data might also be assigned to different objects
during its lifetime, see the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">():</span>
  <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_object</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">track_object</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mf">100000</span><span class="p">)</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">(</span><span class="s">&#39;#1&#39;</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">notmine</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">content</span>
<span class="n">heapmonitor</span><span class="o">.</span><span class="n">create_snapshot</span><span class="p">(</span><span class="s">&#39;#2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the snapshot #1, <em>b</em>&#8216;s size will include the size of the large list. Then
the list is shared with <em>a</em>. The snapshot <em>#2</em> will assign the list&#8217;s footprint
to <em>a</em> because it was registered before <em>b</em>.</p>
<p>If a tracked object <em>A</em> is referenced from another tracked object <em>B</em>,
<em>A</em>&#8216;s size is not added to <em>B</em>&#8216;s size, regardless of the order in which they
are sized.</p>
</div>
<div class="section" id="accuracy">
<h3>Accuracy<a class="headerlink" href="#accuracy" title="Permalink to this headline">¶</a></h3>
<p>Heapmonitor uses the <cite>sizer</cite> module to gather size informations. Asizeof makes
assumptions about the memory footprint of the various data types. As it is
implemented in pure Python, there is no way to know how the actual Python
implementation allocates data and lays it out in memory. Thus, the size numbers
are not really accurate and there will always be a divergence between the
virtual size of the SCons process as reported by the OS and the sizes asizeof
estimates.</p>
<p>Most recent C/Python versions contain a <a class="reference" href="http://bugs.python.org/issue2898">facility to report accurate size
informations</a> of Python objects. If available,
asizeof uses it to improve the accuracy.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
				</li>
				<li class="right" style="margin-right: 10px">Quick Search:</li>
				<li class="right" style="margin-right: 10px"> |</li>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="muppy/muppy.html" title="Muppy Documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="asizeof.html" title="asizeof Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pympler v0.1 documentation</a> &raquo;</li>
          <li><a href="detailed_toc.html" accesskey="U">Sitemap</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="copyright.html">Copyright</a> 2008, Jean Brouwers, Ludwig Haehne, Robert Schuppenies.
      Last updated on Dec 11, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>