Template classes
================

The ``chameleon.genshi`` package provides the ``GenshiTemplate`` and
``GenshiTemplateFile`` classes which allow easy usage of templates in
your application.

Usage
-----

  >>> from chameleon.genshi.template import GenshiTemplate
  
  >>> print GenshiTemplate("""\
  ... <div xmlns="http://www.w3.org/1999/xhtml">
  ...   Hello World!
  ... </div>""")()
  <div>
    Hello World!
  </div>

  >>> from chameleon.genshi.template import GenshiTemplateFile
  >>> from chameleon.genshi import tests
  
  >>> path = tests.__path__[0]
  >>> t = GenshiTemplateFile(path+'/helloworld.html')
  >>> print t()
  <div>
    Hello World!
  </div>

  >>> import os
  >>> t.filename.startswith(os.sep)
  True

Compiler integration
--------------------

Certain constructs require close collaboration between the template
compiler and the page template classes.

py:match

  >>> print GenshiTemplate("""\
  ... <div xmlns="http://www.w3.org/1999/xhtml"
  ...      xmlns:py="http://genshi.edgewall.org/">
  ...   <py:match path=".//xmlns:greeting">Hello ${select('@name')[0]}!</py:match>
  ...   <greeting name="World" />
  ... </div>
  ... """)()
  <div>
    Hello World!
  </div>

XInclude-support
----------------

When using XInclude-statements in Genshi, macro-definitions are
carried over from the included template. This is demonstrated below.

  >>> template1 = GenshiTemplateFile(path+"/xinclude1.html")
  >>> template2 = GenshiTemplateFile(path+"/xinclude2.html")
  
  >>> print template1()
  <div>
    <p class="greeting">
      Hello, world!
    </p>
  </div>

Before we proceed, we reduce and restore the underlying byte-code
template.
  
  >>> from cPickle import dumps, loads
  >>> for registry in (template1.registry, template2.registry):
  ...     for key, bct in registry.items():
  ...         registry[key] = loads(dumps(bct))

  >>> print template1()
  <div>
    <p class="greeting">
      Hello, world!
    </p>
  </div>
  
