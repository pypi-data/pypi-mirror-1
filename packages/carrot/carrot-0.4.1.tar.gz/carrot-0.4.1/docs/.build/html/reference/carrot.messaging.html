<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>carrot.messaging &mdash; Carrot v0.4.1 documentation</title>
    <link rel="stylesheet" href="../static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    '../',
      VERSION:     '0.4.1',
      COLLAPSE_MODINDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="top" title="Carrot v0.4.1 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
    <link rel="next" title="carrot.backends" href="carrot.backends.html" />
    <link rel="prev" title="carrot.connection" href="carrot.connection.html" /> 
  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
	<h1><a href="../index.html">Carrot v0.4.1 documentation</a></h1>
	<div class="rel">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a> |
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |
          <a href="carrot.backends.html" title="carrot.backends"
             accesskey="N">next</a> |
          <a href="carrot.connection.html" title="carrot.connection"
             accesskey="P">previous</a>
	</div>
      </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
	<div class="document">
	  <div class="documentwrapper">
	    <div class="bodywrapper">
	      <div class="body">
		
  <div class="section" id="module-carrot.messaging">
<h1>carrot.messaging<a class="headerlink" href="#module-carrot.messaging" title="Permalink to this headline">¶</a></h1>
<p>The introduction to carrot that was here previously has been moved
to the <a class="reference external" href="http://ask.github.com/carrot/introduction.html#examples">introduction</a> page.</p>
<p>Sending/Receiving Messages.</p>
<dl class="class">
<dt id="carrot.messaging.Consumer">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Consumer</tt><big>(</big><em>connection</em>, <em>queue=None</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Message consumer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Consumer.connection" class="reference internal" href="#carrot.messaging.Consumer.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>queue</em> &#8211; see <a title="carrot.messaging.Consumer.queue" class="reference internal" href="#carrot.messaging.Consumer.queue"><tt class="xref docutils literal"><span class="pre">queue</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Consumer.exchange" class="reference internal" href="#carrot.messaging.Consumer.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>durable</em> &#8211; see <a title="carrot.messaging.Consumer.durable" class="reference internal" href="#carrot.messaging.Consumer.durable"><tt class="xref docutils literal"><span class="pre">durable</span></tt></a>.</li>
<li><em>auto_delete</em> &#8211; see <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.</li>
<li><em>exclusive</em> &#8211; see <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a>.</li>
<li><em>exchange_type</em> &#8211; see <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a>.</li>
<li><em>decoder</em> &#8211; see <a title="carrot.messaging.Consumer.decoder" class="reference internal" href="#carrot.messaging.Consumer.decoder"><tt class="xref docutils literal"><span class="pre">decoder</span></tt></a>.</li>
<li><em>backend_cls</em> &#8211; see <a title="carrot.messaging.Consumer.backend_cls" class="reference internal" href="#carrot.messaging.Consumer.backend_cls"><tt class="xref docutils literal"><span class="pre">backend_cls</span></tt></a>.</li>
<li><em>auto_ack</em> &#8211; see <a title="carrot.messaging.Consumer.auto_ack" class="reference internal" href="#carrot.messaging.Consumer.auto_ack"><tt class="xref docutils literal"><span class="pre">auto_ack</span></tt></a>.</li>
<li><em>no_ack</em> &#8211; see <a title="carrot.messaging.Consumer.no_ack" class="reference internal" href="#carrot.messaging.Consumer.no_ack"><tt class="xref docutils literal"><span class="pre">no_ack</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Consumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Consumer.connection" title="Permalink to this definition">¶</a></dt>
<dd>A <a title="carrot.connection.AMQPConnection" class="reference external" href="carrot.connection.html#carrot.connection.AMQPConnection"><tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt></a> instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.queue">
<tt class="descname">queue</tt><a class="headerlink" href="#carrot.messaging.Consumer.queue" title="Permalink to this definition">¶</a></dt>
<dd>Name of the queue.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange the queue binds to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Consumer.routing_key" title="Permalink to this definition">¶</a></dt>
<dd><p>The routing key (if any). The interpretation of the routing key
depends on the value of the <a title="carrot.messaging.Consumer.exchange_type" class="reference internal" href="#carrot.messaging.Consumer.exchange_type"><tt class="xref docutils literal"><span class="pre">exchange_type</span></tt></a> attribute:</p>
<blockquote>
<ul>
<li><p class="first">direct exchange</p>
<blockquote>
<p>Matches if the routing key property of the message and
the <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a> attribute are identical.</p>
</blockquote>
</li>
<li><p class="first">fanout exchange</p>
<blockquote>
<p>Always matches, even if the binding does not have a key.</p>
</blockquote>
</li>
<li><p class="first">topic exchange</p>
<blockquote>
<p>Matches the routing key property of the message by a primitive
pattern matching scheme. The message routing key then consists
of words separated by dots (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>, like domain names), and
two special characters are available; star (<tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>) and hash
(<tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>). The star matches any word, and the hash matches
zero or more words. For example <tt class="docutils literal"><span class="pre">&quot;*.stock.#&quot;</span></tt> matches the
routing keys <tt class="docutils literal"><span class="pre">&quot;usd.stock&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;eur.stock.db&quot;</span></tt> but not
<tt class="docutils literal"><span class="pre">&quot;stock.nasdaq&quot;</span></tt>.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.durable">
<tt class="descname">durable</tt><a class="headerlink" href="#carrot.messaging.Consumer.durable" title="Permalink to this definition">¶</a></dt>
<dd>Durable exchanges remain active when a server restarts. Non-durable
exchanges (transient exchanges) are purged when a server restarts.
Default is <tt class="xref docutils literal"><span class="pre">True</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_delete">
<tt class="descname">auto_delete</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_delete" title="Permalink to this definition">¶</a></dt>
<dd>If set, the exchange is deleted when all queues have finished
using it. Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exclusive">
<tt class="descname">exclusive</tt><a class="headerlink" href="#carrot.messaging.Consumer.exclusive" title="Permalink to this definition">¶</a></dt>
<dd>Exclusive queues may only be consumed from by the current connection.
When <a title="carrot.messaging.Consumer.exclusive" class="reference internal" href="#carrot.messaging.Consumer.exclusive"><tt class="xref docutils literal"><span class="pre">exclusive</span></tt></a> is on, this also implies <a title="carrot.messaging.Consumer.auto_delete" class="reference internal" href="#carrot.messaging.Consumer.auto_delete"><tt class="xref docutils literal"><span class="pre">auto_delete</span></tt></a>.
Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange_type">
<tt class="descname">exchange_type</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange_type" title="Permalink to this definition">¶</a></dt>
<dd><p>AMQP defines four default exchange types (routing algorithms) that
covers most of the common messaging use cases. An AMQP broker can
also define additional exchange types, so see your message brokers
manual for more information about available exchange types.</p>
<blockquote>
<ul>
<li><p class="first">Direct</p>
<blockquote>
<p>Direct match between the routing key in the message, and the
routing criteria used when a queue is bound to this exchange.</p>
</blockquote>
</li>
<li><p class="first">Topic</p>
<blockquote>
<p>Wildcard match between the routing key and the routing pattern
specified in the binding. The routing key is treated as zero
or more words delimited by <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> and supports special
wildcard characters. <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> matches a single word and <tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>
matches zero or more words.</p>
</blockquote>
</li>
<li><p class="first">Fanout</p>
<blockquote>
<p>Queues are bound to this exchange with no arguments. Hence any
message sent to this exchange will be forwarded to all queues
bound to this exchange.</p>
</blockquote>
</li>
<li><p class="first">Headers</p>
<blockquote>
<p>Queues are bound to this exchange with a table of arguments
containing headers and values (optional). A special argument
named &#8220;x-match&#8221; determines the matching algorithm, where
<tt class="docutils literal"><span class="pre">&quot;all&quot;</span></tt> implies an <tt class="docutils literal"><span class="pre">AND</span></tt> (all pairs must match) and
<tt class="docutils literal"><span class="pre">&quot;any&quot;</span></tt> implies <tt class="docutils literal"><span class="pre">OR</span></tt> (at least one pair must match).</p>
<dl class="docutils">
<dt><em>NOTE</em>: carrot has poor support for header exchanges at</dt>
<dd><p class="first last">this point.</p>
</dd>
</dl>
</blockquote>
</li>
</ul>
<p>This description of AMQP exchange types was shamelessly stolen
from the blog post <a class="reference external" href="http://bit.ly/amqp-exchange-types">AMQP in 10 minutes: Part 4</a> by
Rajith Attapattu. Recommended reading.</p>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.decoder">
<tt class="descname">decoder</tt><a class="headerlink" href="#carrot.messaging.Consumer.decoder" title="Permalink to this definition">¶</a></dt>
<dd>A function able to deserialize the message body.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.backend_cls">
<tt class="descname">backend_cls</tt><a class="headerlink" href="#carrot.messaging.Consumer.backend_cls" title="Permalink to this definition">¶</a></dt>
<dd>The messaging backend class used. Defaults to the <tt class="docutils literal"><span class="pre">pyamqplib</span></tt>
backend.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.callbacks">
<tt class="descname">callbacks</tt><a class="headerlink" href="#carrot.messaging.Consumer.callbacks" title="Permalink to this definition">¶</a></dt>
<dd>List of registered callbacks to trigger when a message is received
by <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.warn_if_exists">
<tt class="descname">warn_if_exists</tt><a class="headerlink" href="#carrot.messaging.Consumer.warn_if_exists" title="Permalink to this definition">¶</a></dt>
<dd>Emit a warning if the queue has already been declared. If a queue
already exists, and you try to redeclare the queue with new settings,
the new settings will be silently ignored, so this can be
useful if you&#8217;ve recently changed the <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a> attribute
or other settings.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_ack">
<tt class="descname">auto_ack</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_ack" title="Permalink to this definition">¶</a></dt>
<dd>Acknowledgement is handled automatically once messages are received.
This means that the <a title="carrot.backends.base.BaseMessage.ack" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.ack"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage.ack()</span></tt></a> and
<a title="carrot.backends.base.BaseMessage.reject" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.reject"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage.reject()</span></tt></a> methods
on the message object are no longer valid.
By default <a title="carrot.messaging.Consumer.auto_ack" class="reference internal" href="#carrot.messaging.Consumer.auto_ack"><tt class="xref docutils literal"><span class="pre">auto_ack</span></tt></a> is set to <tt class="xref docutils literal"><span class="pre">False</span></tt>, and the receiver is
required to manually handle acknowledgment.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.no_ack">
<tt class="descname">no_ack</tt><a class="headerlink" href="#carrot.messaging.Consumer.no_ack" title="Permalink to this definition">¶</a></dt>
<dd>Disable acknowledgement on the server-side. This is different from
<a title="carrot.messaging.Consumer.auto_ack" class="reference internal" href="#carrot.messaging.Consumer.auto_ack"><tt class="xref docutils literal"><span class="pre">auto_ack</span></tt></a> in that acknowledgement is turned off altogether.
This functionality increases performance but at the cost of
reliability. Messages can get lost if a client dies before it can
deliver them to the application.</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises amqplib.client_0_8.channel.AMQPChannelException:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the queue is
exclusive and the queue already exists and is owned by another
connection.</td>
</tr>
</tbody>
</table>
<p>Example Usage</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">Consumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">DjangoAMQPConnection</span><span class="p">(),</span>
<span class="gp">... </span>              <span class="n">queue</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_message</span><span class="p">(</span><span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got message </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>            <span class="n">message</span><span class="o">.</span><span class="n">delivery_tag</span><span class="p">,</span> <span class="n">message_data</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">process_message</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into receive loop</span>
</pre></div>
</div>
<dl class="attribute">
<dt>
<tt class="descname">backend_cls</tt></dt>
<dd>alias of <tt class="xref docutils literal"><span class="pre">Backend</span></tt></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.close" title="Permalink to this definition">¶</a></dt>
<dd>Close the channel to the queue.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.discard_all">
<tt class="descname">discard_all</tt><big>(</big><em>filterfunc=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.discard_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all waiting messages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>filterfunc</em> &#8211; A filter function to only discard the messages this
filter returns.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the number of messages discarded.</td>
</tr>
</tbody>
</table>
<p><em>WARNING</em>: All incoming messages will be ignored and not processed.</p>
<p>Example using filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">waiting_feeds_only</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">message_data</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">except</span><span class="p">:</span> <span class="c"># Should probably be more specific.</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;feed&quot;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.fetch">
<tt class="descname">fetch</tt><big>(</big><em>no_ack=None</em>, <em>auto_ack=None</em>, <em>enable_callbacks=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the next message waiting on the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance,
or <tt class="xref docutils literal"><span class="pre">None</span></tt> if there&#8217;s no messages to be received.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>enable_callbacks</em> &#8211; Enable callbacks. The message will be
processed with all registered callbacks. Default is disabled.</li>
<li><em>auto_ack</em> &#8211; Override the default <a title="carrot.messaging.Consumer.auto_ack" class="reference internal" href="#carrot.messaging.Consumer.auto_ack"><tt class="xref docutils literal"><span class="pre">auto_ack</span></tt></a> setting.</li>
<li><em>no_ack</em> &#8211; Override the default <a title="carrot.messaging.Consumer.no_ack" class="reference internal" href="#carrot.messaging.Consumer.no_ack"><tt class="xref docutils literal"><span class="pre">no_ack</span></tt></a> setting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterconsume">
<tt class="descname">iterconsume</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterconsume" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator processing new messages as they arrive.
Every new message will be passed to the callbacks, and the iterator
returns <tt class="xref docutils literal"><span class="pre">True</span></tt>. The iterator is infinite unless the <tt class="docutils literal"><span class="pre">limit</span></tt>
argument is specified or someone closes the consumer.</p>
<p><a title="carrot.messaging.Consumer.iterconsume" class="reference internal" href="#carrot.messaging.Consumer.iterconsume"><tt class="xref docutils literal"><span class="pre">iterconsume()</span></tt></a> uses transient requests for messages on the
server, while <tt class="xref docutils literal"><span class="pre">iterequeue()</span></tt> uses synchronous access. In most
cases you want <a title="carrot.messaging.Consumer.iterconsume" class="reference internal" href="#carrot.messaging.Consumer.iterconsume"><tt class="xref docutils literal"><span class="pre">iterconsume()</span></tt></a>, but if your environment does not
support this behaviour you can resort to using <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>
instead.</p>
<p>Also, <a title="carrot.messaging.Consumer.iterconsume" class="reference internal" href="#carrot.messaging.Consumer.iterconsume"><tt class="xref docutils literal"><span class="pre">iterconsume()</span></tt></a> does not return the message
at each step, something which <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a> does.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>limit</em> &#8211; Maximum number of messages to process.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises StopIteration:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if limit is set and the message limit has been
reached.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterqueue">
<tt class="descname">iterqueue</tt><big>(</big><em>limit=None</em>, <em>infinite=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinite iterator yielding pending messages, by using
synchronous direct access to the queue (<tt class="docutils literal"><span class="pre">basic_get</span></tt>).</p>
<p><a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a> is used where synchronous functionality is more
important than performance. If you can, use <a title="carrot.messaging.Consumer.iterconsume" class="reference internal" href="#carrot.messaging.Consumer.iterconsume"><tt class="xref docutils literal"><span class="pre">iterconsume()</span></tt></a>
instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>limit</em> &#8211; If set, the iterator stops when it has processed
this number of messages in total.</li>
<li><em>infinite</em> &#8211; Don&#8217;t raise <tt class="xref docutils literal"><span class="pre">StopIteration</span></tt> if there is no
messages waiting, but return <tt class="xref docutils literal"><span class="pre">None</span></tt> instead. If infinite you
obviously shouldn&#8217;t consume the whole iterator at once without
using a <tt class="docutils literal"><span class="pre">limit</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises StopIteration:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If there is no messages waiting, and the
iterator is not infinite.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.process_next">
<tt class="descname">process_next</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.process_next" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>DEPRECATED</strong> Use <a title="carrot.messaging.Consumer.fetch" class="reference internal" href="#carrot.messaging.Consumer.fetch"><tt class="xref docutils literal"><span class="pre">fetch()</span></tt></a> like this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">enable_callbacks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a new message is received by
running <a title="carrot.messaging.Consumer.wait" class="reference internal" href="#carrot.messaging.Consumer.wait"><tt class="xref docutils literal"><span class="pre">wait()</span></tt></a>, <a title="carrot.messaging.Consumer.process_next" class="reference internal" href="#carrot.messaging.Consumer.process_next"><tt class="xref docutils literal"><span class="pre">process_next()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a>.</p>
<p>When a message is received, it passes the message on to the
callbacks listed in the <a title="carrot.messaging.Consumer.callbacks" class="reference internal" href="#carrot.messaging.Consumer.callbacks"><tt class="xref docutils literal"><span class="pre">callbacks</span></tt></a> attribute.
You can register callbacks using <a title="carrot.messaging.Consumer.register_callback" class="reference internal" href="#carrot.messaging.Consumer.register_callback"><tt class="xref docutils literal"><span class="pre">register_callback()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>message_data</em> &#8211; The deserialized message data.</li>
<li><em>message</em> &#8211; The <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises NotImplementedError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If no callbacks has been registered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be triggered by <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">callback</span></tt> function must take two arguments:</p>
<blockquote>
<ul>
<li><p class="first">message_data</p>
<blockquote>
<p>The deserialized message data</p>
</blockquote>
</li>
<li><p class="first">message</p>
<blockquote>
<p>The <a title="carrot.backends.base.BaseMessage" class="reference external" href="carrot.backends.base.html#carrot.backends.base.BaseMessage"><tt class="xref docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.wait">
<tt class="descname">wait</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Go into consume mode.</p>
<p>Mostly for testing purposes and simple programs, you probably
want <a title="carrot.messaging.Consumer.iterconsume" class="reference internal" href="#carrot.messaging.Consumer.iterconsume"><tt class="xref docutils literal"><span class="pre">iterconsume()</span></tt></a> or <a title="carrot.messaging.Consumer.iterqueue" class="reference internal" href="#carrot.messaging.Consumer.iterqueue"><tt class="xref docutils literal"><span class="pre">iterqueue()</span></tt></a> instead.</p>
<p>This runs an infinite loop, processing all incoming messages
using <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">receive()</span></tt></a> to apply the message to all registered
callbacks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Messaging">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Messaging</tt><big>(</big><em>connection</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging" title="Permalink to this definition">¶</a></dt>
<dd><p>A combined message publisher and consumer.</p>
<dl class="method">
<dt id="carrot.messaging.Messaging.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.close" title="Permalink to this definition">¶</a></dt>
<dd>Close any open channels.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.consumer_cls">
<tt class="descname">consumer_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.consumer_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Consumer" class="reference internal" href="#carrot.messaging.Consumer"><tt class="xref docutils literal"><span class="pre">Consumer</span></tt></a></dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.decoder">
<tt class="descname">decoder</tt><a class="headerlink" href="#carrot.messaging.Messaging.decoder" title="Permalink to this definition">¶</a></dt>
<dd>The decoder used.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.encoder">
<tt class="descname">encoder</tt><a class="headerlink" href="#carrot.messaging.Messaging.encoder" title="Permalink to this definition">¶</a></dt>
<dd>The encoder used.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.fetch">
<tt class="descname">fetch</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.fetch" title="Permalink to this definition">¶</a></dt>
<dd>See <a title="carrot.messaging.Consumer.fetch" class="reference internal" href="#carrot.messaging.Consumer.fetch"><tt class="xref docutils literal"><span class="pre">Consumer.fetch()</span></tt></a></dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.publisher_cls">
<tt class="descname">publisher_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.publisher_cls" title="Permalink to this definition">¶</a></dt>
<dd>alias of <a title="carrot.messaging.Publisher" class="reference internal" href="#carrot.messaging.Publisher"><tt class="xref docutils literal"><span class="pre">Publisher</span></tt></a></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.receive" title="Permalink to this definition">¶</a></dt>
<dd>See <a title="carrot.messaging.Consumer.receive" class="reference internal" href="#carrot.messaging.Consumer.receive"><tt class="xref docutils literal"><span class="pre">Consumer.receive()</span></tt></a></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.register_callback" title="Permalink to this definition">¶</a></dt>
<dd>See <a title="carrot.messaging.Consumer.register_callback" class="reference internal" href="#carrot.messaging.Consumer.register_callback"><tt class="xref docutils literal"><span class="pre">Consumer.register_callback()</span></tt></a></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.send" title="Permalink to this definition">¶</a></dt>
<dd>See <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">Publisher.send()</span></tt></a></dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Publisher">
<em class="property">
class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Publisher</tt><big>(</big><em>connection</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Message publisher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>connection</em> &#8211; see <a title="carrot.messaging.Publisher.connection" class="reference internal" href="#carrot.messaging.Publisher.connection"><tt class="xref docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><em>exchange</em> &#8211; see <a title="carrot.messaging.Publisher.exchange" class="reference internal" href="#carrot.messaging.Publisher.exchange"><tt class="xref docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><em>routing_key</em> &#8211; see <a title="carrot.messaging.Publisher.routing_key" class="reference internal" href="#carrot.messaging.Publisher.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><em>encoder</em> &#8211; see <a title="carrot.messaging.Publisher.encoder" class="reference internal" href="#carrot.messaging.Publisher.encoder"><tt class="xref docutils literal"><span class="pre">encoder</span></tt></a>.</li>
<li><em>backend_cls</em> &#8211; see <a title="carrot.messaging.Publisher.backend_cls" class="reference internal" href="#carrot.messaging.Publisher.backend_cls"><tt class="xref docutils literal"><span class="pre">backend_cls</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Publisher.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Publisher.connection" title="Permalink to this definition">¶</a></dt>
<dd>The AMQP connection. A <a title="carrot.connection.AMQPConnection" class="reference external" href="carrot.connection.html#carrot.connection.AMQPConnection"><tt class="xref docutils literal"><span class="pre">carrot.connection.AMQPConnection</span></tt></a>
instance.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Publisher.exchange" title="Permalink to this definition">¶</a></dt>
<dd>Name of the exchange we send messages to.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Publisher.routing_key" title="Permalink to this definition">¶</a></dt>
<dd>The default routing key for messages sent using this publisher.
See <a title="carrot.messaging.Consumer.routing_key" class="reference internal" href="#carrot.messaging.Consumer.routing_key"><tt class="xref docutils literal"><span class="pre">Consumer.routing_key</span></tt></a> for more information.
You can override the routing key by passing an explicit
<tt class="docutils literal"><span class="pre">routing_key</span></tt> argument to <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">send()</span></tt></a>.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.delivery_mode">
<tt class="descname">delivery_mode</tt><a class="headerlink" href="#carrot.messaging.Publisher.delivery_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The default delivery mode used for messages. The value is an integer.
The following delivery modes are supported by (at least) RabbitMQ:</p>
<blockquote>
<ul>
<li><p class="first">1</p>
<blockquote>
<p>The message is non-persistent. Which means it is stored in
memory only, and is lost if the server dies or restarts.</p>
</blockquote>
</li>
<li><dl class="first docutils">
<dt>2</dt>
<dd><p class="first last">The message is persistent. Which means the message is
stored both in-memory, and on disk, and therefore
preserved if the server dies or restarts.</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<p>The default value is <tt class="docutils literal"><span class="pre">2</span></tt> (persistent).</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.encoder">
<tt class="descname">encoder</tt><a class="headerlink" href="#carrot.messaging.Publisher.encoder" title="Permalink to this definition">¶</a></dt>
<dd>The function responsible for encoding the message data passed
to <a title="carrot.messaging.Publisher.send" class="reference internal" href="#carrot.messaging.Publisher.send"><tt class="xref docutils literal"><span class="pre">send()</span></tt></a>. Note that any consumer of the messages sent
must have a decoder supporting the serialization scheme.</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.backend_cls">
<tt class="descname">backend_cls</tt><a class="headerlink" href="#carrot.messaging.Publisher.backend_cls" title="Permalink to this definition">¶</a></dt>
<dd>The messaging backend class used. Defaults to the <tt class="docutils literal"><span class="pre">pyamqplib</span></tt>
backend.</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">backend_cls</tt></dt>
<dd>alias of <tt class="xref docutils literal"><span class="pre">Backend</span></tt></dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.close" title="Permalink to this definition">¶</a></dt>
<dd>Close connection to queue.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.create_message">
<tt class="descname">create_message</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em>, <em>priority=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.create_message" title="Permalink to this definition">¶</a></dt>
<dd>With any data, serialize it and encapsulate it in a AMQP
message with the proper headers set.</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>routing_key=None</em>, <em>delivery_mode=None</em>, <em>mandatory=False</em>, <em>immediate=False</em>, <em>priority=0</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>message_data</em> &#8211; The message data to send. Can be a list,
dictionary or a string.</li>
<li><em>routing_key</em> &#8211; A custom routing key for the message.
If not set, the default routing key set in the <a title="carrot.messaging.Publisher.routing_key" class="reference internal" href="#carrot.messaging.Publisher.routing_key"><tt class="xref docutils literal"><span class="pre">routing_key</span></tt></a>
attribute is used.</li>
<li><em>mandatory</em> &#8211; If set, the message has mandatory routing.
By default the message is silently dropped by the server if it
can&#8217;t be routed to a queue. However - If the message is mandatory,
an exception will be raised instead.</li>
<li><em>immediate</em> &#8211; Request immediate delivery.
If the message cannot be routed to a queue consumer immediately,
an exception will be raised. This is instead of the default
behaviour, where the server will accept and queue the message,
but with no guarantee that the message will ever be consumed.</li>
<li><em>delivery_mode</em> &#8211; Override the default <a title="carrot.messaging.Publisher.delivery_mode" class="reference internal" href="#carrot.messaging.Publisher.delivery_mode"><tt class="xref docutils literal"><span class="pre">delivery_mode</span></tt></a>.</li>
<li><em>priority</em> &#8211; The message priority, <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">9</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


	      </div>
	    </div>
	  </div>
	</div>
	<div class="sidebar">
	  <h3>Contents</h3>
	  <ul class="current">
<li class="toctree-l1"><a class="reference external" href="../introduction.html">carrot - AMQP Messaging Framework for Python</a></li>
<li class="toctree-l1"><a class="reference external" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1 current"><a class="reference external" href="index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference external" href="carrot.connection.html">carrot.connection</a></li>
<li class="toctree-l2 current"><a class="current reference external" href="">carrot.messaging</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.html">carrot.backends</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.base.html">carrot.backends.base</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.pyamqplib.html">carrot.backends.pyamqplib</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.backends.queue.html">carrot.backends.queue</a></li>
<li class="toctree-l2"><a class="reference external" href="carrot.serialization.html">carrot.serialization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="../changelog.html">Change history</a></li>
</ul>

	  <h3 style="margin-top: 1.5em;">Search</h3>
	  <form class="search" action="../search.html" method="get">
            <input type="text" name="q" size="18" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
	</div>
	<div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
	<div class="left">
          <a href="../genindex.html" title="General Index"
             >index</a> |
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |
          <a href="carrot.backends.html" title="carrot.backends"
             >next</a> |
          <a href="carrot.connection.html" title="carrot.connection"
             >previous</a>
            <br/>
            <a href="../sources/reference/carrot.messaging.txt"
               rel="nofollow">Show Source</a>
	</div>

	<div class="right">
	  &copy; Copyright 2009, Ask Solem.<br/>
	  Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.1.
	</div>
	<div class="clearer"></div>
      </div>
    </div>

  </body>
</html>