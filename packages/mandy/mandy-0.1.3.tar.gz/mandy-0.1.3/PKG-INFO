Metadata-Version: 1.0
Name: mandy
Version: 0.1.3
Summary: a terse command-line options parser
Home-page: http://pypi.python.org/pypi/mandy/
Author: Tim Cuthbertson
Author-email: tim3d.junk+mandy@gmail.com
License: BSD
Description: "mandy" is a simple com(mand)-line option parser (see the tenuous name link there?)
        
        It uses the standard optparse library, but makes common functionality
        easy to write (and read!). Argument type checking is trivial, and you
        can supply your own validation actions to further check
        application-specific logic.
        
        An illustrative example::
        
        import mandy
        class Main(mandy.Command):
        # you should define `configure` and `run` methods for your
        # command to work
        
        def configure(self):
        # --name (string)
        self.opt('name', default='(unnamed)', desc="set the name")
        
        # -n [1-5], default of 1
        self.opt('num-things', int, short='n', long=None, default=1,
        action=between_one_and_five, desc="num items (1-5)")
        
        # --frob or --no-frob
        self.opt('frob', bool, default=True, desc="use frobbing")
        
        # --debug (--no-debug is not added since opposite is False)
        self.opt('debug', bool, default=False, opposite=False,
        desc="Set Debug mode")
        
        # --do-thing=yes/no (explicit value)
        # (on/off, true/false, yes/no and 1/0 all work for boolean values)
        self.opt('do-thing', bool, default=False, explicit=True, desc="yes/no")
        
        # arg is the same as opt, but without long/short options,
        # and optional default values
        # this makes:
        #    command [options] foo1 foo2 [bar] baz
        self.arg('foo1')
        self.arg('foo2', bool)
        self.arg('bar', default=None)
        self.arg('baz')
        
        def run(self, opts):
        # opts includes your named options and arguments as attributes
        print "you set name to %s" % (opts.name)
        
        # since you can have options that aren't valid python attributes,
        # you can also treat opts as a dict:
        print "and there are %s things" % opts['num-things']
        
        def between_one_and_five(num):
        if not (num >= 1 and num <= 5):
        raise RuntimeError("number must be between one and five")
        
        if __name__ == '__main__':
        Main()
        
        this produces the following when run with --help::
        
        Usage: example.py [options] foo1 foo2 [bar] baz
        
        Options:
        -h, --help           show this help message and exit
        --name=NAME          set the name
        -n N                 num items (1-5)
        --frob               use frobbing
        --no-frob
        --debug              Set Debug mode
        --do-thing=DO_THING  yes/no
        
        
Keywords: optparse option parsing command commandline simple
Platform: UNKNOWN
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: Python
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Libraries :: Python Modules
