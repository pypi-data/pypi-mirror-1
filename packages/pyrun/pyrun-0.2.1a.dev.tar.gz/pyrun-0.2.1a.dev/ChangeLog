ChangeLog
~~~~~~~~~
0.2.1:
  * Changed the package distribution name back to pyrun
  * in .pth files added support for relative paths, paths which contain
    environment variables, paths which use operating specific aliases for $HOME
  * Bug fixes and better reporting for the exclusion facility.
0.1.1:
  * Added support for directory exclusions and path prunes.
     * exclusion prevents discovery descending into a directory if that
       directory startswith an element in the exclusion set
       (see new option -x).
     * prune operates on the result of the discovery. Any path which contains
       one of the strings specified by a prune is removed from the discovered
       path.

    exclusion hides directories from the discovery process, prune removes
    results after the fact.
    exclusions are enabled by -x
    prunes are enabled by -X
    empty strings are *always* removed from -x and -X.

    There is precisely one mechanism which enables packages *under* an
    exclusion path to be explicitly added back in: All explicitly identified
    python modules are exempted from the exclusion (but not the prune)

  * Decided to use logging instead of print for notification, I had avoided
    this previously because I did not want to polute the logging configuration
    of the target app. I consider this change provisional, if it causes to
    much trouble I will revert to print
  * Added support for including .pth files in the discovery phase. This
    makes it possible to insert paths to directories which do not contain
    an __init__.py or are the dirname() of an explicitly referenced module
    file.
  * bugfix: propagate source file name (or sensibly invented filename) to
    the __file__ attribute of the code instance that becomes our __main__
  * -d works with -m and -c, should also work with -s but have not tried yet.
  * -d option uses pdb.runeval rather than set_trace making for considerably
    simpler target debugging. May consider introducing an "eager" -d variant
    that behaves like 0.1 (set_trace *in* pyrun.py) later.
  * Allow the target to run when -d is in effect, without requiring user to
    manaully do ``opts.d = False``
  * By default suppress -D if -d is in effect.
  * Added -c, its much like python -c
  * The `run script` option changed from -S to -C exist on the file system. -q
    suppreses the warnings

0.1d:
  * `-S` option to explicitly run a python script. uses compiler.compile to
    load and compile the code from an arbitrary file. uses
    runpy._run_module_code to execute the resulting module as __main__.
    NOTE No discovery or sys.path manipulation is performed on the file
    specified with this option. works for plain old python scripts and
    executable scripts that lack an extension.
    .
    The chief motivation for this is to support python projects that
    distribute substantive scripts rather than using the setuptools
    entry_points 'wrapper' script approach. (For example see the
    0.2.1 source tarbal for pyflakes).

  * documentation tidy up

0.1c:
  * Use the parent directory of the top package directory for each explicitly
    listed python file in the discovery path. This means you need to *always* 
    provide fully qualified module names to ``-m``. This change is necessary
    to allow the targeted modules imports to work correctly.

0.1b:

  * path discovery and  python module execution

