import turbogears
from ${package} import model
#if $identity == 'sqlobject'
from sqlobject import *
hub = __connection__ = model.hub
#else if $identity == 'sqlalchemy'
from sqlalchemy import *
from sqlalchemy.ext.assignmapper import assign_mapper
from turbogears.database import metadata, session
#end if
from datetime import datetime
from turbogears import config

def create_registration_tables():
    "Create the appropriate database tables."
#if $identity=='sqlobject'
    RegistrationPendingUser.createTable(ifNotExists=True)
    RegistrationUserEmailChange.createTable(ifNotExists=True)
#else if $identity == 'sqlalchemy'
    registration_pending_user_table.create(checkfirst=True)
    email_change_table.create(checkfirst=True)
#end if

# Automatically create the registration tables when TurboGears starts up
turbogears.startup.call_on_startup.append(create_registration_tables)

class UserClassFinder(object):
    """Utility class to find and store the main User model.
    
    There are two properties intended for public use:
    
    user_class - Returns the main user class (which can be instantiated)
    user_class_name - Returns a string of the name of the user class. This
                      can be useful for SQLObject
    """
        
    def __init__(self):
        super(UserClassFinder, self).__init__()
        self.__user_path = None
        self.__class = None
        self.__classname = None
    
    def _find_user_path(self):
        if not self.__user_path:
#if $identity == 'sqlobject'
            self.__user_path = config.get('identity.soprovider.model.user',
                                        '${package}.model.User')
#else if $identity == 'sqlalchemy'
            self.__user_path = config.get('identity.saprovider.model.user',
                                        '${package}.model.User')
#end if
        return self.__user_path
        
        
    def _user_class(self):
        if not self.__class:
            path = self._find_user_path()
            self.__class = turbogears.util.load_class(path)
        return self.__class
        
    def _user_class_name(self):
        if not self.__classname:
            path = self._find_user_path()
            self.__classname = path.split('.')[-1]
        return self.__classname
            
    user_class = property(_user_class)
    user_class_name = property(_user_class_name)
    
user_class_finder = UserClassFinder()

#if $identity == 'sqlobject'

class RegistrationPendingUser(SQLObject):
    """Model to store information about users that have not been verified.
    """
    # This class should be modified to essentially look like your main model.User
    # class.  You don't need to add in the group information
    user_name = UnicodeCol( length=16, alternateID=True,
                           alternateMethodName="by_user_name" )
    email_address = UnicodeCol( length=255, alternateID=True,
                               alternateMethodName="by_email_address" )
    display_name = UnicodeCol( length=255 )
    password = UnicodeCol( length=40 )
    created = DateTimeCol( default=datetime.now )
    validation_key = StringCol( length=40 )

class RegistrationUserEmailChange(SQLObject):
    """Model to store changes to user email addresses for validation.
    """
    user = ForeignKey(user_class_finder.user_class_name)
    new_email_address = UnicodeCol(length=255, alternateID=True,
                                    alternateMethodName='by_new_email_address')
    validation_key = StringCol(length=40)
    created = DateTimeCol(default=datetime.now)
    
#end if

#if $identity == 'sqlalchemy'

class RegistrationSQLAlchemyBase(object):
    "Base class to handle generic creation and destruction."
    
    def __init__(self, **kw):
        # set each argument as an attribute
        for attr, value in kw.iteritems():
            setattr(self, attr, value)
            
    @classmethod
    def new(cls, **kw):
        """Factory method creates a new instance of this class (both in python and in the db)."""
        raise NotImplementedError("Must override new")
        
    def destroy_self(self):
        session.delete(self)
        del(self)

registration_pending_user_table = Table('registration_pending_user', metadata,
                                        Column('id', Integer, primary_key=True),
                                        Column('user_name', String(16), nullable=False, unique=True),
                                        Column('email_address', String(255), nullable=False, unique=True),
                                        Column('display_name', String(255)),
                                        Column('password', String(40)),
                                        Column('created', DateTime, default=datetime.now),
                                        Column('validation_key', String(40))
                                        )

class RegistrationPendingUser(RegistrationSQLAlchemyBase):
    
    def __repr__(self):
        return "RegistrationPendingUser id:%d user_name:%s email_address: %s" % \
                    (self.id, self.user_name, self.email_address)
    
    @classmethod   
    def new(cls, user_name, email_address, display_name, password, validation_key):
        kw = dict ( user_name=user_name, 
                    email_address=email_address,
                    display_name=display_name,
                    password=password,
                    validation_key=validation_key)
        pend = cls(**kw)
        session.save(pend)
        return pend
        
    @classmethod
    def get_by_email_address(cls, email_address):
        return session.query(cls).get_by(email_address=email_address)

assign_mapper(session.context, RegistrationPendingUser, registration_pending_user_table)

# def newRegistrationPendingUser(user_name,
#                                 email_address,
#                                 display_name,
#                                 password,
#                                 validation_key
#                                 ):
#     pend = RegistrationPendingUser(
#                         user_name = user_name,
#                         email_address = email_address,
#                         display_name = display_name,
#                         password = password,
#                         validation_key = validation_key
#     )
#     session.save(pend)
#     return pend

# def getRegistrationPendingUser(email_address):
#     return session.query(RegistrationPendingUser).get_by(email_address=email_address)
# 
# def deleteRegistrationPendingUser(pend):
#     session.delete(pend)

email_change_table = Table('registration_user_email_change', metadata,
                            Column('id', Integer, primary_key=True),
                            # TODO: should probably make finding the user_id column
                            # more generic
                            Column('user_id', Integer, ForeignKey('tg_user.user_id')),
                            Column('new_email_address', String(255), nullable=False, unique=True),
                            Column('validation_key', String(40), nullable=False),
                            Column('created', DateTime, default=datetime.now)
                        )
    
class RegistrationUserEmailChange(RegistrationSQLAlchemyBase):
    
    # def __init__(self, user_id, new_email_address, validation_key):
    #     self.user_id = user_id
    #     self.new_email_address = new_email_address
    #     self.validation_key = validation_key
    
    def __repr__(self):
        return "RegistrationUserEmailChange id:%d user_id:%d new_email_address:%s " + \
                "validation_key: %s" % (self.id, self.user_id, self.new_email_address, 
                                        self.validation_key)
    
    @classmethod
    def new(cls, user, new_email_address, validation_key):
        """Factory method creates a new instance of this class (both in python and in the db).
        
        user: An identity user object
        new_email_address: string 
        validation_key: string
        """
        kw = dict(user_id=user.user_id, new_email_address=new_email_address, 
                    validation_key=validation_key)
        email_chg = cls(**kw)
        session.save(email_chg)
        return email_chg
        
    @classmethod
    def get_by_new_email(cls, new_email_address):
        "Returns an existing object using new_email_address as the lookup item."
        return session.query(cls).get_by(new_email_address=new_email_address)
        
    def _user(self):
        "Returns the User associated with the email change."
        return user_class_finder.user_class.get_by(user_id=self.user_id)
    user = property(_user)
        
assign_mapper(session.context, RegistrationUserEmailChange, email_change_table)

#end if

def user_name_is_unique(user_name):
    "Return True if the user_name is not yet in the database."
    UserClass = user_class_finder.user_class
#if $identity == 'sqlobject'
    user_count = UserClass.selectBy(user_name=user_name).count()
    pending_count = RegistrationPendingUser.selectBy(user_name=user_name).count()
#else if $identity == 'sqlalchemy'
    user_count = session.query(UserClass).count_by(user_name=user_name)
    pending_count = session.query(RegistrationPendingUser).count_by(user_name=user_name)
#end if
    if user_count or pending_count:
        return False
    else:
        return True
        
def email_is_unique(email):
    "Return True if the email is not yet in the database."
    UserClass = user_class_finder.user_class
#if $identity == 'sqlobject'
    user_count = UserClass.selectBy(email_address=email).count()
    pending_count = RegistrationPendingUser.selectBy(email_address=email).count()
    changed_count = RegistrationUserEmailChange.selectBy(new_email_address=email).count()
#else if $identity == 'sqlalchemy'
    user_count = session.query(UserClass).count_by(email_address=email)
    pending_count = session.query(RegistrationPendingUser).count_by(email_address=email)
    changed_count = session.query(RegistrationUserEmailChange).count_by(new_email_address=email)
#end if
    if user_count or pending_count or changed_count:
        return False
    else:
        return True
