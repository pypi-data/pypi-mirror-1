import turbogears
from ${package} import model
from datetime import datetime
from turbogears import config
#if $identity == 'sqlobject'
from sqlobject import *

hub = __connection__ = model.hub
#end if

class UserClassFinder(object):
    """Utility class to find and store the main User model.
    
    There are two properties intended for public use:
    
    user_class - Returns the main user class (which can be instantiated)
    user_class_name - Returns a string of the name of the user class. This
                      can be useful in SQLObject 
    """
    
    __class = None
    __classname = None
    
    def __init__(self):
        super(UserClassFinder, self).__init__()
        self.__user_path = None
    
    def _find_user_path(self):
        if not self.__user_path:
#if $identity == 'sqlobject'
            self.__user_path = config.get('identity.soprovider.model.user',
                                        '${package}.model.User')
#else if $identity == 'sqlalchemy'
            self.__user_path = config.get('identity.saprovider.model.user',
                                        '${package}.model.User')
#end if
        return self.__user_path
        
        
    def _user_class(self):
        if not UserClassFinder.__class:
            path = self._find_user_path()
            UserClassFinder.__class = turbogears.util.load_class(path)
        return UserClassFinder.__class
        
    def _user_class_name(self):
        if not UserClassFinder.__classname:
            path = self._find_user_path()
            UserClassFinder.__classname = path.split('.')[-1]
        return UserClassFinder.__classname
        
    user_class = property(_user_class)
    user_class_name = property(_user_class_name)
    
user_class_finder = UserClassFinder()

#if $identity == 'sqlobject'
class RegistrationPendingUser(SQLObject):
    """Model to store information about users that have not been verified.
    """
    # This class should be modified to essentially look like your main model.User
    # class.  You don't need to add in the group information
    user_name = UnicodeCol( length=16, alternateID=True,
                           alternateMethodName="by_user_name" )
    email_address = UnicodeCol( length=255, alternateID=True,
                               alternateMethodName="by_email_address" )
    display_name = UnicodeCol( length=255 )
    password = UnicodeCol( length=40 )
    created = DateTimeCol( default=datetime.now )
    validation_key = StringCol( length=40 )

class RegistrationUserEmailChange(SQLObject):
    """Model to store changes to user email addresses for validation.
    """
    user = ForeignKey(user_class_finder.user_class_name)
    new_email_address = UnicodeCol(length=255, alternateID=True,
                                    alternateMethodName='by_new_email_address')
    validation_key = StringCol(length=40)
    created = DateTimeCol(default=datetime.now)
    
#end if

#if $identity == 'sqlalchemy'
from sqlalchemy import *
engine = __engine__ = model.engine


registration_pending_user_table = Table('registration_pending_user', engine,
                                        Column('id', Integer, primary_key=True),
                                        Column('user_name', String(16), nullable=False),
                                        Column('email_address', String(255), nullable=False),
                                        Column('display_name', String(255)),
                                        Column('password', String(40)),
                                        Column('created', DateTime, default=datetime.now),
                                        Column('validation_key', String(40))
                                        )

class RegistrationPendingUser(object):
    def __repr__(self):
        return "RegistrationPendingUser id:%d user_name:%s email_address: %s" % \
                    (self.id, self.user_name, self.email_address)

pendingmapper = mapper(RegistrationPendingUser, registration_pending_user_table)
#end if

def user_name_is_unique(user_name):
    "Return True if the user_name is not yet in the database."
    UserClass = user_class_finder.user_class
#if $identity == 'sqlobject'
    user_count = UserClass.selectBy(user_name=user_name).count()
    pending_count = RegistrationPendingUser.selectBy(user_name=user_name).count()
#else if $identity == 'sqlalchemy'
    session = create_session(bind_to=engine)
    user_count = session.query(UserClass).select_by(user_name=user_name).count()
    pending_count = session.query(RegistrationPendingUser).select_by(user_name=user_name).count()
#end if
    if user_count or pending_count:
        return False
    else:
        return True
        
def email_is_unique(email):
    """Return True if the email is not yet in the database."""
    UserClass = user_class_finder.user_class
#if $identity == 'sqlobject'
    user_count = UserClass.selectBy(email_address=email).count()
    pending_count = RegistrationPendingUser.selectBy(email_address=email).count()
    changed_count = RegistrationUserEmailChange.selectBy(new_email_address=email).count()
#else if $identity == 'sqlalchemy'
    session = create_session(bind_to=engine)
    user_count = session.query(UserClass).select_by(email_address=email).count()
    pending_count = session.query(RegistrationPendingUser).select_by(email_address=email).count()
    # TODO: changed_count
#end if
    if user_count or pending_count or changed_count:
        return False
    else:
        return True