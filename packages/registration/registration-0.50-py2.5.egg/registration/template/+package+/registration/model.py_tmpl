import turbogears
from ${package} import model
#if $identity == 'sqlobject'
from sqlobject import *
hub = __connection__ = model.hub
#else if $identity == 'sqlalchemy'
import pkg_resources
pkg_resources.require("SQLAlchemy>=0.4")

from sqlalchemy import Table, Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relation
from turbogears.database import metadata, session, mapper
#end if
from datetime import datetime
from turbogears import config
from registration.ormmanager import count

def create_registration_tables():
    "Create the appropriate database tables."
#if $identity=='sqlobject'
    RegistrationPendingUser.createTable(ifNotExists=True)
    RegistrationUserEmailChange.createTable(ifNotExists=True)
    RegistrationUserLostPassword.createTable(ifNotExists=True)
#else if $identity == 'sqlalchemy'
    registration_pending_user_table.create(checkfirst=True)
    email_change_table.create(checkfirst=True)
    password_lost_table.create(checkfirst=True)
#end if

# Automatically create the registration tables when TurboGears starts up
# turbogears.startup.call_on_startup.append(create_registration_tables)


#if $identity == 'sqlobject'
_user_path = config.get('identity.soprovider.model.user',
                                        '${package}.model.User')
#else if $identity == 'sqlalchemy'
_user_path = config.get('identity.saprovider.model.user',
                                        '${package}.model.User')
#end if
User = turbogears.util.load_class(_user_path)
                                        
#if $identity == 'sqlobject'

class RegistrationPendingUser(SQLObject):
    """Model to store information about users that have not been verified.
    """
    # This class should be modified to essentially look like your main model.User
    # class.  You don't need to add in the group information
    user_name = UnicodeCol( length=16, alternateID=True,
                           alternateMethodName="by_user_name" )
    email_address = UnicodeCol( length=255, alternateID=True,
                               alternateMethodName="by_email_address" )
    display_name = UnicodeCol( length=255 )
    password = UnicodeCol( length=40 )
    created = DateTimeCol( default=datetime.now )
    validation_key = StringCol( length=40 )

class RegistrationUserEmailChange(SQLObject):
    """Model to store changes to user email addresses for validation.
    """
    user = ForeignKey(User.__name__)
    new_email_address = UnicodeCol(length=255, alternateID=True,
                                    alternateMethodName='by_new_email_address')
    validation_key = StringCol(length=40)
    created = DateTimeCol(default=datetime.now)
    
class RegistrationUserLostPassword(SQLObject):
    """Model to store info about lost password status."""
    
    user = ForeignKey(User.__name__, unique=True)
    validation_key = StringCol(length=40)
    created = DateTimeCol(default=datetime.now)
    
    @classmethod
    def get_by_username_key(cls, user_name, key):
        try:
            user = User.by_user_name(user_name)
        except SQLObjectNotFound:
            return None
        
        select = cls.select(AND(cls.q.userID==user.id,
                                cls.q.validation_key==key))    
        return select.getOne(default=None)
    
#end if

#if $identity == 'sqlalchemy'

registration_pending_user_table = Table('registration_pending_user', metadata,
                        Column('id', Integer, primary_key=True),
                        Column('user_name', String(16),
                                nullable=False, unique=True),
                        Column('email_address', String(255),
                                nullable=False, unique=True),
                        Column('display_name', String(255)),
                        Column('password', String(40)),
                        Column('created', DateTime,
                                default=datetime.now),
                        Column('validation_key', String(40))
                        )
                                
email_change_table = Table('registration_user_email_change', metadata,
                        Column('id', Integer, primary_key=True),
                        # TODO: should probably make finding the user_id 
                        # column more generic
                        Column('user_id', Integer,
                            ForeignKey('tg_user.user_id')),
                        Column('new_email_address', String(255),
                            nullable=False, unique=True),
                        Column('validation_key', String(40), nullable=False),
                        Column('created', DateTime, default=datetime.now)
                        )

password_lost_table = Table('registration_user_lost_password', metadata,
                        Column('id', Integer, primary_key=True),
                        Column('user_id', Integer,
                            ForeignKey('tg_user.user_id'), unique=True),
                        Column('validation_key', String(40), nullable=False),
                        Column('created', DateTime, default=datetime.now)
                        )

class RegistrationPendingUser(object):
    
    def __repr__(self):
        return ("RegistrationPendingUser id:%d user_name:%s "
                "email_address: %s" %
                    (self.id, self.user_name, self.email_address))
    
class RegistrationUserEmailChange(object):
    
    def __repr__(self):
        return ("RegistrationUserEmailChange id:%d user_id:%d "
                "new_email_address:%s validation_key: %s" % (self.id,
                        self.user_id, self.new_email_address, 
                        self.validation_key))
            
    @classmethod
    def get_by_new_email(cls, new_email_address):
        "Return an existing object using new_email_address as the lookup."
        return session.query(cls).filter_by(new_email_address=new_email_address).first()
        
class RegistrationUserLostPassword(object):
    
    @classmethod
    def get_by_username_key(cls, user_name, key):
        "Return an existing object using user_name and key."
        user = User.by_user_name(user_name)
        if user:
            return session.query(cls).filter_by(user=user, validation_key=key).first()

mapper(RegistrationPendingUser, registration_pending_user_table)
        
mapper(RegistrationUserEmailChange, email_change_table,
            properties=dict(user=relation(User)))

mapper(RegistrationUserLostPassword, password_lost_table,
            properties=dict(user=relation(User)))
            
#end if

def user_name_is_unique(user_name):
    "Return True if the user_name is not yet in the database."
    user_count = count(User, user_name=user_name)
    pending_count = count(RegistrationPendingUser, user_name=user_name)
    return not(user_count or pending_count)

        
def email_is_unique(email):
    "Return True if the email is not yet in the database."
    user_count = count(User, email_address=email)
    pending_count = count(RegistrationPendingUser, email_address=email)
    changed_count = count(RegistrationUserEmailChange,
                            new_email_address=email)
    return not(user_count or pending_count or changed_count)
