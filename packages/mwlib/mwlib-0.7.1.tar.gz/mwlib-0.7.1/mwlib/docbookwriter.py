#! /usr/bin/env python

# Copyright (c) 2008, PediaPress GmbH
# See README.txt for additional licensing information.
"""
Generate DocBook from the DOM tree generated by the parser.

Currently this is just a proof of concept which is very incomplete

see also: 
http://docutils.sourceforge.net/sandbox/oliverr/docbook/docbook.py
http://www.docbook.org/tdg5/en/html/ch02.html
"""

import sys
import StringIO
try:
    import xml.etree.ElementTree as ET
except:
    from elementtree import ElementTree as ET

from mwlib import parser
from mwlib import mathml
from mwlib import advtree
from mwlib import xmltreecleaner
from mwlib import writerbase
from mwlib.xhtmlwriter import showNode
from mwlib.xhtmlwriter import indent
from mwlib.xhtmlwriter import validate
from mwlib.xhtmlwriter import setVList
from mwlib.xhtmlwriter import xserializeVList

from mwlib.log import Log

version = "0.1"

log = Log("docbookwriter")

class SkipChildren(object):
    "if returned by the writer no children are processed"
    def __init__(self, element=None):
        self.element = element


class DocBookWriter(object):
    namedLinkCount = 1
    # stylesheet which uses the mozilla Extensible Binding Language
    # http://www.informatik.fh-wiesbaden.de/~werntges/home_t/proj/dbkcss102/wysiwygdocbook.xml
    css = '<?xml-stylesheet href="http://www.informatik.fh-wiesbaden.de/~werntges/home_t/proj/dbkcss102/wysiwygdocbook1.02/driver.css" type="text/css"?>\n'
    header='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE %s PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">\n%s
 ''' # need to expand with at least documenttype
    def __init__(self, env=None, status_callback=None, documenttype="article", language="en", imagesrcresolver=None, debug=False):
        assert documenttype in ("article", "book")
        self.documenttype = documenttype
        self.environment = env
        self.status_callback = status_callback
        self.language = language
        self.imagesrcresolver = imagesrcresolver # e.g. "http://anyhost/redir?img=IMAGENAME" where IMAGENAME is substituted
        self.debug = debug
        self.references = []
        self.root = None
        self.errors = []
        self.languagelinks = []
        self.categorylinks = []
        
    def getHeader(self):
        return self.header % (self.documenttype, self.css)
        
    def getTree(self, debuginfo=""):
        indent(self.root) # breaks XHTML (proper rendering at least) if activated!
        if self.debug:
            r = validate(self.header + ET.tostring(self.root))
            if r:
                self.root.append(ET.Comment(r.replace("--", " - - ")))
        return self.root
    
    def asstring(self):
        return self.getHeader() + ET.tostring(self.getTree())

    
    def writeText(self, obj, parent):
        if parent.getchildren(): # add to tail of last tag
            t = parent.getchildren()[-1]
            if not t.tail:
                t.tail = obj.caption
            else:
                t.tail += obj.caption
        else:
            if not parent.text:
                parent.text = obj.caption
            else:
                parent.text += obj.caption

    def writedebug(self, obj, parent, comment=""):
        if not self.debug or parent is None:
            return 
        attrs = obj.__dict__.keys()
        stuff =  ["%s : %r" %(k,getattr(obj,k)) for k in attrs if 
                  (not k in ("_parentref", "children")) and getattr(obj,k)
                  ]
        text = obj.__class__.__name__  + repr(stuff) 
        if comment:
            text += "\n" + comment
        parent.append(ET.Comment(text.replace("--", " - - "))) # FIXME (hot fix)


    def writeparsetree(self, tree):
        out = StringIO.StringIO()
        parser.show(out, tree)
        self.root.append(ET.Comment(out.getvalue().replace("--", " - - ")))
        

    def write(self, obj, parent=None):
        """
        translates a parse tree object to element tree XML Element
        returns an element, which the caller has to add (or not)
        text is directly added to the parents last child or the parent itself.
        """
        # if its text, append to last node
        if isinstance(obj, parser.Text):
            self.writeText(obj, parent)
        else:
            self.writedebug(obj, parent)
            # check for method
            m = "dbwrite" + obj.__class__.__name__
            m=getattr(self, m, None)
            
            if m: # find handler
                e = m(obj)
            else:
                self.writedebug(obj, parent, "was skipped")
                log("SKIPPED")
                showNode(obj)
                e = None

            if isinstance(e, SkipChildren): # do not process children of this node
                return e.element
            elif e is None:
                e = parent

            p = e
            if hasattr(e, "writeto"):
                p = e.writeto # SPECIAL HANDLING 
            
            for c in obj.children[:]:
                ce = self.write(c,p)
                if ce is not None and ce is not p:                    
                    p.append(ce)
            return e


    def writeChildren(self, obj, parent): # use this to avoid bugs!
        "writes only the children of a node"
        for c in obj:                    
            res = self.write(c, parent)
            if res is not None and res is not parent:
                parent.append(res)


    def writeBook(self, book, output=None):
        self.write(book)
        if output:
            open(output, "w").write(self.asstring())

    def dbwriteBook(self, obj):
        e = ET.Element("book")
        if self.root is None:
            self.root = e
        if self.environment and self.environment.metabook.get('title'):
            h = ET.SubElement(e,"bookinfo")
            t = ET.SubElement(h, "title")
            t.text = self.environment.metabook['title']
        return e


    def dbwriteChapter(self, obj):
        e = ET.Element("chapter")
        h = ET.SubElement(e,"chapterinfo")
        t = ET.SubElement(h, "title")
        if obj.caption:
            t.text = obj.caption
        return e

    def dbwriteArticle(self, a):
        """
        this generates the root element if not available
        """
        # add head + title
        e = ET.Element("article", lang=self.language)
        if self.root is None:
            self.root = e
        h = ET.SubElement(e,"articleinfo")
        t = ET.SubElement(h, "title")
        if a.caption:
            t.text = a.caption
        
        # add a section and heading for this article 
        s = ET.SubElement(e, "section")
        h = ET.SubElement(s, "title")
        h.text = a.caption
        e.writeto = s
        return e 

    def dbwriteSection(self, obj):
        e = ET.Element("section")
        h = ET.SubElement(e, "title")
        self.write(obj.children[0], h)
        obj.children = obj.children[1:]
        return e

    def dbwritePreFormatted(self, n):
        return ET.Element("programlisting")

    def dbwriteParagraph(self, obj):
        return ET.Element("para")

    def dbwriteEmphasized(self, obj):
        return ET.Element("emphasis")
    
    dbwriteStrong = dbwriteEmphasized
    

    
    def dbwriteBlockquote(self, s):
        "margin to the left & right"
        p = ET.Element("blockquote")
        p.writeto = ET.SubElement(p, "para")
        return p

    dbwriteIndented = dbwriteBlockquote 


    def dbwriteItem(self, item):
        p = ET.Element("listitem")
        p.writeto = ET.SubElement(p, "para")
        return p


    def dbwriteItemList(self, lst):
        if lst.numbered:
            return ET.Element("orderedlist", numeration="arabic")
        else:
            return ET.Element("itemizedlist")


    def dbwriteDefinitionList(self, obj):
        """
        <variablelist>
          <varlistentry>
           <term>x</term>
           <listitem><para>y</para></listitem>
          </varlistentry>
        </variablelist>
        """  
        return ET.Element("variablelist") # FIXME

    def dbwriteDefinitionTerm(self, obj):
        p = ET.Element("varlistentry") # FIXME
        p.writeto = ET.SubElement(p, "term")
        return p

    def dbwriteDefinitionDefinition(self, obj):
        p = ET.Element("listitem") # FIXME
        p.writeto = ET.SubElement(p, "para")
        return p

    

    def dbwriteTable(self, t):           
        """
        rowspan & colspan are supported
        nested tables not supported in DocBook V4.4
        """

        table = ET.Element("informaltable")
        setVList(table, t)           
        if t.caption:
            #c = ET.SubElement(table, "caption")
            #self.writeText(t.caption, c)
            pass
        return table


    def dbwriteCell(self, cell):
        td = ET.Element("td")
        setVList(td, cell)           
        return td
            
    def dbwriteRow(self, row):
        return ET.Element("tr")

    def dbwriteCite(self, obj):
        return ET.Element("quote")

    def dbwriteSup(self, obj):
        return ET.Element("superscript")

    def dbwriteSub(self, obj):
        return ET.Element("subscript")
    
 
    def dbwriteCode(self, n):
        return ET.Element("programlisting", format="linespecific")

    dbwriteSource = dbwriteCode

    def dbwriteMath(self, obj): 
        """
        r = mathml.latex2mathml(obj.caption)       
        if r:
            return r
        """
        r = ET.Element("phrase", role="texmath")
        r.text = obj.caption
        return r


    def dbwriteImageLink(self, obj): 
        if obj.isInline():
            e = ET.Element("inlinemediaobject")
        else:
            e = ET.Element("mediaobject")
            #e.set("float", str(int(bool(obj.caption or obj.align)))) # FLOAT

        t = ET.SubElement(e, "imageobject")
        e.writeto = ET.SubElement(ET.SubElement(e, "caption"), "para")

        # use a resolver which redirects to the real image
        # e.g. "http://anyhost/redir?img=IMAGENAME"
        if self.imagesrcresolver:
            imgsrc = self.imagesrcresolver.replace("IMAGENAME", obj.target)
        elif self.environment and self.environment.images:
            imgsrc = self.environment.images.getURL(obj.target, obj.width or None)
        else:
            imgsrc = obj.target

        img = ET.SubElement(t, "imagedata", fileref=imgsrc)
        if obj.width:
            img.set("width", "%dpx" % obj.width)
        if obj.height:
            img.set("depth", "%dpx" % obj.height)

        return e 



    # Links ---------------------------------------------------------

    def dbwriteLink(self, obj): 
        a = ET.Element("ulink")
        if obj.target:
            a.set("url", obj.target)
        if not obj.children:
            a.text = obj.target
        return a

    def dbwriteURL(self, obj):
        a = ET.Element("ulink", url=obj.caption)
        if not obj.children:
            a.text = obj.caption
        return a

    def dbwriteNamedURL(self, obj):
        a = ET.Element("ulink", url=obj.caption)
        if not obj.children:
            name = "[%s]" % self.namedLinkCount
            self.namedLinkCount += 1
            a.text = name
        return a

    def dbwriteSpecialLink(self, obj): # whats that?
        a = ET.Element("ulink", url=obj.target)
        if not obj.children:
            a.text = obj.target
        return a

    def dbwriteCategoryLink(self, obj):
        if not obj.colon and not obj.children:
            pass # FIXME
        a = ET.Element("ulink", url=obj.target)
        a.text = obj.target
        return a


    def dbwriteLangLink(self, obj): # FIXME no valid url (but uri)
        if obj.target is None:
            return
        a = ET.Element("ulink", url=obj.target)
        if not obj.children:
            a.text = obj.target
        return a


    def dbwriteImageMap(self, obj): # FIXME!
        if obj.imagemap.imagelink:
            return self.write(obj.imagemap.imagelink)


    def dbwriteGallery(self, obj):
        s = ET.Element("para")
        #setVList(s, obj)
        return s


# ------------------------------------------------------------------------------

    def dbwriteDiv(self, obj):
        return ET.Element("para") # FIXME

    def dbwriteSpan(self, obj):
        pass # FIXME

    def dbwriteReference(self, t): # FIXME USE DOCBOOK FEATURES (needs parser support)
        self.references.append(t)
        t =  ET.Element("superscript")
        t.text = unicode( len(self.references))
#        self.references.append(t)
#       t =  ET.Element("citation")
#        ET.SubElement("xref", linked="ref-%d" % len(self.references), endterm="%d" % len(self.references))
        return SkipChildren()

    def dbwriteReferenceList(self, t): # FIXME USE DOCBOOK FEATURES
        if not self.references:
            return
        ol =  ET.Element("orderedlist", numeration="arabic")
        for i,ref in enumerate(self.references):
            li = ET.SubElement(ol, "listitem")
            p = ET.SubElement(li, "para")
            self.writeChildren(ref, parent=p)
        self.references = []            
        return ol




# ----------------------------------- old xhtml writer stuff --------------


    # Special Objects


    def xwriteTimeline(self, obj): 
        s = ET.Element("object")
        s.set("class", "mwx.timeline")
        s.set("type", "application/mediawiki-timeline")
        s.set("src", "data:text/plain;charset=utf-8,%s" % obj.caption)
        em = ET.SubElement(s, "em")
        em.set("class", "mwx.timeline.alternate")
        em.text = u"Timeline"
        return s

    def xwriteHiero(self, obj): # FIXME parser support
        s = ET.Element("object")
        s.set("class", "mwx.hiero")
        s.set("type", "application/mediawiki-hiero")
        s.set("src", "data:text/plain;charset=utf-8,%s" % obj.caption)
        em = ET.SubElement(s, "em")
        em.set("class", "mwx.hiero.alternate")
        em.text = u"Hiero"
        return s



    # others: Index, Gallery, ImageMap  FIXME
    # see http://meta.wikimedia.org/wiki/Help:HTML_in_wikitext

    # ------- TAG nodes (deprecated) ----------------

    def xwriteOverline(self, s):
        e = ET.Element("span")
        e.set("class", "mwx.style.overline")
        return e    

    def xwriteUnderline(self, s):
        e = ET.Element("span")
        e.set("class", "mwx.style.underline")
        return e
    
    def xwriteCenter(self, s):
        e = ET.Element("span")
        e.set("class", "mwx.style.center")
        return e

    def xwriteStrike(self, s):
        e = ET.Element("span")
        e.set("class", "mwx.style.strike")
        return e

        
    def xwriteNode(self, n):
        pass # simply write children






def preprocess(root):
    advtree.buildAdvancedTree(root)
    # remove nav boxes
#    for c in root.getAllChildren():
#        if c.isNavBox() and c.parent is not None:
#            c.parent.removeChild(c)
    xmltreecleaner.removeChildlessNodes(root)
    xmltreecleaner.fixLists(root)
    xmltreecleaner.fixParagraphs(root)
    xmltreecleaner.fixBlockElements(root)



# - func  ---------------------------------------------------


def writer(env, output, status_callback):
    book = writerbase.build_book(env, status_callback=status_callback, progress_range=(10, 60))
    scb = lambda status, progress :  status_callback is not None and status_callback(status,progress)
    scb(status='preprocessing', progress=70)
    for c in book.children:
        preprocess(c)
    scb(status='rendering', progress=80)
    DocBookWriter(env, status_callback=scb, documenttype="book").writeBook(book, output=output)

writer.description = 'DocBook XML'



def main():
    for fn in sys.argv[1:]:
        from mwlib.dummydb import DummyDB
        from mwlib.uparser import parseString
        db = DummyDB()
        input = unicode(open(fn).read(), 'utf8')
        r = parseString(title=fn, raw=input, wikidb=db)
        parser.show(sys.stdout, r)
        preprocess(r)
        parser.show(sys.stdout, r)
        dbw = DocBookWriter()
        dbw.write(r)
        nf = open("%s.xml" % fn, "w")
        nf.write(dbw.asstring())
        
 
if __name__=="__main__":
    main()
