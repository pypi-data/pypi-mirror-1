<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Bitarray module</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="bitarray-module">
<h1 class="title">Bitarray module</h1>

<p>This module provides an object type which can efficiently
represent a bitarray.  Bitarrays are sequence types and behave very much
like usual lists.  Each bit is represented as an actual bit in memory.
For example, this allows the storage of 8Gbits in 1GB of memory.
Most of the functionallity is implemented in C, for speed.</p>
<p>Requires Python 2.5 or greater, see PEP 353.</p>
<div class="section" id="installation">
<h1>Installation</h1>
<p>bitarray can be installed from source:</p>
<pre class="literal-block">
$ tar xzf bitarray-0.2.0.tar.gz
$ cd bitarray-0.2.0
$ python setup.py install
</pre>
<p>On Unix systems, the latter command may be executed with root privileges.</p>
<p>If you have <a class="reference external" href="http://pypi.python.org/pypi/setuptools">setuptools</a> installed on your system, you can
easy_install bitarray.</p>
<p>Once you have installed the package, you may want to test it:</p>
<pre class="literal-block">
$ python -c 'from bitarray import test; test()'
bitarray is insalled in: /usr/local/lib/python2.5/site-packages/bitarray
bitarray version: 0.2.0
2.5.2 (r252:60911, Jul 17 2008, 10:38:24)
[GCC 4.2.1 (SUSE Linux)]
....................................
----------------------------------------------------------------------
Ran 36 tests in 0.294s

OK
</pre>
<p>In fact, one can always import the function test which in addition to
printing the test, also returns an instance of <cite>unittest._TextTestResult</cite>;
for example <cite>test().wasSuccessful()</cite> will return True when the test went OK.</p>
</div>
<div class="section" id="using-the-module">
<h1>Using the module</h1>
<p>Here are a few usage example, pointing out some differences to lists.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from bitarray import bitarray
&gt;&gt;&gt; a = bitarray()            # create empty bitarray
&gt;&gt;&gt; a.append(True)
&gt;&gt;&gt; a.extend([False, True])
&gt;&gt;&gt; a
bitarray('101')
&gt;&gt;&gt; a[-1]
True
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; len(a)
2
</pre>
</blockquote>
<p>Creating objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray(1024)        # bitarray of length 1024 (uninitialized)
&gt;&gt;&gt; bitarray('1001011')       # from string
bitarray('1001011')
&gt;&gt;&gt; lst = [True, False, False, True, False, True, True]
&gt;&gt;&gt; bitarray(lst)             # from list, tuple, sequence, iterable
bitarray('1001011')
</pre>
</blockquote>
<p>Bits can be assigned from any Python object.
Whenever bits are assigned, the built-in <cite>bool()</cite> function is used to
determine the value of the bit.  (Actually the C equivalent of <cite>bool()</cite>
is used.)</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray([42, '', True, {}, 'foo', None])
&gt;&gt;&gt; a
bitarray('101010')
&gt;&gt;&gt; a.append(a)      # note that bool(a) is True
&gt;&gt;&gt; a
bitarray('1010101')
&gt;&gt;&gt; a.count(42)      # counts occurrences of True
4L
&gt;&gt;&gt; a.remove('')     # removes first occurence of False
&gt;&gt;&gt; a
bitarray('110101')
</pre>
</blockquote>
<p>Like lists, bitarray objects support slice assignment and deletion:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray(50)
&gt;&gt;&gt; a.setall(False)
&gt;&gt;&gt; a[11:37:3] = 9*bitarray([True])
&gt;&gt;&gt; a
bitarray('00000000000100100100100100100100100100000000000000')
&gt;&gt;&gt; del a[12::3]
&gt;&gt;&gt; a
bitarray('0000000000010101010101010101000000000')
&gt;&gt;&gt; a[-6:] = bitarray('10011')
&gt;&gt;&gt; a
bitarray('000000000001010101010101010100010011')
&gt;&gt;&gt; a += bitarray('000111')
&gt;&gt;&gt; a
bitarray('000000000001010101010101010100010011000111')
</pre>
</blockquote>
</div>
<div class="section" id="bit-endianness">
<h1>Bit endianness</h1>
<p>Since a bitarray allows addressing of individual bits, where the machine
represents 8 bits in one byte, there two obvious choices for this mapping;
little- and big-endian.
When creating a new bitarray object, the endianness can always be
specified explicitly:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray(endian='little')
&gt;&gt;&gt; a.fromstring('A')
&gt;&gt;&gt; a
bitarray('10000010')
&gt;&gt;&gt; b = bitarray('11000010', endian='little')
&gt;&gt;&gt; b.tostring()
'C'
</pre>
</blockquote>
<p>Here the low-bit comes first because little-endian means that increasing
numeric significance corresponds to an increasing address (or index).
So a[0] is the lowest and least significant bit, and a[7] is the highest
and most significant bit.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray(endian='big')
&gt;&gt;&gt; a.fromstring('A')
&gt;&gt;&gt; a
bitarray('01000001')
&gt;&gt;&gt; a[6] = 1
&gt;&gt;&gt; a.tostring()
'C'
</pre>
</blockquote>
<p>Here the high-bit comes first because big-endian
means &quot;most-significant first&quot;.
So a[0] is now the lowest and most significant bit, and a[7] is the highest
and least significant bit.</p>
<p>The bit endianness is a property attachet to each bitarray object.
When comparing bitarray objects, the endianness (and hence the machine
representation) is irrelevant; what matters is the mapping from indicies
to bits:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; bitarray('11001', endian='big') == bitarray('11001', endian='little')
True
</pre>
</blockquote>
<p>When converting to and from machine representation, using
the <cite>tostring</cite>, <cite>fromstring</cite>, <cite>tofile</cite> and <cite>fromfile</cite> methods,
the endianness matters:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray(endian='little')
&gt;&gt;&gt; a.fromstring('\x01')
&gt;&gt;&gt; a
bitarray('10000000')
&gt;&gt;&gt; b = bitarray(endian='big')
&gt;&gt;&gt; b.fromstring('\x80')
&gt;&gt;&gt; a == b
True
&gt;&gt;&gt; a.tostring() == b.tostring()
False
</pre>
</blockquote>
<p>The endianness can not be changed once an object is created.
However, since creating a bitarray from another bitarray just copies the
memory representing the data, you can create a new bitarray with different
endianness:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = bitarray('11100000', endian='little')
&gt;&gt;&gt; b = bitarray(a, endian='big')
&gt;&gt;&gt; b
bitarray('00000111')
&gt;&gt;&gt; a == b
False
&gt;&gt;&gt; a.tostring() == b.tostring()
True
</pre>
</blockquote>
<p>The default bit endianness is currently big-endian, however this may change
in the future, and when dealing with the machine represention of bitarray
objects, it is recommanded to always explicitly specifiy the endianness.</p>
<p>Unless, excplicity converting to machine representation, using
the <cite>tostring</cite>, <cite>fromstring</cite>, <cite>tofile</cite> and <cite>fromfile</cite> methods,
the bit endianness will have no effect on any computation, and you
don't have to worry about setting the endianness, and other (possibly
confusing) details of this section.</p>
</div>
<div class="section" id="reference">
<h1>Reference</h1>
<p>A bitarray object has the following methods:</p>
<dl class="docutils">
<dt>append(x)</dt>
<dd>Append new value bool(x) to the end of the bitarray.</dd>
<dt>buffer_info()</dt>
<dd>Return a tuple (address, length, endianness) giving the current memory
address, and the length in bytes used to hold the bitarray's contents, and
the bit endianness as a string (either 'little' or 'big').
The length in bytes multiplied by 8 is slightly larger than the number of
bits the bitarray holds.</dd>
<dt>bytereverse()</dt>
<dd>For all bytes representing the bitarray, reverse the bit order.</dd>
<dt>count(x)</dt>
<dd>Return number of occurences of x in the bitarray.</dd>
<dt>endian()</dt>
<dd>return the bit endianness as a string (either 'little' or 'big').</dd>
<dt>extend(bitarray or iterable)</dt>
<dd>Append bits to the end of the bitarray.
When you want to extend from a list, it's faster to use fromlist.</dd>
<dt>fill()</dt>
<dd>When the length of the bitarray is not a mutiple of 8, increase the length
slightly such that the new length is a mutiple of 8, and set the few new
bits to zero.</dd>
<dt>from01(string)</dt>
<dd>Appends items from the string (containing '0's and '1's) to the bitarray.</dd>
<dt>fromfile(f [, n])</dt>
<dd>Read n bytes from the file object f and append them to the bitarray
interpreted as machine values.  When n is omitted, as many bytes are
read until EOF is reached.</dd>
<dt>fromlist(list)</dt>
<dd>Append bits to bitarray from list.</dd>
<dt>fromstring(string)</dt>
<dd>Append from a string, interpreting the string as machine values.</dd>
<dt>index(x)</dt>
<dd>Return index of first occurence of x in the bitarray.  It is an error when x
does not occur in the bitarray</dd>
<dt>insert(i, x)</dt>
<dd>Insert a new item x into the bitarray before position i.</dd>
<dt>invert(x)</dt>
<dd>Invert all bits in the bitarray, i.e. convert each 1-bit into a 0-bit
and vice versa.</dd>
<dt>length()</dt>
<dd>Return the length (number of bits) of the bitarray.</dd>
<dt>pop([i])</dt>
<dd>Return the i-th element and delete it from the bitarray. i defaults to -1.</dd>
<dt>remove(x)</dt>
<dd>Remove the first occurence of x in the bitarray.</dd>
<dt>reverse()</dt>
<dd>reverse the order of bits in the bitarray.</dd>
<dt>setall(x)</dt>
<dd>Set all bits in the bitarray to x.</dd>
<dt>to01(string)</dt>
<dd>Return a string containing '0's and '1's, representing the bits in the
bitarray object.</dd>
<dt>tofile(f)</dt>
<dd>Write all bits (as machine values) to the file object f.
When the length of the bitarray is not a mutiple of 8,
the few remaining bits are filled with zeros.</dd>
<dt>tolist()</dt>
<dd>Return an ordinary list with the items in the bitarray.</dd>
<dt>tostring()</dt>
<dd>Return the string representing (machine values) of the bitarray.
When the length of the bitarray is not a mutiple of 8, the few remaining
bits are filled with zeros.</dd>
</dl>
</div>
</div>
</body>
</html>
