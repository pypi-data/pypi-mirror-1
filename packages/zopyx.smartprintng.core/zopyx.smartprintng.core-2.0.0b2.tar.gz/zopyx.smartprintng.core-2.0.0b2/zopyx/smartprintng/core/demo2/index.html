<html>
    <head>
        
            <style type="text/css">
/* FOP styles */

h1 {font-size: 20px; color: blue;}
h2 {font-size: 16px; color: green;}
pre {background-color: #cccccc; display: block;}


</style>
        
        
            <style type="text/css">
/* Demo styles */

body {
    font-size: 12px;
}

</style>
        
    </head>
    <body>
        <div> Demo Demo </div>
        <div><div class="chapter sp-page"><h1 class="title">Component-Management objects</h1>
<p>Component-management objects provide a higher-level
component-management API over the basic adapter-registration API
provided by the zope.interface package.  In particular, it provides:</p>
<ul class="simple">
<li>utilities</li>
<li>support for computing adapters, rather than just looking up adapter
factories.</li>
<li>management of registration comments</li>
</ul>
<p>The zope.component.registry.Components class provides an
implementation of zope.component.interfaces.IComponents that provides
these features.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope.component import registry
&gt;&gt;&gt; from zope.component import tests
&gt;&gt;&gt; components = registry.Components('comps')
</pre>
</blockquote>
<p>As components are registered, events are generated.  Let's register
an event subscriber, so we can see the events generated:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import zope.event
&gt;&gt;&gt; def logevent(event):
...     print event
&gt;&gt;&gt; zope.event.subscribers.append(logevent)
</pre>
</blockquote>
<div class="section" id="utilities"></div>
<div class="chapter sp-page"><h1><a name="utilities">Utilities</a></h1>
<p>You can register Utilities using registerUtility:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U1(1))
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 1, u'')
</pre>
</blockquote>
<p>Here we didn't specify an interface or name.  An unnamed utility was
registered for interface I1, since that is only interface implemented
by the U1 class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.getUtility(tests.I1)
U1(1)
</pre>
</blockquote>
<p>If a component implements other than one interface or no interface,
then an error will be raised:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U12(2))
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The utility doesn't provide a single interface and
no provided interface was specified.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.A)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The utility doesn't provide a single interface and
no provided interface was specified.
</pre>
</blockquote>
<p>We can provide an interface if desired:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U12(2), tests.I2)
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I2, u'', 2, u'')
</pre>
</blockquote>
<p>and we can specify a name:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U12(3), tests.I2, u'three')
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I2, u'three', 3, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.getUtility(tests.I2)
U12(2)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.getUtility(tests.I2, 'three')
U12(3)
</pre>
</blockquote>
<p>If you try to get a utility that doesn't exist, you'll get a component
lookup error:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.getUtility(tests.I3)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
ComponentLookupError: 
(&lt;InterfaceClass zope.component.tests.I3&gt;, u'')
</pre>
</blockquote>
<p>Unless you use queryUtility:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryUtility(tests.I3)
&gt;&gt;&gt; components.queryUtility(tests.I3, default=42)
42
</pre>
</blockquote>
<p>You can get information about registered utilities with the
registeredUtilities method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredUtilities()):
...     print registration.provided, registration.name
...     print registration.component, registration.info
&lt;InterfaceClass zope.component.tests.I1&gt; 
U1(1) 
&lt;InterfaceClass zope.component.tests.I2&gt; 
U12(2) 
&lt;InterfaceClass zope.component.tests.I2&gt; three
U12(3) 
</pre>
</blockquote>
<p>Duplicate registrations replace existing ones:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U1(4), info=u'use 4 now')
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 4, u'use 4 now')
&gt;&gt;&gt; components.getUtility(tests.I1)
U1(4)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredUtilities()):
...     print registration.provided, registration.name
...     print registration.component, registration.info
&lt;InterfaceClass zope.component.tests.I1&gt; 
U1(4) use 4 now
&lt;InterfaceClass zope.component.tests.I2&gt; 
U12(2) 
&lt;InterfaceClass zope.component.tests.I2&gt; three
U12(3) 
</pre>
</blockquote>
<p>As shown in the this example, you can provide an &quot;info&quot; argumemnt when
registering utilities.  This provides extra documentation about the
registration itself that is shown when listing registrations.</p>
<p>You can also unregister utilities:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterUtility(provided=tests.I1)
Unregistered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 4, u'use 4 now')
True
</pre>
</blockquote>
<p>A boolean is returned indicating whether anything changed:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryUtility(tests.I1)
&gt;&gt;&gt; for registration in sorted(components.registeredUtilities()):
...     print registration.provided, registration.name
...     print registration.component, registration.info
&lt;InterfaceClass zope.component.tests.I2&gt; 
U12(2) 
&lt;InterfaceClass zope.component.tests.I2&gt; three
U12(3) 
</pre>
</blockquote>
<p>When you unregister, you can specify a component.  If the component
doesn't match the one registered, then nothing happens:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; u5 = tests.U1(5)
&gt;&gt;&gt; components.registerUtility(u5)
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
&gt;&gt;&gt; components.unregisterUtility(tests.U1(6))
False
&gt;&gt;&gt; components.queryUtility(tests.I1)
U1(5)
&gt;&gt;&gt; components.unregisterUtility(u5)
Unregistered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
True
&gt;&gt;&gt; components.queryUtility(tests.I1)
</pre>
</blockquote>
<p>You can get the name and utility for all of the utilities that provide
an interface using getUtilitiesFor:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted(components.getUtilitiesFor(tests.I2))
[(u'', U12(2)), (u'three', U12(3))]
</pre>
</blockquote>
<p>getAllUtilitiesRegisteredFor is similar to getUtilitiesFor except that
it includes utilities that are overridden.  For example, we'll
register a utility that for an extending interface of I2:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(tests.U('ext'), tests.I2e)
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I2e, u'', ext, u'')
</pre>
</blockquote>
<p>We don't get the new utility for getUtilitiesFor:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted(components.getUtilitiesFor(tests.I2))
[(u'', U12(2)), (u'three', U12(3))]
</pre>
</blockquote>
<p>but we do get it from getAllUtilitiesRegisteredFor:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sorted(map(str, components.getAllUtilitiesRegisteredFor(tests.I2)))
['U(ext)', 'U12(2)', 'U12(3)']
</pre>
</blockquote>
</div>
<div class="section" id="adapters"></div>
<div class="chapter sp-page"><h1><a name="adapters">Adapters</a></h1>
<p>You can register adapters with registerAdapter:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A12_1)
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
</pre>
</blockquote>
<p>Here, we didn't specify required interfaces, a provided interface, or
a name.  The required interfaces were determined from the factory
s __component_adapts__ attribute and the provided interface was
determined by introspecting what the factory implements.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.getMultiAdapter((tests.U1(6), tests.U12(7)), tests.IA1)
A12_1(U1(6), U12(7))
</pre>
</blockquote>
<p>If a factory implements more than one interface, an exception will be
raised:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_12)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single
interface and no provided interface was specified.
</pre>
</blockquote>
<p>Unless the provided interface is specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_12, provided=tests.IA2)
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
</pre>
</blockquote>
<p>If a factory doesn't declare an implemented interface, an exception will be
raised:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A12_)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single
interface and no provided interface was specified. 
</pre>
</blockquote>
<p>Unless the provided interface is specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A12_, provided=tests.IA2)
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA2, u'', A12_, u'')
</pre>
</blockquote>
<p>The required interface needs to be specified in the registration if
the factory doesn't have a __component_adapts__ attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A_2)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't have a __component_adapts__
attribute and no required specifications were specified 
</pre>
</blockquote>
<p>Unless the required specifications specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A_2, required=[tests.I3])
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I3], IA2, u'', A_2, u'')
</pre>
</blockquote>
<p>Classes can be specified in place of specifications, in which case the
implementedBy specification for the class is used:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A_3, required=[tests.U],
...                            info=&quot;Really class specific&quot;)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [zope.component.tests.U], IA3, u'',
                    A_3, 'Really class specific')
</pre>
</blockquote>
<p>We can see the adapters that have been registered using the
registeredAdapters method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;InterfaceClass zope.component.tests.I1&gt;, 
 &lt;InterfaceClass zope.component.tests.I2&gt;)
&lt;InterfaceClass zope.component.tests.IA1&gt; 
zope.component.tests.A12_1 
(&lt;InterfaceClass zope.component.tests.I1&gt;, 
 &lt;InterfaceClass zope.component.tests.I2&gt;)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A12_ 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_12 
(&lt;InterfaceClass zope.component.tests.I3&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A_2 
(&lt;implementedBy zope.component.tests.U&gt;,)
&lt;InterfaceClass zope.component.tests.IA3&gt; 
zope.component.tests.A_3 Really class specific
</pre>
</blockquote>
<p>As with utilities, we can provide registration information when
registering adapters.</p>
<p>If you try to fetch an adapter that isn't registered, you'll get a
component-lookup error:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.getMultiAdapter((tests.U(8), ), tests.IA1)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
ComponentLookupError: ((U(8),), 
                      &lt;InterfaceClass zope.component.tests.IA1&gt;, u'')
</pre>
</blockquote>
<p>unless you use queryAdapter:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryMultiAdapter((tests.U(8), ), tests.IA1)
&gt;&gt;&gt; components.queryMultiAdapter((tests.U(8), ), tests.IA1, default=42)
42
</pre>
</blockquote>
<p>When looking up an adapter for a single object, you can use the
slightly simpler getAdapter and queryAdapter calls:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.getAdapter(tests.U1(9), tests.IA2)
A1_12(U1(9))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryAdapter(tests.U1(9), tests.IA2)
A1_12(U1(9))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.getAdapter(tests.U(8), tests.IA1)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
ComponentLookupError: (U(8), 
                       &lt;InterfaceClass zope.component.tests.IA1&gt;, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryAdapter(tests.U(8), tests.IA2)
&gt;&gt;&gt; components.queryAdapter(tests.U(8), tests.IA2, default=42)
42
</pre>
</blockquote>
<p>You can unregister an adapter.  If a factory is provided and if the
rewuired and provided interfaces, can be infered, then they need not
be provided:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A12_1)
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;InterfaceClass zope.component.tests.I1&gt;, 
 &lt;InterfaceClass zope.component.tests.I2&gt;)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A12_ 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_12 
(&lt;InterfaceClass zope.component.tests.I3&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A_2 
(&lt;implementedBy zope.component.tests.U&gt;,)
&lt;InterfaceClass zope.component.tests.IA3&gt; 
zope.component.tests.A_3 Really class specific
</pre>
</blockquote>
<p>A boolean is returned indicating whether a change was made.</p>
<p>If a factory implements more than one interface, an exception will be
raised:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A1_12)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single
interface and no provided interface was specified.
</pre>
</blockquote>
<p>Unless the provided interface is specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A1_12, provided=tests.IA2)
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
True
</pre>
</blockquote>
<p>If a factory doesn't declare an implemented interface, an exception will be
raised:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A12_)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single
interface and no provided interface was specified. 
</pre>
</blockquote>
<p>Unless the provided interface is specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A12_, provided=tests.IA2)
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA2, u'', A12_, u'')
True
</pre>
</blockquote>
<p>The required interface needs to be specified if the factory doesn't
have a __component_adapts__ attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A_2)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't have a __component_adapts__
attribute and no required specifications were specified 
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A_2, required=[tests.I3])
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I3], IA2, u'', A_2, u'')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;implementedBy zope.component.tests.U&gt;,)
&lt;InterfaceClass zope.component.tests.IA3&gt; 
zope.component.tests.A_3 Really class specific
</pre>
</blockquote>
<p>If a factory is unregistered that is not registered, False is
returned:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A_2, required=[tests.I3])
False
&gt;&gt;&gt; components.unregisterAdapter(tests.A12_1, required=[tests.U])
False
</pre>
</blockquote>
<p>The factory can be omitted, to unregister <em>any</em> factory that matches
specified required and provided interfaces:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(required=[tests.U], provided=tests.IA3)
... # doctest: +NORMALIZE_WHITESPACE
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [zope.component.tests.U], 
                    IA3, u'', A_3, 'Really class specific')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(components.registeredAdapters()):
...     print registration
</pre>
</blockquote>
<p>Adapters can be named:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_12, provided=tests.IA2, 
...                            name=u'test')
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'test', A1_12, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryMultiAdapter((tests.U1(9), ), tests.IA2)
&gt;&gt;&gt; components.queryMultiAdapter((tests.U1(9), ), tests.IA2, name=u'test')
A1_12(U1(9))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.queryAdapter(tests.U1(9), tests.IA2)
&gt;&gt;&gt; components.queryAdapter(tests.U1(9), tests.IA2, name=u'test')
A1_12(U1(9))
&gt;&gt;&gt; components.getAdapter(tests.U1(9), tests.IA2, name=u'test')
A1_12(U1(9))
</pre>
</blockquote>
<p>It is possible to look up all of the adapters that provide an
interface:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_23, provided=tests.IA2, 
...                            name=u'test 2')
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'test 2', A1_23, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_12, provided=tests.IA2)
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for name, adapter in sorted(components.getAdapters((tests.U1(9), ), 
...                                                    tests.IA2)):
...     print name, adapter
 A1_12(U1(9))
test A1_12(U1(9))
test 2 A1_23(U1(9))
</pre>
</blockquote>
<p>getAdapters is most commonly used as the basis of menu systems.</p>
<p>If an adapter factory returns None, it is equivalent to there being no
factory:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.noop, 
...                            required=[tests.IA1], provided=tests.IA2, 
...                            name=u'test noop')
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [IA1], IA2, u'test noop', 
                    noop, u'')
&gt;&gt;&gt; components.queryAdapter(tests.U1(9), tests.IA2, name=u'test noop')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A1_12, provided=tests.IA2)
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for name, adapter in sorted(components.getAdapters((tests.U1(9), ), 
...                                                    tests.IA2)):
...     print name, adapter
 A1_12(U1(9))
test A1_12(U1(9))
test 2 A1_23(U1(9))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterAdapter(tests.A1_12, provided=tests.IA2, 
...                              name=u'test')
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'test', A1_12, u'')
True
&gt;&gt;&gt; components.unregisterAdapter(tests.A1_12, provided=tests.IA2)
Unregistered event:
AdapterRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
True
&gt;&gt;&gt; for registration in sorted(components.registeredAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; test 2
zope.component.tests.A1_23 
(&lt;InterfaceClass zope.component.tests.IA1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; test noop
&lt;function noop at 0xb79a1064&gt; 
</pre>
</blockquote>
</div>
<div class="section" id="subscribers"></div>
<div class="chapter sp-page"><h1><a name="subscribers">Subscribers</a></h1>
<p>Subscribers provide a way to get multiple adapters of a given type.
In this regard, subscribers are like named adapters, except that there
isn't any concept of the most specific adapter for a given name.</p>
<p>Subscribers are registered by calling registerSubscriptionAdapter:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(tests.A1_2)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(
...     tests.A1_12, provided=tests.IA2)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_12, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(
...     tests.A, [tests.I1], tests.IA2,
...     info='a sample comment')
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', 
                         A, 'a sample comment')
</pre>
</blockquote>
<p>The same rules, with regard to when required and provided interfaces
have to be specified apply as with adapters:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(tests.A1_12)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single 
interface and no provided interface was specified.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(tests.A)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single interface and
 no provided interface was specified.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(tests.A, required=[tests.IA1])
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single interface
and no provided interface was specified.
</pre>
</blockquote>
<p>Note that we provided the info argument as a keyword argument above.
That's because there is a name argument that's reserved for future
use. We can give a name, as long as it is an empty string:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(
...     tests.A, [tests.I1], tests.IA2, u'', 'a sample comment')
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', 
                         A, 'a sample comment')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(
...     tests.A, [tests.I1], tests.IA2, u'oops', 'a sample comment')
Traceback (most recent call last):
...
TypeError: Named subscribers are not yet supported
</pre>
</blockquote>
<p>Subscribers are looked up using the subscribers method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in components.subscribers((tests.U1(1), ), tests.IA2):
...    print s
A1_2(U1(1))
A1_12(U1(1))
A(U1(1),)
A(U1(1),)
</pre>
</blockquote>
<p>Note that, because we created multiple subscriptions for A, we got multiple
subscriber instances.</p>
<p>As with normal adapters, if a factory returns None, the result is skipped:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(
...     tests.noop, [tests.I1], tests.IA2)
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', noop, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for s in components.subscribers((tests.U1(1), ), tests.IA2):
...    print s
A1_2(U1(1))
A1_12(U1(1))
A(U1(1),)
A(U1(1),)
</pre>
</blockquote>
<p>We can get registration information for subscriptions:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(
...     components.registeredSubscriptionAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A a sample comment
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A a sample comment
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_12 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_2 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
&lt;function noop at 0xb796ff7c&gt; 
</pre>
</blockquote>
<p>We can also unregister subscriptions in much the same way we can for adapters:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(tests.A1_2)
... # doctest: +NORMALIZE_WHITESPACE
Unregistered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, '')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for s in components.subscribers((tests.U1(1), ), tests.IA2):
...    print s
A1_12(U1(1))
A(U1(1),)
A(U1(1),)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(
...     components.registeredSubscriptionAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A a sample comment
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A a sample comment
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_12 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
&lt;function noop at 0xb796ff7c&gt; 
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(
...     tests.A, [tests.I1], tests.IA2)
Unregistered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A, '')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for s in components.subscribers((tests.U1(1), ), tests.IA2):
...    print s
A1_12(U1(1))
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(
...     components.registeredSubscriptionAdapters()):
...     print registration.required
...     print registration.provided, registration.name
...     print registration.factory, registration.info
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
zope.component.tests.A1_12 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;InterfaceClass zope.component.tests.IA2&gt; 
&lt;function noop at 0xb796ff7c&gt; 
</pre>
</blockquote>
<p>Note here that both registrations for A were removed.</p>
<p>If we omit the factory, we must specify the required and provided interfaces:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(required=[tests.I1])
Traceback (most recent call last):
...
TypeError: Must specify one of factory and provided
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(provided=tests.IA2)
Traceback (most recent call last):
...
TypeError: Must specify one of factory and required
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(
...     required=[tests.I1], provided=tests.IA2)
Unregistered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', None, '')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for s in components.subscribers((tests.U1(1), ), tests.IA2):
...    print s
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in sorted(
...     components.registeredSubscriptionAdapters()):
...     print registration.factory
</pre>
</blockquote>
<p>As when registering, an error is raised if the registration
information can't be determined from the factory and isn't specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(tests.A1_12)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single 
interface and no provided interface was specified.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(tests.A)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single interface and
 no provided interface was specified.
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(tests.A, required=[tests.IA1])
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't implement a single interface
and no provided interface was specified.
</pre>
</blockquote>
<p>If you unregister something that's not registered, nothing will be
changed and False will be returned:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterSubscriptionAdapter(
...     required=[tests.I1], provided=tests.IA2)
False
</pre>
</blockquote>
</div>
<div class="section" id="handlers"></div>
<div class="chapter sp-page"><h1><a name="handlers">Handlers</a></h1>
<p>Handlers are used when you want to perform some function in response
to an event.  Handlers aren't expected to return anything when called
and are not registered to provide any interface.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope import component
&gt;&gt;&gt; &#64;component.adapter(tests.I1)
... def handle1(x):
...     print 'handle1', x
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle1, info=&quot;First handler&quot;)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
HandlerRegistration(&lt;Components comps&gt;, [I1], u'', 
                    handle1, 'First handler')
&gt;&gt;&gt; components.handle(tests.U1(1))
handle1 U1(1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;component.adapter(tests.I1, tests.I2)
... def handle12(x, y):
...     print 'handle12', x, y
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle12)
Registered event:
HandlerRegistration(&lt;Components comps&gt;, [I1, I2], u'', handle12, u'')
&gt;&gt;&gt; components.handle(tests.U1(1), tests.U12(2))
handle12 U1(1) U12(2)
</pre>
</blockquote>
<p>If a handler doesn't document interfaces it handles, then 
the required interfaces must be specified:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def handle(*objects):
...     print 'handle', objects
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't have a __component_adapts__ 
attribute and no required specifications were specified
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle, required=[tests.I1], 
...                            info=&quot;a comment&quot;)
Registered event:
HandlerRegistration(&lt;Components comps&gt;, [I1], u'', handle, 'a comment')
</pre>
</blockquote>
<p>Handlers can also be registered for classes:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle, required=[tests.U], 
...                            info=&quot;handle a class&quot;)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
HandlerRegistration(&lt;Components comps&gt;, [zope.component.tests.U], u'', 
                    handle, 'handle a class')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.handle(tests.U1(1))
handle (U1(1),)
handle1 U1(1)
handle (U1(1),)
</pre>
</blockquote>
<p>We can list the handler registrations:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in components.registeredHandlers():
...     print registration.required
...     print registration.handler, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle1 at 0xb78f5bfc&gt; First handler
(&lt;InterfaceClass zope.component.tests.I1&gt;,
 &lt;InterfaceClass zope.component.tests.I2&gt;)
&lt;function handle12 at 0xb78f5c34&gt; 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle at 0xb78f5ca4&gt; a comment
(&lt;implementedBy zope.component.tests.U&gt;,)
&lt;function handle at 0xb78f5ca4&gt; handle a class
</pre>
</blockquote>
<p>and we can unregister handlers:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterHandler(required=[tests.U])
... # doctest: +NORMALIZE_WHITESPACE
Unregistered event:
HandlerRegistration(&lt;Components comps&gt;, [zope.component.tests.U], u'', 
                    None, '')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in components.registeredHandlers():
...     print registration.required
...     print registration.handler, registration.info
... # doctest: +NORMALIZE_WHITESPACE
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle1 at 0xb78f5bfc&gt; First handler
(&lt;InterfaceClass zope.component.tests.I1&gt;,
 &lt;InterfaceClass zope.component.tests.I2&gt;)
&lt;function handle12 at 0xb78f5c34&gt; 
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle at 0xb78f5ca4&gt; a comment
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterHandler(handle12)
Unregistered event:
HandlerRegistration(&lt;Components comps&gt;, [I1, I2], u'', handle12, '')
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; for registration in components.registeredHandlers():
...     print registration.required
...     print registration.handler, registration.info
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle1 at 0xb78f5bfc&gt; First handler
(&lt;InterfaceClass zope.component.tests.I1&gt;,)
&lt;function handle at 0xb78f5ca4&gt; a comment
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterHandler(handle12)
False
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.unregisterHandler()
Traceback (most recent call last):
...
TypeError: Must specify one of factory and required
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerHandler(handle)
... # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
...
TypeError: The adapter factory doesn't have a __component_adapts__ 
attribute and no required specifications were specified
</pre>
</blockquote>
</div>
<div class="section" id="extending"></div>
<div class="chapter sp-page"><h1><a name="extending">Extending</a></h1>
<p>Component-management objects can extend other component-management
objects.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c1 = registry.Components('1')
&gt;&gt;&gt; c1.__bases__
()
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c2 = registry.Components('2', (c1, ))
&gt;&gt;&gt; c2.__bases__ == (c1, )
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c1.registerUtility(tests.U1(1))
Registered event:
UtilityRegistration(&lt;Components 1&gt;, I1, u'', 1, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c1.queryUtility(tests.I1)
U1(1)
&gt;&gt;&gt; c2.queryUtility(tests.I1)
U1(1)
&gt;&gt;&gt; c1.registerUtility(tests.U1(2))
Registered event:
UtilityRegistration(&lt;Components 1&gt;, I1, u'', 2, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c2.queryUtility(tests.I1)
U1(2)
</pre>
</blockquote>
<p>We can use multiple inheritence:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c3 = registry.Components('3', (c1, ))
&gt;&gt;&gt; c4 = registry.Components('4', (c2, c3))
&gt;&gt;&gt; c4.queryUtility(tests.I1)
U1(2)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c1.registerUtility(tests.U12(1), tests.I2)
Registered event:
UtilityRegistration(&lt;Components 1&gt;, I2, u'', 1, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c4.queryUtility(tests.I2)
U12(1)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c3.registerUtility(tests.U12(3), tests.I2)
Registered event:
UtilityRegistration(&lt;Components 3&gt;, I2, u'', 3, u'')
&gt;&gt;&gt; c4.queryUtility(tests.I2)
U12(3)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c1.registerHandler(handle1, info=&quot;First handler&quot;)
Registered event:
HandlerRegistration(&lt;Components 1&gt;, [I1], u'', handle1, 'First handler')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c2.registerHandler(handle, required=[tests.U])
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
HandlerRegistration(&lt;Components 2&gt;, [zope.component.tests.U], u'', 
                    handle, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;component.adapter(tests.I1)
... def handle3(x):
...     print 'handle3', x
&gt;&gt;&gt; c3.registerHandler(handle3)
Registered event:
HandlerRegistration(&lt;Components 3&gt;, [I1], u'', handle3, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;component.adapter(tests.I1)
... def handle4(x):
...     print 'handle4', x
&gt;&gt;&gt; c4.registerHandler(handle4)
Registered event:
HandlerRegistration(&lt;Components 4&gt;, [I1], u'', handle4, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c4.handle(tests.U1(1))
handle1 U1(1)
handle3 U1(1)
handle (U1(1),)
handle4 U1(1)
</pre>
</blockquote>
</div>
<div class="section" id="redispatch-of-registration-events"></div>
<div class="chapter"><h1><a name="redispatch-of-registration-events">Redispatch of registration events</a></h1>
<p>Some handlers are available that, if registered, redispatch
registration events to the objects being registered.  They depend on
being dispatched to by the object-event dispatcher:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from zope import component
&gt;&gt;&gt; import zope.component.event
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(
...      zope.component.event.objectEventNotify)
... # doctest: +NORMALIZE_WHITESPACE
Registered event:
HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
                    [IObjectEvent], u'', objectEventNotify, u'')
</pre>
</blockquote>
<p>To see this, we'll first register a multi-handler to show is when
handlers are called on 2 objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; &#64;zope.component.adapter(None, None)
... def double_handler(o1, o2):
...     print 'Double dispatch:'
...     print ' ', o1
...     print ' ', o2
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(double_handler)
... # doctest: +NORMALIZE_WHITESPACE
Double dispatch:
  HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
                      [Interface, Interface], u'', double_handler, u'')
  Registered event:
  HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
  [Interface, Interface], u'', double_handler, u'')
Registered event:
HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
                    [Interface, Interface], u'', double_handler, u'')
</pre>
</blockquote>
<p>In the example above, the double_handler reported it's own registration. :)</p>
<p>Now we'll register our handlers:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(
...     registry.dispatchUtilityRegistrationEvent)
... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
Double dispatch:
...
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(
...     registry.dispatchAdapterRegistrationEvent)
... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
Double dispatch:
...
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(
...     registry.dispatchSubscriptionAdapterRegistrationEvent)
... # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
Double dispatch:
...
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; zope.component.getGlobalSiteManager().registerHandler(
...     registry.dispatchHandlerRegistrationEvent)
... # doctest: +NORMALIZE_WHITESPACE
Double dispatch:
  HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
                      [IHandlerRegistration, IRegistrationEvent], u'', 
                      dispatchHandlerRegistrationEvent, u'')
  Registered event:
  HandlerRegistration(&lt;BaseGlobalComponents base&gt;, 
                      [IHandlerRegistration, IRegistrationEvent], u'', 
                      dispatchHandlerRegistrationEvent, u'')
Double dispatch:
  &lt;function dispatchHandlerRegistrationEvent at 0xb799f72c&gt;
  Registered event:
  HandlerRegistration(&lt;BaseGlobalComponents base&gt;,
                      [IHandlerRegistration, IRegistrationEvent], u'',
                      dispatchHandlerRegistrationEvent, u'')
Registered event:
HandlerRegistration(&lt;BaseGlobalComponents base&gt;,
                    [IHandlerRegistration, IRegistrationEvent], u'',
                    dispatchHandlerRegistrationEvent, u'')
</pre>
</blockquote>
<p>In the last example above, we can see that the registration of
dispatchHandlerRegistrationEvent was handled by
dispatchHandlerRegistrationEvent and redispatched.  This can be seen
in the second double-dispatch output, where the first argument is the
object being registered, which is dispatchHandlerRegistrationEvent.</p>
<p>If we change some other registrations, we can the double dispatch
taking place:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerUtility(u5)
... # doctest: +NORMALIZE_WHITESPACE
Double dispatch:
  UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
  Registered event:
  UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
Double dispatch:
  U1(5)
  Registered event:
  UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
Registered event:
UtilityRegistration(&lt;Components comps&gt;, I1, u'', 5, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerAdapter(tests.A12_1)
... # doctest: +NORMALIZE_WHITESPACE
Double dispatch:
  AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
  Registered event:
  AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
Double dispatch:
  zope.component.tests.A12_1
  Registered event:
  AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
Registered event:
AdapterRegistration(&lt;Components comps&gt;, [I1, I2], IA1, u'', A12_1, u'')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; components.registerSubscriptionAdapter(tests.A1_2)
... # doctest: +NORMALIZE_WHITESPACE
Double dispatch:
  SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, u'')
  Registered event:
  SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, u'')
Double dispatch:
  zope.component.tests.A1_2
  Registered event:
  SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, u'')
Registered event:
SubscriptionRegistration(&lt;Components comps&gt;, [I1], IA2, u'', A1_2, u'')
</pre>
</blockquote>
</div></div></div>
        <div> Demo Demo </div>
    </body>
</html>
