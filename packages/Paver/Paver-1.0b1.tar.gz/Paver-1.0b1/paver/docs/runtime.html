<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Pavement runtime helpers &mdash; Paver v1.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Paver v1.0 documentation" href="index.html" />
    <link rel="up" title="The Paver Standard Library" href="paverstdlib.html" />
    <link rel="next" title="distutils and setuptools" href="setuptools.html" />
    <link rel="prev" title="The Paver Standard Library" href="paverstdlib.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="setuptools.html" title="distutils and setuptools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="paverstdlib.html" title="The Paver Standard Library"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Paver v1.0 documentation</a> &raquo;</li>
          <li><a href="paverstdlib.html" accesskey="U">The Paver Standard Library</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-paver.runtime">
<span id="runtime"></span><h1>Pavement runtime helpers<a class="headerlink" href="#module-paver.runtime" title="Permalink to this headline">¶</a></h1>
<p>Helper functions and data structures used by pavements.</p>
<dl class="class">
<dt id="paver.runtime.Bunch">
<!--[paver.runtime.Bunch]-->class <tt class="descclassname">paver.runtime.</tt><tt class="descname">Bunch</tt><a class="headerlink" href="#paver.runtime.Bunch" title="Permalink to this definition">¶</a></dt>
<dd>A dictionary that provides attribute-style access.</dd></dl>

<dl class="function">
<dt id="paver.runtime.task">
<!--[paver.runtime.task]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">task</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#paver.runtime.task" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies that this function is a task.</p>
<p>Note that this decorator does not actually replace the function object.
It just keeps track of the task and sets an is_task flag on the
function object.</p>
</dd></dl>

<dl class="function">
<dt id="paver.runtime.needs">
<!--[paver.runtime.needs]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">needs</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#paver.runtime.needs" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies tasks upon which this task depends.</p>
<p>req can be a string or a list of strings with the names
of the tasks. You can call this decorator multiple times
and the various requirements are added on. You can also
call with the requirements as a list of arguments.</p>
<p>The requirements are called in the order presented in the
list.</p>
</dd></dl>

<dl class="function">
<dt id="paver.runtime.dry">
<!--[paver.runtime.dry]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">dry</tt><big>(</big><em>message</em>, <em>func</em>, <em>*args</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#paver.runtime.dry" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a function that performs a destructive operation, so that
nothing will happen when a dry run is requested.</p>
<p>Runs func with the given arguments and keyword arguments. If this
is a dry run, print the message rather than running the function.</p>
</dd></dl>

<dl class="function">
<dt id="paver.runtime.error">
<!--[paver.runtime.error]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">error</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#paver.runtime.error" title="Permalink to this definition">¶</a></dt>
<dd>Displays an error message to the user.</dd></dl>

<dl class="function">
<dt id="paver.runtime.info">
<!--[paver.runtime.info]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">info</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#paver.runtime.info" title="Permalink to this definition">¶</a></dt>
<dd>Displays a message to the user. If the quiet option is specified, the
message will not be displayed.</dd></dl>

<dl class="function">
<dt id="paver.runtime.debug">
<!--[paver.runtime.debug]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">debug</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#paver.runtime.debug" title="Permalink to this definition">¶</a></dt>
<dd>Displays a message to the user, but only if the verbose flag is
set.</dd></dl>

<dl class="function">
<dt id="paver.runtime.call_task">
<!--[paver.runtime.call_task]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">call_task</tt><big>(</big><em>task_name</em>, <em>options=None</em><big>)</big><a class="headerlink" href="#paver.runtime.call_task" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED. Just call the task instead.</p>
<p>Calls the desired task, including any tasks upon which that task
depends. options is an optional dictionary that will be added
to the option lookup search order.</p>
<p>You can always call a task directly by calling the function directly.
But, if you do so the dependencies aren&#8217;t called. call_task ensures
that these are called.</p>
<p>Note that call_task will only call the task <cite>once</cite> during a given
build as long as the options remain the same. If the options are
changed, the task will be called again.</p>
</dd></dl>

<dl class="function">
<dt id="paver.runtime.require_keys">
<!--[paver.runtime.require_keys]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">require_keys</tt><big>(</big><em>keys</em><big>)</big><a class="headerlink" href="#paver.runtime.require_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>GONE. There is no equivalent in Paver 1.0. Calling this
will raise an exception.</p>
<p>A set of dotted-notation keys that must be present in the
options for this task to be relevant.</p>
</dd></dl>

<dl class="function">
<dt id="paver.runtime.sh">
<!--[paver.runtime.sh]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">sh</tt><big>(</big><em>command</em>, <em>capture=False</em>, <em>ignore_error=False</em><big>)</big><a class="headerlink" href="#paver.runtime.sh" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs an external command. If capture is True, the output of the
command will be captured and returned as a string.  If the command 
has a non-zero return code raise a BuildFailure. You can pass
ignore_error=True to allow non-zero return codes to be allowed to
pass silently, silently into the night.</p>
<p>If the dry_run option is True, the command will not
actually be run.</p>
</dd></dl>

<dl class="exception">
<dt id="paver.runtime.BuildFailure">
<!--[paver.runtime.BuildFailure]-->exception <tt class="descclassname">paver.runtime.</tt><tt class="descname">BuildFailure</tt><a class="headerlink" href="#paver.runtime.BuildFailure" title="Permalink to this definition">¶</a></dt>
<dd>Represents a problem with some part of the build&#8217;s execution.</dd></dl>

<dl class="class">
<dt id="paver.runtime.path">
<!--[paver.runtime.path]-->class <tt class="descclassname">paver.runtime.</tt><tt class="descname">path</tt><a class="headerlink" href="#paver.runtime.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a filesystem path.</p>
<p>For documentation on individual methods, consult their
counterparts in os.path.</p>
<dl class="method">
<dt id="paver.runtime.path.access">
<!--[paver.runtime.path.access]--><tt class="descname">access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.runtime.path.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if current user has access to this path.</p>
<p>mode - One of the constants os.F_OK, os.R_OK, os.W_OK, os.X_OK</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.atime">
<!--[paver.runtime.path.atime]--><tt class="descname">atime</tt><a class="headerlink" href="#paver.runtime.path.atime" title="Permalink to this definition">¶</a></dt>
<dd>Last access time of the file.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.basename">
<!--[paver.runtime.path.basename]--><tt class="descname">basename</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#paver.runtime.path.basename" title="Permalink to this definition">¶</a></dt>
<dd>Returns the final component of a pathname</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.bytes">
<!--[paver.runtime.path.bytes]--><tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.bytes" title="Permalink to this definition">¶</a></dt>
<dd>Open this file, read all bytes, return them as a string.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.chdir">
<!--[paver.runtime.path.chdir]--><tt class="descname">chdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.chdir" title="Permalink to this definition">¶</a></dt>
<dd>Change current directory.</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.ctime">
<!--[paver.runtime.path.ctime]--><tt class="descname">ctime</tt><a class="headerlink" href="#paver.runtime.path.ctime" title="Permalink to this definition">¶</a></dt>
<dd>Creation time of the file.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.dirs">
<!--[paver.runtime.path.dirs]--><tt class="descname">dirs</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.runtime.path.dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>D.dirs() -&gt; List of this directory&#8217;s subdirectories.</p>
<p>The elements of the list are path objects.
This does not walk recursively into subdirectories
(but see path.walkdirs).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
directories whose names match the given pattern.  For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span><span class="o">.</span><span class="n">dirs</span><span class="p">(</span><span class="s">&#39;build-*&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.drive">
<!--[paver.runtime.path.drive]--><tt class="descname">drive</tt><a class="headerlink" href="#paver.runtime.path.drive" title="Permalink to this definition">¶</a></dt>
<dd>The drive specifier, for example &#8216;C:&#8217;.
This is always empty on systems that don&#8217;t use drive specifiers.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.exists">
<!--[paver.runtime.path.exists]--><tt class="descname">exists</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#paver.runtime.path.exists" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path exists.  Returns False for broken symbolic links</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.expand">
<!--[paver.runtime.path.expand]--><tt class="descname">expand</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up a filename by calling expandvars(),
expanduser(), and normpath() on it.</p>
<p>This is commonly everything needed to clean up a filename
read from a configuration file, for example.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.ext">
<!--[paver.runtime.path.ext]--><tt class="descname">ext</tt><a class="headerlink" href="#paver.runtime.path.ext" title="Permalink to this definition">¶</a></dt>
<dd>The file extension, for example &#8216;.py&#8217;.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.files">
<!--[paver.runtime.path.files]--><tt class="descname">files</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.runtime.path.files" title="Permalink to this definition">¶</a></dt>
<dd><p>D.files() -&gt; List of the files in this directory.</p>
<p>The elements of the list are path objects.
This does not walk into subdirectories (see path.walkfiles).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists files
whose names match the given pattern.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span><span class="o">.</span><span class="n">files</span><span class="p">(</span><span class="s">&#39;*.pyc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.fnmatch">
<!--[paver.runtime.path.fnmatch]--><tt class="descname">fnmatch</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.runtime.path.fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self.name matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A filename pattern with wildcards,</dt>
<dd>for example <tt class="docutils literal"><span class="pre">'*.py'</span></tt>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.get_owner">
<!--[paver.runtime.path.get_owner]--><tt class="descname">get_owner</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the owner of this file or directory.</p>
<p>This follows symbolic links.</p>
<p>On Windows, this returns a name of the form ur&#8217;DOMAINUser Name&#8217;.
On Windows, a group can own a file or directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.getatime">
<!--[paver.runtime.path.getatime]--><tt class="descname">getatime</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#paver.runtime.path.getatime" title="Permalink to this definition">¶</a></dt>
<dd>Return the last access time of a file, reported by os.stat().</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.getctime">
<!--[paver.runtime.path.getctime]--><tt class="descname">getctime</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#paver.runtime.path.getctime" title="Permalink to this definition">¶</a></dt>
<dd>Return the metadata change time of a file, reported by os.stat().</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.getcwd">
<!--[paver.runtime.path.getcwd]--><tt class="descname">getcwd</tt><a class="headerlink" href="#paver.runtime.path.getcwd" title="Permalink to this definition">¶</a></dt>
<dd>Return the current working directory as a path object.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.getmtime">
<!--[paver.runtime.path.getmtime]--><tt class="descname">getmtime</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#paver.runtime.path.getmtime" title="Permalink to this definition">¶</a></dt>
<dd>Return the last modification time of a file, reported by os.stat().</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.getsize">
<!--[paver.runtime.path.getsize]--><tt class="descname">getsize</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#paver.runtime.path.getsize" title="Permalink to this definition">¶</a></dt>
<dd>Return the size of a file, reported by os.stat().</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.glob">
<!--[paver.runtime.path.glob]--><tt class="descname">glob</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.runtime.path.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of path objects that match the pattern.</p>
<p>pattern - a path relative to this directory, with wildcards.</p>
<p>For example, path(&#8216;/users&#8217;).glob(&#8216;<em>/bin/</em>&#8216;) returns a list
of all the files users have in their bin directories.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.isabs">
<!--[paver.runtime.path.isabs]--><tt class="descname">isabs</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#paver.runtime.path.isabs" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path is absolute</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.isdir">
<!--[paver.runtime.path.isdir]--><tt class="descname">isdir</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#paver.runtime.path.isdir" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path is a directory</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.isfile">
<!--[paver.runtime.path.isfile]--><tt class="descname">isfile</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#paver.runtime.path.isfile" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path is a regular file</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.islink">
<!--[paver.runtime.path.islink]--><tt class="descname">islink</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#paver.runtime.path.islink" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path is a symbolic link</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.ismount">
<!--[paver.runtime.path.ismount]--><tt class="descname">ismount</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#paver.runtime.path.ismount" title="Permalink to this definition">¶</a></dt>
<dd>Test whether a path is a mount point</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.joinpath">
<!--[paver.runtime.path.joinpath]--><tt class="descname">joinpath</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#paver.runtime.path.joinpath" title="Permalink to this definition">¶</a></dt>
<dd>Join two or more path components, adding a separator
character (os.sep) if needed.  Returns a new path
object.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.lines">
<!--[paver.runtime.path.lines]--><tt class="descname">lines</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em>, <em>retain=True</em><big>)</big><a class="headerlink" href="#paver.runtime.path.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all lines, return them in a list.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  The default is None, meaning the content
of the file is read as 8-bit characters and returned
as a list of (non-Unicode) str objects.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;</dd>
<dt>retain - If true, retain newline characters; but all newline</dt>
<dd>character combinations (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;) are
translated to &#8216;n&#8217;.  If false, newline characters are
stripped off.  Default is True.</dd>
</dl>
</dd>
</dl>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.link">
<!--[paver.runtime.path.link]--><tt class="descname">link</tt><big>(</big><em>newpath</em><big>)</big><a class="headerlink" href="#paver.runtime.path.link" title="Permalink to this definition">¶</a></dt>
<dd>Create a hard link at &#8216;newpath&#8217;, pointing to this file.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.listdir">
<!--[paver.runtime.path.listdir]--><tt class="descname">listdir</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.runtime.path.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>D.listdir() -&gt; List of items in this directory.</p>
<p>Use D.files() or D.dirs() instead if you want a listing
of just files or just subdirectories.</p>
<p>The elements of the list are path objects.</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
items whose names match the given pattern.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.lstat">
<!--[paver.runtime.path.lstat]--><tt class="descname">lstat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.lstat" title="Permalink to this definition">¶</a></dt>
<dd>Like path.stat(), but do not follow symbolic links.</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.mtime">
<!--[paver.runtime.path.mtime]--><tt class="descname">mtime</tt><a class="headerlink" href="#paver.runtime.path.mtime" title="Permalink to this definition">¶</a></dt>
<dd>Last-modified time of the file.</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.name">
<!--[paver.runtime.path.name]--><tt class="descname">name</tt><a class="headerlink" href="#paver.runtime.path.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file or directory without the full path.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).name == &#8216;libpython.so&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.namebase">
<!--[paver.runtime.path.namebase]--><tt class="descname">namebase</tt><a class="headerlink" href="#paver.runtime.path.namebase" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as path.name, but with one file extension stripped off.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).name     == &#8216;python.tar.gz&#8217;,
but          path(&#8216;/home/guido/python.tar.gz&#8217;).namebase == &#8216;python.tar&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.open">
<!--[paver.runtime.path.open]--><tt class="descname">open</tt><big>(</big><em>mode='r'</em><big>)</big><a class="headerlink" href="#paver.runtime.path.open" title="Permalink to this definition">¶</a></dt>
<dd>Open this file.  Return a file object.</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.owner">
<!--[paver.runtime.path.owner]--><tt class="descname">owner</tt><a class="headerlink" href="#paver.runtime.path.owner" title="Permalink to this definition">¶</a></dt>
<dd>Name of the owner of this file or directory.</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.parent">
<!--[paver.runtime.path.parent]--><tt class="descname">parent</tt><a class="headerlink" href="#paver.runtime.path.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>This path&#8217;s parent directory, as a new path object.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).parent == path(&#8216;/usr/local/lib&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.read_md5">
<!--[paver.runtime.path.read_md5]--><tt class="descname">read_md5</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.read_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the md5 hash for this file.</p>
<p>This reads through the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.readlink">
<!--[paver.runtime.path.readlink]--><tt class="descname">readlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result may be an absolute or a relative path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.readlinkabs">
<!--[paver.runtime.path.readlinkabs]--><tt class="descname">readlinkabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.readlinkabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result is always an absolute path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.relpath">
<!--[paver.runtime.path.relpath]--><tt class="descname">relpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.relpath" title="Permalink to this definition">¶</a></dt>
<dd>Return this path as a relative path,
based from the current working directory.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.relpathto">
<!--[paver.runtime.path.relpathto]--><tt class="descname">relpathto</tt><big>(</big><em>dest</em><big>)</big><a class="headerlink" href="#paver.runtime.path.relpathto" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a relative path from self to dest.</p>
<p>If there is no relative path from self to dest, for example if
they reside on different drives in Windows, then this returns
dest.abspath().</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.samefile">
<!--[paver.runtime.path.samefile]--><tt class="descname">samefile</tt><big>(</big><em>f1</em>, <em>f2</em><big>)</big><a class="headerlink" href="#paver.runtime.path.samefile" title="Permalink to this definition">¶</a></dt>
<dd>Test whether two pathnames reference the same actual file</dd></dl>

<dl class="attribute">
<dt id="paver.runtime.path.size">
<!--[paver.runtime.path.size]--><tt class="descname">size</tt><a class="headerlink" href="#paver.runtime.path.size" title="Permalink to this definition">¶</a></dt>
<dd>Size of the file, in bytes.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.splitall">
<!--[paver.runtime.path.splitall]--><tt class="descname">splitall</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.splitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the path components in this path.</p>
<p>The first item in the list will be a path.  Its value will be
either os.curdir, os.pardir, empty, or the root directory of
this path (for example, &#8216;/&#8217; or &#8216;C:\&#8217;).  The other items in
the list will be strings.</p>
<p><tt class="docutils literal"><span class="pre">path.path.joinpath(*result)</span></tt> will yield the original path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.splitdrive">
<!--[paver.runtime.path.splitdrive]--><tt class="descname">splitdrive</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.splitdrive" title="Permalink to this definition">¶</a></dt>
<dd><p>p.splitdrive() -&gt; Return (p.drive, &lt;the rest of p&gt;).</p>
<p>Split the drive specifier from this path.  If there is
no drive specifier, p.drive is empty, so the return value
is simply (path(&#8216;&#8217;), p).  This is always the case on Unix.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.splitext">
<!--[paver.runtime.path.splitext]--><tt class="descname">splitext</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.splitext" title="Permalink to this definition">¶</a></dt>
<dd><p>p.splitext() -&gt; Return (p.stripext(), p.ext).</p>
<p>Split the filename extension from this path and return
the two parts.  Either part may be empty.</p>
<p>The extension is everything from &#8216;.&#8217; to the end of the
last path segment.  This has the property that if
(a, b) == p.splitext(), then a + b == p.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.splitpath">
<!--[paver.runtime.path.splitpath]--><tt class="descname">splitpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.splitpath" title="Permalink to this definition">¶</a></dt>
<dd>p.splitpath() -&gt; Return (p.parent, p.name).</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.stat">
<!--[paver.runtime.path.stat]--><tt class="descname">stat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.stat" title="Permalink to this definition">¶</a></dt>
<dd>Perform a stat() system call on this path.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.statvfs">
<!--[paver.runtime.path.statvfs]--><tt class="descname">statvfs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.statvfs" title="Permalink to this definition">¶</a></dt>
<dd>Perform a statvfs() system call on this path.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.stripext">
<!--[paver.runtime.path.stripext]--><tt class="descname">stripext</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.stripext" title="Permalink to this definition">¶</a></dt>
<dd><p>p.stripext() -&gt; Remove one file extension from the path.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).stripext()
returns path(&#8216;/home/guido/python.tar&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.symlink">
<!--[paver.runtime.path.symlink]--><tt class="descname">symlink</tt><big>(</big><em>newlink</em><big>)</big><a class="headerlink" href="#paver.runtime.path.symlink" title="Permalink to this definition">¶</a></dt>
<dd>Create a symbolic link at &#8216;newlink&#8217;, pointing here.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.text">
<!--[paver.runtime.path.text]--><tt class="descname">text</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.runtime.path.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read it in, return the content as a string.</p>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later, so &#8216;rn&#8217; and &#8216;r&#8217;
are automatically translated to &#8216;n&#8217;.</p>
<p>Optional arguments:</p>
<dl class="docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  If present, the content of the file is
decoded and returned as a unicode object; otherwise
it is returned as an 8-bit str.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.touch">
<!--[paver.runtime.path.touch]--><tt class="descname">touch</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.runtime.path.touch" title="Permalink to this definition">¶</a></dt>
<dd>Set the access/modified times of this file to the current time.
Create the file if it does not exist.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.utime">
<!--[paver.runtime.path.utime]--><tt class="descname">utime</tt><big>(</big><em>times</em><big>)</big><a class="headerlink" href="#paver.runtime.path.utime" title="Permalink to this definition">¶</a></dt>
<dd>Set the access and modified times of this file.</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.walk">
<!--[paver.runtime.path.walk]--><tt class="descname">walk</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.runtime.path.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walk() -&gt; iterator over files and subdirs, recursively.</p>
<p>The iterator yields path objects naming each child item of
this directory and its descendants.  This requires that
D.isdir().</p>
<p>This performs a depth-first traversal of the directory tree.
Each directory is returned just before all its children.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.walkdirs">
<!--[paver.runtime.path.walkdirs]--><tt class="descname">walkdirs</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.runtime.path.walkdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walkdirs() -&gt; iterator over subdirs, recursively.</p>
<p>With the optional &#8216;pattern&#8217; argument, this yields only
directories whose names match the given pattern.  For
example, <tt class="docutils literal"><span class="pre">mydir.walkdirs('*test')</span></tt> yields only directories
with names ending in &#8216;test&#8217;.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.walkfiles">
<!--[paver.runtime.path.walkfiles]--><tt class="descname">walkfiles</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.runtime.path.walkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walkfiles() -&gt; iterator over files in D, recursively.</p>
<p>The optional argument, pattern, limits the results to files
with names that match the pattern.  For example,
<tt class="docutils literal"><span class="pre">mydir.walkfiles('*.tmp')</span></tt> yields only files with the .tmp
extension.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.write_bytes">
<!--[paver.runtime.path.write_bytes]--><tt class="descname">write_bytes</tt><big>(</big><em>bytes</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.runtime.path.write_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file and write the given bytes to it.</p>
<p>Default behavior is to overwrite any existing file.
Call p.write_bytes(bytes, append=True) to append instead.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.write_lines">
<!--[paver.runtime.path.write_lines]--><tt class="descname">write_lines</tt><big>(</big><em>lines</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.runtime.path.write_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given lines of text to this file.</p>
<p>By default this overwrites any existing file at this path.</p>
<p>This puts a platform-specific newline sequence on every line.
See &#8216;linesep&#8217; below.</p>
<p>lines - A list of strings.</p>
<dl class="docutils">
<dt>encoding - A Unicode encoding to use.  This applies only if</dt>
<dd>&#8216;lines&#8217; contains any Unicode strings.</dd>
<dt>errors - How to handle errors in Unicode encoding.  This</dt>
<dd>also applies only to Unicode strings.</dd>
<dt>linesep - The desired line-ending.  This line-ending is</dt>
<dd>applied to every line.  If a line already has any
standard line ending (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;, u&#8217;x85&#8217;,
u&#8217;rx85&#8217;, u&#8217;u2028&#8217;), that will be stripped off and
this will be used instead.  The default is os.linesep,
which is platform-dependent (&#8216;rn&#8217; on Windows, &#8216;n&#8217; on
Unix, etc.)  Specify None to write the lines as-is,
like file.writelines().</dd>
</dl>
<p>Use the keyword argument append=True to append lines to the
file.  The default is to overwrite the file.  Warning:
When you use this with Unicode data, if the encoding of the
existing data in the file is different from the encoding
you specify with the encoding= parameter, the result is
mixed-encoding data, which can really confuse someone trying
to read the file later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.runtime.path.write_text">
<!--[paver.runtime.path.write_text]--><tt class="descname">write_text</tt><big>(</big><em>text</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.runtime.path.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given text to this file.</p>
<p>The default behavior is to overwrite any existing file;
to append instead, use the &#8216;append=True&#8217; keyword argument.</p>
<p>There are two differences between path.write_text() and
path.write_bytes(): newline handling and Unicode handling.
See below.</p>
<p>Parameters:</p>
<blockquote>
<ul class="simple">
<li>text - str/unicode - The text to be written.</li>
<li>encoding - str - The Unicode encoding that will be used.
This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode string.</li>
<li>errors - str - How to handle Unicode encoding errors.
Default is &#8216;strict&#8217;.  See help(unicode.encode) for the
options.  This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode
string.</li>
<li>linesep - keyword argument - str/unicode - The sequence of
characters to be used to mark end-of-line.  The default is
os.linesep.  You can also specify None; this means to
leave all newlines as they are in &#8216;text&#8217;.</li>
<li>append - keyword argument - bool - Specifies what to do if
the file already exists (True: append to the end of it;
False: overwrite it.)  The default is False.</li>
</ul>
</blockquote>
<p>&#8212; Newline handling.</p>
<p>write_text() converts all standard end-of-line sequences
(&#8216;n&#8217;, &#8216;r&#8217;, and &#8216;rn&#8217;) to your platform&#8217;s default end-of-line
sequence (see os.linesep; on Windows, for example, the
end-of-line marker is &#8216;rn&#8217;).</p>
<p>If you don&#8217;t like your platform&#8217;s default, you can override it
using the &#8216;linesep=&#8217; keyword argument.  If you specifically want
write_text() to preserve the newlines as-is, use &#8216;linesep=None&#8217;.</p>
<p>This applies to Unicode text the same as to 8-bit text, except
there are three additional standard Unicode end-of-line sequences:
u&#8217;x85&#8217;, u&#8217;rx85&#8217;, and u&#8217;u2028&#8217;.</p>
<p>(This is slightly different from when you open a file for
writing with fopen(filename, &#8220;w&#8221;) in C or file(filename, &#8216;w&#8217;)
in Python.)</p>
<p>&#8212; Unicode</p>
<p>If &#8216;text&#8217; isn&#8217;t Unicode, then apart from newline handling, the
bytes are written verbatim to the file.  The &#8216;encoding&#8217; and
&#8216;errors&#8217; arguments are not used and must be omitted.</p>
<p>If &#8216;text&#8217; is Unicode, it is first converted to bytes using the
specified &#8216;encoding&#8217; (or the default encoding if &#8216;encoding&#8217;
isn&#8217;t specified).  The &#8216;errors&#8217; argument applies only to this
conversion.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="paver.runtime.cmdopts">
<!--[paver.runtime.cmdopts]--><tt class="descclassname">paver.runtime.</tt><tt class="descname">cmdopts</tt><big>(</big><em>options</em><big>)</big><a class="headerlink" href="#paver.runtime.cmdopts" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the command line options that can be set for this task.
This uses the same format as the distutils command line option
parser. It&#8217;s a list of tuples, each with three elements:
long option name, short option, description.</p>
<p>If the long option name ends with &#8216;=&#8217;, that means that the
option takes a value. Otherwise the option is just boolean.
All of the options will be stored in the options dict with
the name of the task. Each value that gets stored in that
dict will be stored with a key that is based on the long option
name (the only difference is that - is replaced by _).</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="paverstdlib.html" title="previous chapter">The Paver Standard Library</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="setuptools.html" title="next chapter">distutils and setuptools</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/runtime.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="setuptools.html" title="distutils and setuptools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="paverstdlib.html" title="The Paver Standard Library"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Paver v1.0 documentation</a> &raquo;</li>
          <li><a href="paverstdlib.html" accesskey="U">The Paver Standard Library</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, SitePen, Inc..
      Last updated on Mar 13, 2009.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.1.
    </div>
  </body>
</html>