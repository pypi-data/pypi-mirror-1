
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>File Handling in Paver &mdash; Paver Documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css">
    <link rel="stylesheet" href="_static/pygments.css" type="text/css">
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:   '',
        VERSION:    '0.4'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/interface.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html">
    <link rel="index" title="Global index" href="genindex.html">
    <link rel="search" title="Search" href="search.html">
    <link rel="top" title="Paver Documentation" href="index.html">
    <link rel="up" title="The Paver Standard Library" href="paverstdlib.html">
    <link rel="next" title="Sphinx" href="sphinx.html">
    <link rel="prev" title="distutils and setuptools" href="setuptools.html">
  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px"><a href="genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right"><a href="modindex.html" title="Global Module Index" accesskey="M">modules</a> |</li>
          <li class="right"><a href="sphinx.html" title="Sphinx" accesskey="N">next</a> |</li>
          <li class="right"><a href="setuptools.html" title="distutils and setuptools" accesskey="P">previous</a> |</li>
        <li><a href="index.html">Paver v0.4 documentation</a> &raquo;</li>
          <li><a href="paverstdlib.html" accesskey="U">The Paver Standard Library</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section">
<h1 id="module-paver.path"><span id="filehandling"></span>File Handling in Paver<a class="headerlink" href="#module-paver.path" title="Permalink to this headline">¶</a></h1>
<p>path.py - An object representing a path to a file or directory.</p>
<p>Example:</p>
<p>from path import path
d = path(&#8216;/home/guido/bin&#8217;)
for f in d.files(&#8216;<a href="#id1" name="id2"><span class="problematic" id="id2">*</span></a>.py&#8217;):</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: <a name="id1">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 15); <em><a href="#id2">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">&lt;docstring of paver.path&gt;</tt>, line 8)</p>
Unexpected indentation.</div>
<blockquote>
f.chmod(0755)</blockquote>
<p>This module requires Python 2.2 or later.</p>
<p>URL:     <a class="reference" href="http://www.jorendorff.com/articles/python/path">http://www.jorendorff.com/articles/python/path</a>
Author:  Jason Orendorff &lt;<a class="reference" href="mailto:jason&#46;orendorff&#37;&#52;&#48;gmail&#46;com">jason<span>&#46;</span>orendorff<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; (and others - see the url!)
Date:    9 Mar 2007</p>
<p>This has been modified from the original to avoid dry run issues.</p>
<dl class="class">
<dt id="paver.path.path">
<!--#paver.path.path#-->class <tt class="descclassname">paver.path.</tt><tt class="descname">path</tt><a class="headerlink" href="#paver.path.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a filesystem path.</p>
<p>For documentation on individual methods, consult their
counterparts in os.path.</p>
<dl class="method">
<dt id="paver.path.path.access">
<!--#paver.path.path.access#--><tt class="descname">access</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#paver.path.path.access" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if current user has access to this path.</p>
<p>mode - One of the constants os.F_OK, os.R_OK, os.W_OK, os.X_OK</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.atime">
<!--#paver.path.path.atime#--><tt class="descname">atime</tt><a class="headerlink" href="#paver.path.path.atime" title="Permalink to this definition">¶</a></dt>
<dd>Last access time of the file.</dd></dl>

<dl class="method">
<dt id="paver.path.path.bytes">
<!--#paver.path.path.bytes#--><tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.bytes" title="Permalink to this definition">¶</a></dt>
<dd>Open this file, read all bytes, return them as a string.</dd></dl>

<dl class="method">
<dt id="paver.path.path.capitalize">
<!--#paver.path.path.capitalize#--><tt class="descname">capitalize</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.capitalize" title="Permalink to this definition">¶</a></dt>
<dd><p>S.capitalize() -&gt; string</p>
<p>Return a copy of the string S with only its first character
capitalized.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.center">
<!--#paver.path.path.center#--><tt class="descname">center</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.center" title="Permalink to this definition">¶</a></dt>
<dd><p>S.center(width[, fillchar]) -&gt; string</p>
<p>Return S centered in a string of length width. Padding is
done using the specified fill character (default is a space)</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.chdir">
<!--#paver.path.path.chdir#--><tt class="descname">chdir</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.chdir" title="Permalink to this definition">¶</a></dt>
<dd>Change current directory.</dd></dl>

<dl class="method">
<dt id="paver.path.path.count">
<!--#paver.path.path.count#--><tt class="descname">count</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.count" title="Permalink to this definition">¶</a></dt>
<dd><p>S.count(sub[, start[, end]]) -&gt; int</p>
<p>Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are interpreted
as in slice notation.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.ctime">
<!--#paver.path.path.ctime#--><tt class="descname">ctime</tt><a class="headerlink" href="#paver.path.path.ctime" title="Permalink to this definition">¶</a></dt>
<dd>Creation time of the file.</dd></dl>

<dl class="method">
<dt id="paver.path.path.decode">
<!--#paver.path.path.decode#--><tt class="descname">decode</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>S.decode([encoding[,errors]]) -&gt; object</p>
<p>Decodes S using the codec registered for encoding. encoding defaults
to the default encoding. errors may be given to set a different error
handling scheme. Default is &#8216;strict&#8217; meaning that encoding errors raise
a UnicodeDecodeError. Other possible values are &#8216;ignore&#8217; and &#8216;replace&#8217;
as well as any other name registerd with codecs.register_error that is
able to handle UnicodeDecodeErrors.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.dirs">
<!--#paver.path.path.dirs#--><tt class="descname">dirs</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.path.path.dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>D.dirs() -&gt; List of this directory&#8217;s subdirectories.</p>
<p>The elements of the list are path objects.
This does not walk recursively into subdirectories
(but see path.walkdirs).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
directories whose names match the given pattern.  For
example, d.dirs(&#8216;build-<a href="#id3" name="id4"><span class="problematic" id="id4">*</span></a>&#8216;).</p>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: <a name="id3">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 99); <em><a href="#id4">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.drive">
<!--#paver.path.path.drive#--><tt class="descname">drive</tt><a class="headerlink" href="#paver.path.path.drive" title="Permalink to this definition">¶</a></dt>
<dd>The drive specifier, for example &#8216;C:&#8217;.
This is always empty on systems that don&#8217;t use drive specifiers.</dd></dl>

<dl class="method">
<dt id="paver.path.path.encode">
<!--#paver.path.path.encode#--><tt class="descname">encode</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>S.encode([encoding[,errors]]) -&gt; object</p>
<p>Encodes S using the codec registered for encoding. encoding defaults
to the default encoding. errors may be given to set a different error
handling scheme. Default is &#8216;strict&#8217; meaning that encoding errors raise
a UnicodeEncodeError. Other possible values are &#8216;ignore&#8217;, &#8216;replace&#8217; and
&#8216;xmlcharrefreplace&#8217; as well as any other name registered with
codecs.register_error that is able to handle UnicodeEncodeErrors.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.endswith">
<!--#paver.path.path.endswith#--><tt class="descname">endswith</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.endswith" title="Permalink to this definition">¶</a></dt>
<dd><p>S.endswith(suffix[, start[, end]]) -&gt; bool</p>
<p>Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.expand">
<!--#paver.path.path.expand#--><tt class="descname">expand</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up a filename by calling expandvars(),
expanduser(), and normpath() on it.</p>
<p>This is commonly everything needed to clean up a filename
read from a configuration file, for example.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.expandtabs">
<!--#paver.path.path.expandtabs#--><tt class="descname">expandtabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.expandtabs" title="Permalink to this definition">¶</a></dt>
<dd><p>S.expandtabs([tabsize]) -&gt; string</p>
<p>Return a copy of S where all tab characters are expanded using spaces.
If tabsize is not given, a tab size of 8 characters is assumed.</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.ext">
<!--#paver.path.path.ext#--><tt class="descname">ext</tt><a class="headerlink" href="#paver.path.path.ext" title="Permalink to this definition">¶</a></dt>
<dd>The file extension, for example &#8216;.py&#8217;.</dd></dl>

<dl class="method">
<dt id="paver.path.path.files">
<!--#paver.path.path.files#--><tt class="descname">files</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.path.path.files" title="Permalink to this definition">¶</a></dt>
<dd><p>D.files() -&gt; List of the files in this directory.</p>
<p>The elements of the list are path objects.
This does not walk into subdirectories (see path.walkfiles).</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists files
whose names match the given pattern.  For example,
d.files(&#8216;<a href="#id5" name="id6"><span class="problematic" id="id6">*</span></a>.pyc&#8217;).</p>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: <a name="id5">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 154); <em><a href="#id6">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.find">
<!--#paver.path.path.find#--><tt class="descname">find</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.find" title="Permalink to this definition">¶</a></dt>
<dd><p>S.find(sub [,start [,end]]) -&gt; int</p>
<p>Return the lowest index in S where substring sub is found,
such that sub is contained within s[start,end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.fnmatch">
<!--#paver.path.path.fnmatch#--><tt class="descname">fnmatch</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.path.path.fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if self.name matches the given pattern.</p>
<dl class="docutils">
<dt>pattern - A filename pattern with wildcards,</dt>
<dd><p class="first">for example &#8216;<a href="#id7" name="id8"><span class="problematic" id="id8">*</span></a>.py&#8217;.</p>
<div class="last system-message" id="id7">
<p class="system-message-title">System Message: <a name="id7">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 173); <em><a href="#id8">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.get_owner">
<!--#paver.path.path.get_owner#--><tt class="descname">get_owner</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the owner of this file or directory.</p>
<p>This follows symbolic links.</p>
<p>On Windows, this returns a name of the form ur&#8217;DOMAINUser Name&#8217;.
On Windows, a group can own a file or directory.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.getcwd">
<!--#paver.path.path.getcwd#--><tt class="descname">getcwd</tt><big>(</big><em>cls</em><big>)</big><a class="headerlink" href="#paver.path.path.getcwd" title="Permalink to this definition">¶</a></dt>
<dd>Return the current working directory as a path object.</dd></dl>

<dl class="method">
<dt id="paver.path.path.glob">
<!--#paver.path.path.glob#--><tt class="descname">glob</tt><big>(</big><em>pattern</em><big>)</big><a class="headerlink" href="#paver.path.path.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of path objects that match the pattern.</p>
<p>pattern - a path relative to this directory, with wildcards.</p>
<p>For example, path(&#8216;/users&#8217;).glob(&#8216;<em>/bin/</em>&#8216;) returns a list
of all the files users have in their bin directories.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.index">
<!--#paver.path.path.index#--><tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.index" title="Permalink to this definition">¶</a></dt>
<dd><p>S.index(sub [,start [,end]]) -&gt; int</p>
<p>Like S.find() but raise ValueError when the substring is not found.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.isalnum">
<!--#paver.path.path.isalnum#--><tt class="descname">isalnum</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.isalnum" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isalnum() -&gt; bool</p>
<p>Return True if all characters in S are alphanumeric
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.isalpha">
<!--#paver.path.path.isalpha#--><tt class="descname">isalpha</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.isalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isalpha() -&gt; bool</p>
<p>Return True if all characters in S are alphabetic
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.isdigit">
<!--#paver.path.path.isdigit#--><tt class="descname">isdigit</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.isdigit" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isdigit() -&gt; bool</p>
<p>Return True if all characters in S are digits
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.islower">
<!--#paver.path.path.islower#--><tt class="descname">islower</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.islower" title="Permalink to this definition">¶</a></dt>
<dd><p>S.islower() -&gt; bool</p>
<p>Return True if all cased characters in S are lowercase and there is
at least one cased character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.isspace">
<!--#paver.path.path.isspace#--><tt class="descname">isspace</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.isspace" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isspace() -&gt; bool</p>
<p>Return True if all characters in S are whitespace
and there is at least one character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.istitle">
<!--#paver.path.path.istitle#--><tt class="descname">istitle</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.istitle" title="Permalink to this definition">¶</a></dt>
<dd><p>S.istitle() -&gt; bool</p>
<p>Return True if S is a titlecased string and there is at least one
character in S, i.e. uppercase characters may only follow uncased
characters and lowercase characters only cased ones. Return False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.isupper">
<!--#paver.path.path.isupper#--><tt class="descname">isupper</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.isupper" title="Permalink to this definition">¶</a></dt>
<dd><p>S.isupper() -&gt; bool</p>
<p>Return True if all cased characters in S are uppercase and there is
at least one cased character in S, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.join">
<!--#paver.path.path.join#--><tt class="descname">join</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.join" title="Permalink to this definition">¶</a></dt>
<dd><p>S.join(sequence) -&gt; string</p>
<p>Return a string which is the concatenation of the strings in the
sequence.  The separator between elements is S.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.joinpath">
<!--#paver.path.path.joinpath#--><tt class="descname">joinpath</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#paver.path.path.joinpath" title="Permalink to this definition">¶</a></dt>
<dd>Join two or more path components, adding a separator
character (os.sep) if needed.  Returns a new path
object.</dd></dl>

<dl class="method">
<dt id="paver.path.path.lines">
<!--#paver.path.path.lines#--><tt class="descname">lines</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em>, <em>retain=True</em><big>)</big><a class="headerlink" href="#paver.path.path.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read all lines, return them in a list.</p>
<dl class="docutils">
<dt>Optional arguments:</dt>
<dd><dl class="first last docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  The default is None, meaning the content
of the file is read as 8-bit characters and returned
as a list of (non-Unicode) str objects.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;</dd>
<dt>retain - If true, retain newline characters; but all newline</dt>
<dd>character combinations (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;) are
translated to &#8216;n&#8217;.  If false, newline characters are
stripped off.  Default is True.</dd>
</dl>
</dd>
</dl>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.link">
<!--#paver.path.path.link#--><tt class="descname">link</tt><big>(</big><em>newpath</em><big>)</big><a class="headerlink" href="#paver.path.path.link" title="Permalink to this definition">¶</a></dt>
<dd>Create a hard link at &#8216;newpath&#8217;, pointing to this file.</dd></dl>

<dl class="method">
<dt id="paver.path.path.listdir">
<!--#paver.path.path.listdir#--><tt class="descname">listdir</tt><big>(</big><em>pattern=None</em><big>)</big><a class="headerlink" href="#paver.path.path.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>D.listdir() -&gt; List of items in this directory.</p>
<p>Use D.files() or D.dirs() instead if you want a listing
of just files or just subdirectories.</p>
<p>The elements of the list are path objects.</p>
<p>With the optional &#8216;pattern&#8217; argument, this only lists
items whose names match the given pattern.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.ljust">
<!--#paver.path.path.ljust#--><tt class="descname">ljust</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.ljust" title="Permalink to this definition">¶</a></dt>
<dd><p>S.ljust(width[, fillchar]) -&gt; string</p>
<p>Return S left justified in a string of length width. Padding is
done using the specified fill character (default is a space).</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.lower">
<!--#paver.path.path.lower#--><tt class="descname">lower</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>S.lower() -&gt; string</p>
<p>Return a copy of the string S converted to lowercase.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.lstat">
<!--#paver.path.path.lstat#--><tt class="descname">lstat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.lstat" title="Permalink to this definition">¶</a></dt>
<dd>Like path.stat(), but do not follow symbolic links.</dd></dl>

<dl class="method">
<dt id="paver.path.path.lstrip">
<!--#paver.path.path.lstrip#--><tt class="descname">lstrip</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.lstrip([chars]) -&gt; string or unicode</p>
<p>Return a copy of the string S with leading whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is unicode, S will be converted to unicode before stripping</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.mtime">
<!--#paver.path.path.mtime#--><tt class="descname">mtime</tt><a class="headerlink" href="#paver.path.path.mtime" title="Permalink to this definition">¶</a></dt>
<dd>Last-modified time of the file.</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.name">
<!--#paver.path.path.name#--><tt class="descname">name</tt><a class="headerlink" href="#paver.path.path.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of this file or directory without the full path.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).name == &#8216;libpython.so&#8217;</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.namebase">
<!--#paver.path.path.namebase#--><tt class="descname">namebase</tt><a class="headerlink" href="#paver.path.path.namebase" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as path.name, but with one file extension stripped off.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).name     == &#8216;python.tar.gz&#8217;,
but          path(&#8216;/home/guido/python.tar.gz&#8217;).namebase == &#8216;python.tar&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.open">
<!--#paver.path.path.open#--><tt class="descname">open</tt><big>(</big><em>mode='r'</em><big>)</big><a class="headerlink" href="#paver.path.path.open" title="Permalink to this definition">¶</a></dt>
<dd>Open this file.  Return a file object.</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.owner">
<!--#paver.path.path.owner#--><tt class="descname">owner</tt><a class="headerlink" href="#paver.path.path.owner" title="Permalink to this definition">¶</a></dt>
<dd>Name of the owner of this file or directory.</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.parent">
<!--#paver.path.path.parent#--><tt class="descname">parent</tt><a class="headerlink" href="#paver.path.path.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>This path&#8217;s parent directory, as a new path object.</p>
<p>For example, path(&#8216;/usr/local/lib/libpython.so&#8217;).parent == path(&#8216;/usr/local/lib&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.partition">
<!--#paver.path.path.partition#--><tt class="descname">partition</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>S.partition(sep) -&gt; (head, sep, tail)</p>
<p>Searches for the separator sep in S, and returns the part before it,
the separator itself, and the part after it.  If the separator is not
found, returns S and two empty strings.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.read_md5">
<!--#paver.path.path.read_md5#--><tt class="descname">read_md5</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.read_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the md5 hash for this file.</p>
<p>This reads through the entire file.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.readlink">
<!--#paver.path.path.readlink#--><tt class="descname">readlink</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result may be an absolute or a relative path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.readlinkabs">
<!--#paver.path.path.readlinkabs#--><tt class="descname">readlinkabs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.readlinkabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to which this symbolic link points.</p>
<p>The result is always an absolute path.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.relpath">
<!--#paver.path.path.relpath#--><tt class="descname">relpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.relpath" title="Permalink to this definition">¶</a></dt>
<dd>Return this path as a relative path,
based from the current working directory.</dd></dl>

<dl class="method">
<dt id="paver.path.path.relpathto">
<!--#paver.path.path.relpathto#--><tt class="descname">relpathto</tt><big>(</big><em>dest</em><big>)</big><a class="headerlink" href="#paver.path.path.relpathto" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a relative path from self to dest.</p>
<p>If there is no relative path from self to dest, for example if
they reside on different drives in Windows, then this returns
dest.abspath().</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.replace">
<!--#paver.path.path.replace#--><tt class="descname">replace</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>S.replace (old, new[, count]) -&gt; string</p>
<p>Return a copy of string S with all occurrences of substring
old replaced by new.  If the optional argument count is
given, only the first count occurrences are replaced.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rfind">
<!--#paver.path.path.rfind#--><tt class="descname">rfind</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rfind(sub [,start [,end]]) -&gt; int</p>
<p>Return the highest index in S where substring sub is found,
such that sub is contained within s[start,end].  Optional
arguments start and end are interpreted as in slice notation.</p>
<p>Return -1 on failure.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rindex">
<!--#paver.path.path.rindex#--><tt class="descname">rindex</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rindex(sub [,start [,end]]) -&gt; int</p>
<p>Like S.rfind() but raise ValueError when the substring is not found.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rjust">
<!--#paver.path.path.rjust#--><tt class="descname">rjust</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rjust" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rjust(width[, fillchar]) -&gt; string</p>
<p>Return S right justified in a string of length width. Padding is
done using the specified fill character (default is a space)</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rpartition">
<!--#paver.path.path.rpartition#--><tt class="descname">rpartition</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rpartition(sep) -&gt; (tail, sep, head)</p>
<p>Searches for the separator sep in S, starting at the end of S, and returns
the part before it, the separator itself, and the part after it.  If the
separator is not found, returns two empty strings and S.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rsplit">
<!--#paver.path.path.rsplit#--><tt class="descname">rsplit</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rsplit([sep [,maxsplit]]) -&gt; list of strings</p>
<p>Return a list of the words in the string S, using sep as the
delimiter string, starting at the end of the string and working
to the front.  If maxsplit is given, at most maxsplit splits are
done. If sep is not specified or is None, any whitespace string
is a separator.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.rstrip">
<!--#paver.path.path.rstrip#--><tt class="descname">rstrip</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.rstrip([chars]) -&gt; string or unicode</p>
<p>Return a copy of the string S with trailing whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is unicode, S will be converted to unicode before stripping</p>
</dd></dl>

<dl class="attribute">
<dt id="paver.path.path.size">
<!--#paver.path.path.size#--><tt class="descname">size</tt><a class="headerlink" href="#paver.path.path.size" title="Permalink to this definition">¶</a></dt>
<dd>Size of the file, in bytes.</dd></dl>

<dl class="method">
<dt id="paver.path.path.split">
<!--#paver.path.path.split#--><tt class="descname">split</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.split" title="Permalink to this definition">¶</a></dt>
<dd><p>S.split([sep [,maxsplit]]) -&gt; list of strings</p>
<p>Return a list of the words in the string S, using sep as the
delimiter string.  If maxsplit is given, at most maxsplit
splits are done. If sep is not specified or is None, any
whitespace string is a separator.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.splitall">
<!--#paver.path.path.splitall#--><tt class="descname">splitall</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.splitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the path components in this path.</p>
<p>The first item in the list will be a path.  Its value will be
either os.curdir, os.pardir, empty, or the root directory of
this path (for example, &#8216;/&#8217; or &#8216;C:\&#8217;).  The other items in
the list will be strings.</p>
<p>path.path.joinpath(<a href="#id9" name="id10"><span class="problematic" id="id10">*</span></a>result) will yield the original path.</p>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: <a name="id9">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 475); <em><a href="#id10">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.splitdrive">
<!--#paver.path.path.splitdrive#--><tt class="descname">splitdrive</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.splitdrive" title="Permalink to this definition">¶</a></dt>
<dd><p>p.splitdrive() -&gt; Return (p.drive, &lt;the rest of p&gt;).</p>
<p>Split the drive specifier from this path.  If there is
no drive specifier, p.drive is empty, so the return value
is simply (path(&#8216;&#8217;), p).  This is always the case on Unix.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.splitext">
<!--#paver.path.path.splitext#--><tt class="descname">splitext</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.splitext" title="Permalink to this definition">¶</a></dt>
<dd><p>p.splitext() -&gt; Return (p.stripext(), p.ext).</p>
<p>Split the filename extension from this path and return
the two parts.  Either part may be empty.</p>
<p>The extension is everything from &#8216;.&#8217; to the end of the
last path segment.  This has the property that if
(a, b) == p.splitext(), then a + b == p.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.splitlines">
<!--#paver.path.path.splitlines#--><tt class="descname">splitlines</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.splitlines" title="Permalink to this definition">¶</a></dt>
<dd><p>S.splitlines([keepends]) -&gt; list of strings</p>
<p>Return a list of the lines in S, breaking at line boundaries.
Line breaks are not included in the resulting list unless keepends
is given and true.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.splitpath">
<!--#paver.path.path.splitpath#--><tt class="descname">splitpath</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.splitpath" title="Permalink to this definition">¶</a></dt>
<dd>p.splitpath() -&gt; Return (p.parent, p.name).</dd></dl>

<dl class="method">
<dt id="paver.path.path.startswith">
<!--#paver.path.path.startswith#--><tt class="descname">startswith</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>S.startswith(prefix[, start[, end]]) -&gt; bool</p>
<p>Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.stat">
<!--#paver.path.path.stat#--><tt class="descname">stat</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.stat" title="Permalink to this definition">¶</a></dt>
<dd>Perform a stat() system call on this path.</dd></dl>

<dl class="method">
<dt id="paver.path.path.statvfs">
<!--#paver.path.path.statvfs#--><tt class="descname">statvfs</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.statvfs" title="Permalink to this definition">¶</a></dt>
<dd>Perform a statvfs() system call on this path.</dd></dl>

<dl class="method">
<dt id="paver.path.path.strip">
<!--#paver.path.path.strip#--><tt class="descname">strip</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>S.strip([chars]) -&gt; string or unicode</p>
<p>Return a copy of the string S with leading and trailing
whitespace removed.
If chars is given and not None, remove characters in chars instead.
If chars is unicode, S will be converted to unicode before stripping</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.stripext">
<!--#paver.path.path.stripext#--><tt class="descname">stripext</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.stripext" title="Permalink to this definition">¶</a></dt>
<dd><p>p.stripext() -&gt; Remove one file extension from the path.</p>
<p>For example, path(&#8216;/home/guido/python.tar.gz&#8217;).stripext()
returns path(&#8216;/home/guido/python.tar&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.swapcase">
<!--#paver.path.path.swapcase#--><tt class="descname">swapcase</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.swapcase" title="Permalink to this definition">¶</a></dt>
<dd><p>S.swapcase() -&gt; string</p>
<p>Return a copy of the string S with uppercase characters
converted to lowercase and vice versa.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.symlink">
<!--#paver.path.path.symlink#--><tt class="descname">symlink</tt><big>(</big><em>newlink</em><big>)</big><a class="headerlink" href="#paver.path.path.symlink" title="Permalink to this definition">¶</a></dt>
<dd>Create a symbolic link at &#8216;newlink&#8217;, pointing here.</dd></dl>

<dl class="method">
<dt id="paver.path.path.text">
<!--#paver.path.path.text#--><tt class="descname">text</tt><big>(</big><em>encoding=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.path.path.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file, read it in, return the content as a string.</p>
<p>This uses &#8216;U&#8217; mode in Python 2.3 and later, so &#8216;rn&#8217; and &#8216;r&#8217;
are automatically translated to &#8216;n&#8217;.</p>
<p>Optional arguments:</p>
<dl class="docutils">
<dt>encoding - The Unicode encoding (or character set) of</dt>
<dd>the file.  If present, the content of the file is
decoded and returned as a unicode object; otherwise
it is returned as an 8-bit str.</dd>
<dt>errors - How to handle Unicode errors; see help(str.decode)</dt>
<dd>for the options.  Default is &#8216;strict&#8217;.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.title">
<!--#paver.path.path.title#--><tt class="descname">title</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.title" title="Permalink to this definition">¶</a></dt>
<dd><p>S.title() -&gt; string</p>
<p>Return a titlecased version of S, i.e. words start with uppercase
characters, all remaining cased characters have lowercase.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.touch">
<!--#paver.path.path.touch#--><tt class="descname">touch</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.touch" title="Permalink to this definition">¶</a></dt>
<dd>Set the access/modified times of this file to the current time.
Create the file if it does not exist.</dd></dl>

<dl class="method">
<dt id="paver.path.path.translate">
<!--#paver.path.path.translate#--><tt class="descname">translate</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>S.translate(table [,deletechars]) -&gt; string</p>
<p>Return a copy of the string S, where all characters occurring
in the optional argument deletechars are removed, and the
remaining characters have been mapped through the given
translation table, which must be a string of length 256.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.upper">
<!--#paver.path.path.upper#--><tt class="descname">upper</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>S.upper() -&gt; string</p>
<p>Return a copy of the string S converted to uppercase.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.utime">
<!--#paver.path.path.utime#--><tt class="descname">utime</tt><big>(</big><em>times</em><big>)</big><a class="headerlink" href="#paver.path.path.utime" title="Permalink to this definition">¶</a></dt>
<dd>Set the access and modified times of this file.</dd></dl>

<dl class="method">
<dt id="paver.path.path.walk">
<!--#paver.path.path.walk#--><tt class="descname">walk</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.path.path.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walk() -&gt; iterator over files and subdirs, recursively.</p>
<p>The iterator yields path objects naming each child item of
this directory and its descendants.  This requires that
D.isdir().</p>
<p>This performs a depth-first traversal of the directory tree.
Each directory is returned just before all its children.</p>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.walkdirs">
<!--#paver.path.path.walkdirs#--><tt class="descname">walkdirs</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.path.path.walkdirs" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walkdirs() -&gt; iterator over subdirs, recursively.</p>
<p>With the optional &#8216;pattern&#8217; argument, this yields only
directories whose names match the given pattern.  For
example, mydir.walkdirs(&#8216;<a href="#id11" name="id12"><span class="problematic" id="id12">*</span></a>test&#8217;) yields only directories
with names ending in &#8216;test&#8217;.</p>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: <a name="id11">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 619); <em><a href="#id12">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<p>The errors= keyword argument controls behavior when an
error occurs.  The default is &#8216;strict&#8217;, which causes an
exception.  The other allowed values are &#8216;warn&#8217;, which
reports the error via warnings.warn(), and &#8216;ignore&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.walkfiles">
<!--#paver.path.path.walkfiles#--><tt class="descname">walkfiles</tt><big>(</big><em>pattern=None</em>, <em>errors='strict'</em><big>)</big><a class="headerlink" href="#paver.path.path.walkfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>D.walkfiles() -&gt; iterator over files in D, recursively.</p>
<p>The optional argument, pattern, limits the results to files
with names that match the pattern.  For example,
mydir.walkfiles(&#8216;<a href="#id13" name="id14"><span class="problematic" id="id14">*</span></a>.tmp&#8217;) yields only files with the .tmp
extension.</p>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: <a name="id13">WARNING/2</a> (<tt class="docutils">/Users/admin/projects/paver/docs/source/files.rst</tt>, line 633); <em><a href="#id14">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.write_bytes">
<!--#paver.path.path.write_bytes#--><tt class="descname">write_bytes</tt><big>(</big><em>bytes</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.path.path.write_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Open this file and write the given bytes to it.</p>
<p>Default behavior is to overwrite any existing file.
Call p.write_bytes(bytes, append=True) to append instead.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.write_lines">
<!--#paver.path.path.write_lines#--><tt class="descname">write_lines</tt><big>(</big><em>lines</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.path.path.write_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given lines of text to this file.</p>
<p>By default this overwrites any existing file at this path.</p>
<p>This puts a platform-specific newline sequence on every line.
See &#8216;linesep&#8217; below.</p>
<p>lines - A list of strings.</p>
<dl class="docutils">
<dt>encoding - A Unicode encoding to use.  This applies only if</dt>
<dd>&#8216;lines&#8217; contains any Unicode strings.</dd>
<dt>errors - How to handle errors in Unicode encoding.  This</dt>
<dd>also applies only to Unicode strings.</dd>
<dt>linesep - The desired line-ending.  This line-ending is</dt>
<dd>applied to every line.  If a line already has any
standard line ending (&#8216;r&#8217;, &#8216;n&#8217;, &#8216;rn&#8217;, u&#8217;x85&#8217;,
u&#8217;rx85&#8217;, u&#8217;u2028&#8217;), that will be stripped off and
this will be used instead.  The default is os.linesep,
which is platform-dependent (&#8216;rn&#8217; on Windows, &#8216;n&#8217; on
Unix, etc.)  Specify None to write the lines as-is,
like file.writelines().</dd>
</dl>
<p>Use the keyword argument append=True to append lines to the
file.  The default is to overwrite the file.  Warning:
When you use this with Unicode data, if the encoding of the
existing data in the file is different from the encoding
you specify with the encoding= parameter, the result is
mixed-encoding data, which can really confuse someone trying
to read the file later.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.write_text">
<!--#paver.path.path.write_text#--><tt class="descname">write_text</tt><big>(</big><em>text</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>linesep='n'</em>, <em>append=False</em><big>)</big><a class="headerlink" href="#paver.path.path.write_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given text to this file.</p>
<p>The default behavior is to overwrite any existing file;
to append instead, use the &#8216;append=True&#8217; keyword argument.</p>
<p>There are two differences between path.write_text() and
path.write_bytes(): newline handling and Unicode handling.
See below.</p>
<p>Parameters:</p>
<blockquote>
<ul class="simple">
<li>text - str/unicode - The text to be written.</li>
<li>encoding - str - The Unicode encoding that will be used.
This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode string.</li>
<li>errors - str - How to handle Unicode encoding errors.
Default is &#8216;strict&#8217;.  See help(unicode.encode) for the
options.  This is ignored if &#8216;text&#8217; isn&#8217;t a Unicode
string.</li>
<li>linesep - keyword argument - str/unicode - The sequence of
characters to be used to mark end-of-line.  The default is
os.linesep.  You can also specify None; this means to
leave all newlines as they are in &#8216;text&#8217;.</li>
<li>append - keyword argument - bool - Specifies what to do if
the file already exists (True: append to the end of it;
False: overwrite it.)  The default is False.</li>
</ul>
</blockquote>
<p>&#8212; Newline handling.</p>
<p>write_text() converts all standard end-of-line sequences
(&#8216;n&#8217;, &#8216;r&#8217;, and &#8216;rn&#8217;) to your platform&#8217;s default end-of-line
sequence (see os.linesep; on Windows, for example, the
end-of-line marker is &#8216;rn&#8217;).</p>
<p>If you don&#8217;t like your platform&#8217;s default, you can override it
using the &#8216;linesep=&#8217; keyword argument.  If you specifically want
write_text() to preserve the newlines as-is, use &#8216;linesep=None&#8217;.</p>
<p>This applies to Unicode text the same as to 8-bit text, except
there are three additional standard Unicode end-of-line sequences:
u&#8217;x85&#8217;, u&#8217;rx85&#8217;, and u&#8217;u2028&#8217;.</p>
<p>(This is slightly different from when you open a file for
writing with fopen(filename, &#8220;w&#8221;) in C or file(filename, &#8216;w&#8217;)
in Python.)</p>
<p>&#8212; Unicode</p>
<p>If &#8216;text&#8217; isn&#8217;t Unicode, then apart from newline handling, the
bytes are written verbatim to the file.  The &#8216;encoding&#8217; and
&#8216;errors&#8217; arguments are not used and must be omitted.</p>
<p>If &#8216;text&#8217; is Unicode, it is first converted to bytes using the
specified &#8216;encoding&#8217; (or the default encoding if &#8216;encoding&#8217;
isn&#8217;t specified).  The &#8216;errors&#8217; argument applies only to this
conversion.</p>
</dd></dl>

<dl class="method">
<dt id="paver.path.path.zfill">
<!--#paver.path.path.zfill#--><tt class="descname">zfill</tt><big>(</big><big>)</big><a class="headerlink" href="#paver.path.path.zfill" title="Permalink to this definition">¶</a></dt>
<dd><p>S.zfill(width) -&gt; string</p>
<p>Pad a numeric string S with zeros on the left, to fill a field
of the specified width.  The string S is never truncated.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sidebar">
        <div class="sidebarwrapper">
          
            <h4>Previous topic</h4>
            <p class="topless"><a href="setuptools.html" title="previous chapter">distutils and setuptools</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="sphinx.html" title="next chapter">Sphinx</a></p>
          
            <h3>This Page</h3>
            <ul class="this-page-menu">
            
              <li><a href="_sources/files.txt">Show Source</a></li>
            
            </ul>
          
          
          
            <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18"> <input type="submit" value="Go">
              <input type="hidden" name="check_keywords" value="yes">
              <input type="hidden" name="area" value="default">
            </form>
            
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px"><a href="genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right"><a href="modindex.html" title="Global Module Index" accesskey="M">modules</a> |</li>
          <li class="right"><a href="sphinx.html" title="Sphinx" accesskey="N">next</a> |</li>
          <li class="right"><a href="setuptools.html" title="distutils and setuptools" accesskey="P">previous</a> |</li>
        <li><a href="index.html">Paver v0.4 documentation</a> &raquo;</li>
          <li><a href="paverstdlib.html" accesskey="U">The Paver Standard Library</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, SitePen, Inc..
      Last updated on Apr 22, 2008.
    </div>
  </body>
</html>