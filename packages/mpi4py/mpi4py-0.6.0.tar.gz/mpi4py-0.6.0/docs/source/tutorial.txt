Tutorial (dated)
================


Invoking the interpreter
------------------------

In the following examples, we assume that a parallelized version of
the Python interpreter was launched using the implementation-provided
MPI startup mechanism. With the MPICH distribution on a cluster of
five PC's running GNU/Linux and listed in file ``nodes.dat``, this can
be accomplished by typing::

       $ mpirun -np 5 -machinefile nodes.dat <prefix>/bin/bwpython -i

from a command-line shell environment like bash. After that, the
``MPI`` module can be imported by typing::

       >>> from mpi4py import MPI


Hello World!
------------

By typing the following sentences in the Python prompt, output from
all processes should be obtained.

>>> rank, size = MPI.COMM_WORLD.rank, MPI.COMM_WORLD.size
>>> print 'Hello World! I am process', rank, 'of', size
Hello World! I am process 0 of 5
Hello World! I am process 4 of 5
Hello World! I am process 2 of 5
Hello World! I am process 1 of 5
Hello World! I am process 3 of 5


Point-to-Point communications
-----------------------------

First, we prepare some different data in each process.

>>> rank, size = MPI.COMM_WORLD.rank, MPI.COMM_WORLD.size
>>> sendbuf = 10 * size + rank
>>> print '[%d]' % rank, sendbuf
[0] 50
[4] 54
[2] 52
[1] 51
[3] 53

Next, we can try some point-to-point communications.

* using standard form ...

>>> MPI.COMM_WORLD.Send(sendbuf, dest=0, tag=7)
>>> recvbuf = []
>>> if MPI.COMM_WORLD.rank == 0:
...     for i in xrange(MPI.COMM_WORLD.size):
...         data = MPI.COMM_WORLD.Recv(source=i, tag=7)
...         recvbuf.append(data)
...
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, recvbuf)
[0] [50, 51, 52, 53, 54]
[4] []
[2] []
[1] []
[3] []

* using ports ...

>>> MPI.COMM_WORLD[0].Send(sendbuf) # get port 0, send with default tag
>>> recvbuf = []
>>> if MPI.COMM_WORLD.rank == 0:
...     for p in MPI.COMM_WORLD:         # iterate over comm
...         recvbuf += [ p.Recv() ] # recv with default tag
...
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, recvbuf)
[0] [50, 51, 52, 53, 54]
[4] []
[2] []
[1] []
[3] []

* using ports with stream syntax ...

>>> MPI.COMM_WORLD[0] << [ sendbuf ] # input stream must be list !!!
>>>
>>> recvbuf = [] # output stream must be list, too !!!
>>> if MPI.COMM_WORLD.rank == 0:
...     for p in MPI.COMM_WORLD:
...         p >> recvbuf
...
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, recvbuf)
[0] [50, 51, 52, 53, 54]
[4] []
[2] []
[1] []
[3] []


Collective communications
-------------------------

* broadcast using standard form ...

>>> sendbuf = MPI.COMM_WORLD.rank**2 # square of process rank
>>>
>>> root = MPI.COMM_WORLD.size-1 # last process
>>> recvbuf = MPI.COMM_WORLD.Bcast(sendbuf, root)
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, recvbuf)
[0] 16
[1] 16
[2] 16
[3] 16
[4] 16

* gather using ports ...

>>> rank, size = MPI.COMM_WORLD.rank, MPI.COMM_WORLD.size
>>> sendbuf = [ rank**2 , rank%2!=0 ]
>>> print '[%d] %s' % (rank, sendbuf)
[0] [0, False]
[1] [1, True]
[2] [4, False]
[3] [9, True]
[4] [16, False]
>>>
>>> root = size//2 # middle process
>>> recvbuf = MPI.COMM_WORLD[root].Gather(sendbuf)
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, recvbuf)
[0] None
[1] None
[2] [[0, False], [1, True], [4, False], [9, True], [16, False]]
[3] None
[4] None

* scatter using ports ...

>>> rank, size = MPI.COMM_WORLD.rank, MPI.COMM_WORLD.size
>>> root = size//2 # middle process
>>>
>>> sendbuf = None
>>> if rank = root: # set data in root
...     sendbuf = [ (i, i**2, i**3) for i in range(size) ]
>>> print '[%d] %s' % (rank, sendbuf)
[0] None
[1] None
[2] [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]
[3] None
[4] None
>>>
>>> p = MPI.COMM_WORLD[root]
>>> recvbuf = p.Scatter(sendbuf)
>>> print '[%d] %s' % (rank, recvbuf)
[0] (0, 0, 0)
[1] (1, 1, 1)
[2] (2, 4, 8)
[3] (3, 9, 27)
[4] (4, 16, 64)


Communicators
--------------

* duplication and comparison ...

>>> MPI.rprint([MPI.IDENT, MPI.CONGRUENT, MPI.SIMILAR, MPI.UNEQUAL])
[1, 2, 3, 4]
>>>
>>> comm = MPI.COMM_WORLD.Dup();
>>> rslt = MPI.Comm.Compare(comm, MPI.COMM_WORLD)
>>> congruent = (rslt==MPI.CONGRUENT)
>>> print '[%d] congruent: %s' % (MPI.COMM_WORLD.rank, congruent)
[0] congruent: True
[1] congruent: True
[2] congruent: True
[3] congruent: True
[4] congruent: True
>>>
>>> flag = ( comm == MPI.COMM_WORLD )
>>> print '[%d] %s' % (MPI.COMM_WORLD.rank, flag)
[0] True
[1] True
[2] True
[3] True
[4] True



* splitting ...

>>> rank, size = MPI.COMM_WORLD.rank, MPI.COMM_WORLD.size
>>> color = int(rank < size//2)
>>> key   = size-rank
>>> fmt = '[%d] color: %s - key: %s'
>>> print fmt % (MPI.COMM_WORLD.rank, color, key)
[0] color: 1 - key: 5
[1] color: 1 - key: 4
[2] color: 0 - key: 3
[3] color: 0 - key: 2
[4] color: 0 - key: 1
>>>
>>> comm = MPI.COMM_WORLD.Split(color, key)
>>> rk = comm.Get_rank()
>>> sz = comm.Get_size()
>>>
>>> fmt = '[%d] rank: %d - size: %d'
>>> pprint fmt % (rank, rk, sz)
[0] rank: 1 - size: 2
[1] rank: 0 - size: 2
[2] rank: 2 - size: 3
[3] rank: 1 - size: 3
[4] rank: 0 - size: 3

