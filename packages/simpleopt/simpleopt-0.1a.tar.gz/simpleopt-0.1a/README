simpleopt - a simple parser for options in command line
=======================================================

Usage Example
-------------

You just define a function, and optionally annotate the type of the
parameters, the same arguments will be parsed on the command line::

  @annotation(command=str, interval=float, differences=bool,
              args=str, kwargs=str)
  def watch(command, interval=2.0, differences=False, *args, **kwargs):
      print (command, interval, differences, args, kwargs)

  if __name__ == '__main__':
      SimpleOpt(watch).run()

Then you can call it like this, supposing you saved it on a file named
watch.py and made it executable::

  $ watch.py "df -h"
  ('df -h', 2.0, False, (), {})

  $ watch.py --interval 1.0 "df -h"
  ('df -h', 1.0, False, (), {})

  $ watch.py --noverbose --differences "df -h"
  ('df -h', 1.0, True, (), {})

  $ python simpleopt.py --foo bar --bar baz "df -h" quux quuux
  ('df -h', 2.0, False, ('quux', 'quuux'), {'foo': 'bar', 'bar': 'baz'})

Another example::

  @annotation(foo={str:int})
  def example(foo):
      return foo

  $ example.py --foo a:1,b:2,c:3
  {'a': 1, 'c': 3, 'b': 2}

  $ example.py a:1,b:2,c:3
  {'a': 1, 'c': 3, 'b': 2}


Working details
---------------

The command-line arguments are classified in one of two types: (i) option
arguments and (ii) positional arguments.

  (i) option arguments have the form --OPTION or --OPTION=VALUE where
      OPTION is the argument name and VALUE is an optional value given to
      that argument.

  (ii) positional arguments are those that are not option arguments.

The way that command-line arguments are assigned to the function's formal
parameters differ from the way that python assigns input arguments in python
code.

When a python script is run on the command line, the command-line arguments are
assigned to the function's formal parameters as follows:

  - For each formal parameter, there is a slot which will be used to contain
    the value of the argument assigned to that parameter.

  - Each slot is either 'empty' or 'filled'. Slots which had values assigned
    to them are 'filled', otherwise they are 'empty'.

  - Initially, all slots are marked 'empty'.

  - Option arguments are assigned first, followed by positional arguments.

  - For each option argument:

     o If there is a parameter with the same name as the option argument, then
       the argument value is assigned to that parameter slot. However, if the
       parameter is already filled, then that is an error.

     o Otherwise, if there is a 'keyword dictionary' argument, the argument is
       added to the dictionary using the keyword name as the dictionary key,
       unless there is already an entry with that key, in which case it is an
       error.

     o Otherwise, if there is no keyword dictionary, and no matching named
       parameter, then it is an error.

  - For each positional argument:

     o Attempt to bind the argument to the first unfilled parameter slot that
       has *no default value*. If the slot is not a vararg slot, then mark the
       slot as 'filled'.

     o Otherwise, if the next unfilled slot is a vararg slot then all remaining
       positional arguments are placed into the vararg slot.

  - Finally:

     o If the vararg slot is not yet filled, assign an empty tuple as its
       value.

     o If the keyword dictionary argument is not yet filled, assign an empty
       dicionary as its value.

     o For each remaining empty slot: if there is a default value for that
       slot, then fill the slot with the default value. If there is no default
       value, then it is an error.

When an error happens, a message is printed about the error.
