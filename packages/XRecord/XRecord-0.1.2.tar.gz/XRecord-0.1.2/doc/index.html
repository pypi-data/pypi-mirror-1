<html>

<head>
  <title>XRecord - An introspecting Python ORM</title>
</head>

<body>

<style>
div#contents {
   margin: auto;
   -moz-border-radius: 10px;
   width: 900px;
   padding: 14px;
   padding-left: 40px;
   padding-right: 40px;
   background: #fff;
   border: solid 1px #999;
   color: #400;
   text-align: justify;
}
body {
   font-family: sans;
   background: #eee;
}

a {
   color: #900;
}

h2 {
   color: #200;
}

#header {
   color: #003;
}

#header h1 {
  letter-spacing: 3px;
  font-size: 3.3em;
  padding: 0; 
  margin: 0;
}

#header h3 {
   padding: 0;
   padding-left: 20px;
   margin: 0;
}

#header div#download {
   float: right;
   background: #003;
   background-image: url(document-save.png);
   background-position: 95% center;
   background-repeat: no-repeat;
   color: #fff;
   -moz-border-radius: 10px;
   padding: 15px;
   padding-right: 80px;
   margin-top: 15px;
}

#download a {
   color: #ee0;
   font-weight: bold;
   text-decoration: none;
}

#download a:hover {
   text-decoration: underline;
}
</style>

<div id="contents">

<div id="header">
  <div id="download">
    <div class="link"><a href="https://sourceforge.net/projects/xrecord/files/">Download Latest</a></div>
    <small>version: 0.1.2</small>
  </div>
<h1>XRecord</h1>
<h3>An <u>Introspecting</u> Python ORM</h3>
</div>

<h2>Jump in!</h2>
<a href="api/index.html"><b>Read the API reference, and the tutorial!</b></a>

<h2>Introduction</h2>
<p>
XRecord is an <em>Object-Relational Mapper</em> - a library which provides an object interface to databases. Tables are represented
as classes, columns are attributes, and rows of data are class instances. If you used Python for developing database applications
you may have come across one or more of ORMs, like:
</p>
<ul>
   <li><a href="http://www.sqlobject.org/">SQLObject</a></li>
   <li><a href="http://www.sqlalchemy.org/">SQLAlchemy</a></li>
   <li><a href="http://autumn-orm.org/">Autumn</a></li>
   <li><a href="https://storm.canonical.com/">Storm</a></li>
   <li>many more...</li>
</ul>
<p>
XRecord is not meant to replace any of them, but rather - provide an alternative approach to Object-Relation mapping. XRecord also
tries to be a thin Database Abstraction Layer - make using an RDBMS quick and easy without hiding any of its powerful features.
</p>

<h2>Features</h2>
<ul>
  <li>full introspection, no model definition in Python required,</li>
  <li>automatic foreign key mapping, both in the referenced and referencing objects,</li>
  <li>automatic many-to-many relationship detection,</li>
  <li>optional foreign-key references caching,</li>
  <li>easily extend generated record classes to provide extra functionality for your objects,</li>
  <li>easily define FK and MTM relationships, that were left out in the database definition,</li> 
  <li>object-mapping of any SQL statement,</li>
  <li>may be used without writing a single line of SQL,</li>
  <li>multiple-column primary keys,</li>
  <li>database connection objects designed for long-running applications</li>
</ul>

<h2>Why another ORM?</h2>
<p>
It's seems that the "Python ORM market" is filled with some excellent solutions, all of which do what is expected of them really well.
However, while using most of them I found that they all share some design decisions, as result of which they don't exactly fit my needs.
</p>
<p>
Most of existing Python ORMs require you to actually write the classes onto which rows of data will be mapped. They require you to 
explicitly define the foreign keys in your classes (tables) and to describe the many-to-many relationships. Since all of this information
is already inside your RDBMS, I believe this to be in a little conflict with the DRY principle, of which I am a big fan. Some ORMs try to 
counter this problem by leaving the database (model) definition entirely in Python code, but this is just a superficial solution - even though
your model is defined in Python, your data is still stored in an external database and their structures do not always have to be in sync.  
</p>
<p>
Most existing Python ORMs are designed to hide all SQL from the programmer, but still allow complex queries to be performed through an 
abstraction layer put on top of low-level database API. This makes the code look clean, and RDBMS independent. It is common for applications
to be developed and tested with SQLite, and then switched to MySQL/PostgreSQL in production, which is both elegant and convenient.<br/>
However, this approach has some issues. All of the widely used RDBMS, are highly sophisticated, mature projects, with thousands of man-hours 
put into development, testing and optimization. Most of them introduce many handy improvements to the SQL standard (non standard types, alternative
syntax, etc), which may be lost when using a unified abstraction layer (which, btw, may be a source of new bugs).<br/>
So the price for the clean code, and platform independence, may be reduced functionality of your database system. When writing quick, small 
applications I often choose my RDBMS back-end based on one of its distinctive features, which will make my work faster, so I looked for 
an ORM which made using it easier, rather than more difficult.
</p>
<p>
Some may argue, that all of the aforementioned ORMs have built-in hacks (or even features :) ) to overcome all these problems. That's true, but it's just not the
way they were designed to be used - so by using these hacks, you no longer have clean, engine-independent code, but sometimes it's even 
uglier and less maintainable than the low-level API.
</p>


<h2>Common ORM features that were left out</h2>
<ul>
  <li>no object caching, no Store</li>
  <li>no way to customize SELECT queries without writing SQL</li>
  <li>no automatic database generation</li>
</ul>

<h2>Supported RDBMS</h2>
<ul>
  <li>MySQL</li>
  <li>SQLite</li>
  <li>PostgeSQL (work-in-progress)</li>
</ul>

</div>

</body>

</html>
