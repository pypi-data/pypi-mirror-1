<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
  
  <title>Internationalisation</title><meta name="generator" content="amaya 8.1a, see http://www.w3.org/Amaya/" />
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>
<h1>Internationalisation</h1>
<p>One important issue was intentionally not covered in the <a href="template-design.html">"Template Design"</a>
document: the usage of different texts, labels or phrases chosen
according to the languages understood by users of an application. The
XSLForms toolkit provides two mechanisms for the use of translations
and translated phrases:</p><ul><li>The&nbsp;<a href="reference.html#i18n"><code>template:i18n</code></a> attribute, as described in the <a href="reference.html">"Template Attribute Reference"</a> document.</li><li>The&nbsp;<a href="../apidocs/public/XSLForms.Output-module.html#i18n"><code>template:i18n</code></a> extension function, as described in the <a href="../apidocs/public/XSLForms.Output-module.html">extension function API documentation</a>.</li></ul><span style="font-family: sans-serif;"><span style="font-weight: bold;"></span></span><p>Each
of the above mechanisms has its own specific purpose in&nbsp;template
documents, and these purposes are described below, along with the
necessary procedures for initialising and invoking the translation
mechanisms in an XSLForms application.<br /></p><h2><a name="TranslatingElementContent"></a>Translating Element Content</h2><p>Consider the following document fragment:</p><pre>&lt;h1&gt;System Configurator&lt;/h1&gt;</pre><p>In
order to translate this to a different language, according to that
preferred by the user, we must annotate the element containing the text
as follows:</p><pre>&lt;h1 template:i18n="-"&gt;System Configurator&lt;/h1&gt;</pre><p>Here, we state that the contents on the&nbsp;<code>h1</code> element (the exact text&nbsp;<code>System Configurator</code>)
will be used to find a suitable translation in a translation dictionary
(as described below). The anticipated result of applying the annotation
would resemble&nbsp;the following output document fragment:</p><pre>&lt;h1&gt;Systemkonfigurasjon&lt;/h1&gt;</pre><p>Consequently,
a&nbsp;translation has been inserted in place of the original text. In
cases where no translation could be found, the original contents of the
element would be preserved.</p><h3>Named Translations</h3><p>It is also possible to employ a
specific translation as opposed to the text which just happen to reside
inside an element; for example:</p><pre>&lt;h1 template:i18n="sysconfig"&gt;System Configurator&lt;/h1&gt;</pre><p>Here, instead of taking the  exact text&nbsp;<code>System Configurator</code> as the "token" to be used to find a translation, we instead use the token with the name <code>sysconfig</code>. The effect, providing that the translation of&nbsp;<code>sysconfig</code> is&nbsp;<code>Systemkonfigurasjon</code>,&nbsp;would be the same as the result given above.</p><h3>Value Translations</h3><p>In cases where the value being translated is not known before a document is to be displayed, one can either use the&nbsp;<code>template:i18n</code> extension function (as described below), special features of other annotations (such as&nbsp;<code>template:multiple-choice-value</code>), or expression-based translations, where an XPath expression is supplied within the annotation.</p><p>Here is an&nbsp;example for translating a multiple-choice field's values:</p><pre>&lt;select template:multiple-choice-field="-,type" name="..." value="..."&gt;<br />  &lt;option template:multiple-choice-value="type-enum,type,selected,template:i18n(@type)" value="..."/&gt;<br />&lt;/select&gt;</pre><p>Note that this actually uses the <code>template:i18n</code> extension function in conjunction with the annotation's support for separate labels.</p><p>Here is how this might be done using an expression-based translation:</p><pre>&lt;select template:multiple-choice-field="-,type" name="..." value="..."&gt;<br />  &lt;option template:i18n="{@type}" template:multiple-choice-value="type-enum,type,selected" value="..."/&gt;<br />&lt;/select&gt;</pre><p>In the above multiple-choice field definition, a range of values are presented that originates from&nbsp;<code>type</code> attributes on a number of <code>type-enum</code>
elements. Instead of just presenting the raw values as the labels for
the resulting pull-down menu, it is possible to override the
underlying&nbsp;<code>template:value</code> mechanism and provide a translation instead.</p><p>See the <a href="reference.html#i18n"><code>template:i18n</code></a> section of the <a href="reference.html">"Template Attribute Reference"</a> document for details of this annotation.</p><h2><a name="TranslatingAttributes"></a>Translating Attributes</h2><p>Consider the following document fragment:</p><pre>&lt;input type="submit" name="update" value="Update!"/&gt;</pre><p>In order to translate the label of this particular form control to another language, we must modify the&nbsp;<code>value</code> attribute as follows:</p><pre>&lt;input type="submit" name="update" value="{template:i18n('Update!')}"/&gt;</pre><p>Here,
we insert an expression inside the attribute whose result will be
inserted in&nbsp;place of the expression. Note that for non-template
attributes, the expression must reside between&nbsp;<code>{</code> and <code>}</code> characters for the evaluation to take place. The anticipated result might resemble something like the following:</p><pre>&lt;input type="submit" name="update" value="Oppdat&eacute;r"/&gt;</pre><p>Where
no suitable translation can be found for the text passed to the
function, the submitted text is returned as a result, producing
something resembling the original, non-translated document fragment.</p><p>See the <a href="../apidocs/public/XSLForms.Output-module.html#i18n"><code>template:i18n</code></a> extension function description in the <a href="../apidocs/public/XSLForms.Output-module.html">extension function API documentation</a> for more details.</p><h2>Initialising and Invoking Translations</h2><p>To
permit the translation of text to occur, we must first prepare the
translations themselves; then, we must change our application to make
use of the translations.</p><h3><a name="PreparingTheTranslations"></a>Preparing the Translations</h3><p>Translations
are typically stored in an XML file alongside other resources such as
templates and documents containing data which are also used to prepare
the final user-viewable output from an application. For example, one
can define a file with the name&nbsp;<code>translations.xml</code> and then insert the following contents into it:</p><pre>&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;<br />&lt;translations&gt;<br />  &lt;locale&gt;<br />    &lt;code value="en_GB"/&gt;<br />    &lt;code value="en"/&gt;<br />  &lt;/locale&gt;<br />  &lt;locale&gt;<br />    &lt;code value="nb_NO"/&gt;<br />    &lt;code value="nb"/&gt;<br />    &lt;translation value="System Configurator"&gt;Systemkonfigurasjon&lt;/translation&gt;<br />    &lt;translation value="Update!"&gt;Oppdat&eacute;r!&lt;/translation&gt;<br />    &lt;translation value="Export!"&gt;Eksport&eacute;r!&lt;/translation&gt;<br />  &lt;/locale&gt;<br />&lt;/translations&gt;</pre><p>The structure of any such translations file must resemble the above:</p><ol><li>A top-level&nbsp;<code>translations</code> element containing...</li><li>A number of&nbsp;<code>locale</code> sections, each containing...</li><li>One or more&nbsp;<code>code</code> elements identifying the&nbsp;locale, together with...</li><li>A number of&nbsp;<code>translation</code> elements, each providing a translation for each token.</li></ol><p>In the above example, the locale for&nbsp;<code>en</code> and <code>en_GB</code> have no translations defined; as a result, for any requests for translations in this locale the
text already found in the document will be preserved.</p><p>Conversely, in the above example, the locale for&nbsp;<code>nb</code> and&nbsp;<code>nb_NO</code>
has some translations defined; as a result, requests for translations
in this locale will result in the specified translations being
returned, provided the token is defined in a&nbsp;<code>value</code> attribute of a&nbsp;<code>translation</code> element; otherwise, the default translation&nbsp;will be employed.</p><p>Note that the default translation,&nbsp;<strong>in contrast to earlier versions of XSLTools</strong>, is defined by the first <code>locale</code>&nbsp;section.
Thus, in the above example, other locales not mentioned in the
translations file will employ the translations associated with the <code>en</code> and <code>en_GB</code>&nbsp;locales.
In this case, the text already found in the document will be preserved
since no translations are explicitly given for that locale.</p><h4>Summary of Selection Algorithm</h4><p>The following algorithm summarises the above description:</p><ol><li>For a requested locale, look for a matching <code>locale</code> section.</li><li>For a matching section, find a translation for a text value; if a translation is found, return it.</li><li>Where
no matching section or translation is found, find a translation in the
first, default section; if a translation is found, return it.</li><li>Where no matching default translation is found, return the original text value.</li></ol><h3><a name="UsingTheTranslations"></a>Using the Translations</h3><p>To make use of such a translation file, the file must first be registered in an application. As described in the <a href="Web-resource.html">"Creating Applications: Write a Web Resource"</a> and <a href="XSLForms-resource.html">"Using the XSLFormsResource API"</a> documents, we may add the above example to a resource in the&nbsp;<code>document_resources</code> attribute:</p><pre>document_resources = {<br />    "translations" : "translations.xml"<br />    # Other resources are defined here.<br />    }</pre><p>When
producing output for a template which uses internationalisation
features, we must first obtain a reference to the above document:</p><pre># In the respond_to_form method of an XSLFormsResource...<br />translations_xml = self.prepare_document("translations")</pre><p>Then,
we must decide which language or locale the output will employ. One way
of making that decision is to use the WebStack API to find out which
languages a user's Web browser is configured to receive:</p><pre># In the respond_to_form method of an XSLFormsResource...<br />languages = trans.get_content_languages()<br /># Get the first one...<br />try:<br />    language = languages[0]<br />except IndexError:<br />    language = "" # Or choose an acceptable default.</pre><p>Finally,
with the above information in hand, we may now modify the output
production by adding a document reference (thus permitting the output
stylesheet to access the translations document) and by specifying the
chosen locale with the&nbsp;<code>locale</code> stylesheet parameter:</p><pre># Use the transaction, output stylesheet, form data document, stylesheet parameters<br /># as well as the document reference.<br />self.send_output(trans, [output_xsl], doc, {"locale" : language},<br />    references={"translations" : translations_xml})</pre><p>This
should produce an output document which uses the registered
translations as much as is possible for the selected language.
Obviously, a more complicated approach could be used to choose the most
appropriate language in the&nbsp;<code>languages</code> list, but such algorithms are not covered here.</p></body></html>