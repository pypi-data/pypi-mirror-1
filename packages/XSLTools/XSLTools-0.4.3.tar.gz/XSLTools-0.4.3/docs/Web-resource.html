<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
  
  <title>Creating Applications: Write a Web Resource</title><meta name="generator" content="amaya 8.1a, see http://www.w3.org/Amaya/" />
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>
<h1>Creating Applications: Write a Web Resource</h1>
<p>With a completed template after the <a href="design.html">design</a>,
<a href="structure.html">structure annotation</a> and <a href="selectors.html">selector annotation</a>, we may now write a Web
resource which will expose our form as a Web application, allowing
users to input information and to manipulate that information using
their Web browser. Whilst XSLForms is just a normal Python package
which can be used from many kinds of programs and environments, we
shall concentrate on using the built-in <a href="http://www.boddie.org.uk/python/WebStack.html">WebStack</a>
support to build a
WebStack application around our form template.</p>
<h2>XSLForms Meets WebStack </h2>
<p>In the <a href="directory.html">directory structure</a> created
earlier, we now want to edit the&nbsp;<code>__init__.py</code> file and
add code which will do most of the work of the form-editing
application. Here is the start of this code:</p>
<pre>#!/usr/bin/env python<br /><br />"A very simple example application."<br /><br />import WebStack.Generic<br />import XSLForms.Resources.WebResources<br />import XSLForms.Utils<br />import os<br /><br /># Resource classes.<br /><br />class VerySimpleResource(XSLForms.Resources.WebResources.XSLFormsResource):<br /><br />    # To be continued.</pre>
<p>The above import statements just include in our application
everything that it is likely to need from WebStack, XSLForms and the
standard library. Then, we define a class inheriting from a special
XSLForms class which does some of the tedious Web application
housekeeping that we would otherwise need to do ourselves.</p>
<p>We may expand the above class definition as follows:</p>
<pre>class VerySimpleResource(XSLForms.Resources.WebResources.XSLFormsResource):<br /><br />    "A very simple resource providing a hierarchy of editable fields."<br /><br />    resource_dir = os.path.join(os.path.split(__file__)[0], "Resources")<br />    encoding = "utf-8"<br />    template_resources = {<br />        "structure" : ("structure_template.xhtml", "structure_output.xsl")<br />        }<br /><br />    def respond_to_form(self, trans, form):<br /><br />        """<br />        Respond to a request having the given transaction 'trans' and the given<br />        'form' information.<br />        """<br /><br />        # To be continued.</pre>
<p>The class is started with some attribute definitions:</p>
<ul>
  <li>The&nbsp;<code>resource_dir</code> attribute is used to locate
the template, stylesheet and other non-Python resources. We calculate
this attribute by taking the location of the Python package itself and
finding the&nbsp;<code>Resources</code> subdirectory, just as described
in the <a href="directory.html">directory structure</a> document.</li>
  <li>The&nbsp;<code>encoding</code> attribute is not strictly
necessary, but it states which character encoding will be used in the
Web pages generated by the template, and UTF-8 is a safe choice in most
situations.</li>
  <li>The&nbsp;<code>template_resources</code> attribute is a
dictionary mapping a name onto details about our template and the
stylesheet that will actually produce the Web pages for each form being
edited.<br />
    <ol>
      <li>For the key, we choose a name that can easily be remembered
and associated with our template:&nbsp;<code>structure</code> (since
the root element of the form data is always&nbsp;<code>structure</code>)</li>
      <li>Then, we specify the filename of our template in the&nbsp;<code>Resources</code>
directory:&nbsp;<code>structure_template.xhtml</code> (if the suggested
name was used)</li>
      <li>Finally, we choose a filename for the stylesheet. Since this
is automatically produced from the template, we only need to choose a
name which is not already in use by another file, and for clarity a
name similar to that of the template is recommended:&nbsp;<code>structure_output.xsl</code></li>
    </ol></li></ul>
<p>The class also has a method which resembles the typical&nbsp;<code>respond</code>
method of normal <a href="http://www.boddie.org.uk/python/WebStack.html">WebStack</a>
resources: the&nbsp;<code>respond_to_form</code> method is, in fact, a
special version of that method providing ready-to-use information about
the form (or forms) being edited.</p>
<p>We may now add to the above method definition by considering what
the resource needs to do when being sent a request by a user of the
application.</p>
<h3>Defining the Method</h3>
<p>First of all, we need to inspect the&nbsp;<code>form</code> object
to see if any form data is available. Since the data is provided
throughout XSLForms as XML documents, we call the&nbsp;<code>get_documents</code>
method on the&nbsp;<code>form</code> object:</p>
<pre>        documents = form.get_documents()</pre>
<p>As a result of this method, we should now have a dictionary mapping
form names to XML documents containing form data. However, it is not
guaranteed that the form data for our chosen form,&nbsp;<code>structure</code>,
even exists since a user may be visiting the resource for the first
time.</p>
<p>Therefore, we test to see if the&nbsp;<code>structure</code>
document exists, creating a new document if it did not:</p>
<pre>        # Ensure the presence of a document.<br /><br />        if documents.has_key("structure"):<br />            structure = documents["structure"]<br />        else:<br />            structure = form.new_instance("structure")<br /></pre>
<p>Now we should have a document containing the data for the form being
edited, regardless of whether any form was filled out and submitted or
whether we have created a new one for that purpose.</p>
<p>It may be the case that a user pressed a button in order to add or
remove items or subitems from the form. We must respond to such things
by examining the selector information to see which parts of the&nbsp;<code>structure</code>
document are affected:</p>
<pre>        # Add and remove elements according to the selectors found.<br /><br />        selectors = form.get_selectors()<br /></pre>
<p>The result of <code>get_selectors</code> is a dictionary mapping
selector names to lists of&nbsp;nodes affected by each particular
selector. In the <a href="selectors.html">selector annotation</a>
process, we defined selectors for the addition and removal of items and
subitems, and for convenience we pass the results for each selector to
a special function to perform the appropriate operation for us:</p>
<pre>        XSLForms.Utils.remove_elements(selectors.get("remove2"))<br />        XSLForms.Utils.add_elements(selectors.get("add2"), "subitem")<br />        XSLForms.Utils.remove_elements(selectors.get("remove"))<br />        XSLForms.Utils.add_elements(selectors.get("add"), "item")<br /></pre>
<p>Finally, we are ready to present the edited form data. In typical
WebStack fashion, we emit the content type of the final output along
with our chosen character encoding:</p>
<pre>        # Start the response.<br /><br />        trans.set_content_type(WebStack.Generic.ContentType("application/xhtml+xml", self.encoding))<br /></pre>
<p>Then, we ensure that our template is ready to use by calling the
superclass's&nbsp;<code>prepare_output</code> method with the name of
the form:</p>
<pre>        # Ensure that an output stylesheet exists.<br /><br />        trans_xsl = self.prepare_output("structure")<br /></pre>
<p>This prepares the stylesheet whose file is named in the&nbsp;<code>template_resources</code>
attribute entry, and this stylesheet is then sent to the
superclass's&nbsp;<code>send_output</code> method as part of a list of
stylesheets (although we only use a single stylesheet in this example)
along with the form data itself:</p>
<pre>        # Complete the response.<br /><br />        self.send_output(trans, [trans_xsl], structure)</pre>
<p>At this point, the user should receive their edited form and be able
to make more modifications.</p>
<h3>Deployment Details</h3>
<p>Some additional code is required to deploy this example application
using WebStack. We have chosen to expose the above resource class using
a special function which can be called from outside the package to
obtain an instance of the class:</p>
<pre># Site map initialisation.<br /><br />def get_site():<br /><br />    "Return a simple Web site resource."<br /><br />    return VerySimpleResource()</pre>
<p>To actually deploy the application, we could choose one of many
server environments supported by WebStack. For clarity, we choose here
to write the following separate program which we can save under the
name&nbsp;<code>VerySimpleApp.py</code> (for example):</p>
<pre>#!/usr/bin/env python<br /><br />from WebStack.Adapters.BaseHTTPRequestHandler import deploy<br />import VerySimple<br /><br /># Get a simple Web site.<br /><br />resource = VerySimple.get_site()<br /><br /># Special magic incantation.<br /><br />print "Serving..."<br />deploy(resource, handle_errors=0)</pre>
<p>Ensuring that the example application's package (which we
called&nbsp;<code>VerySimple</code> in the directory structure
document), WebStack, libxml2dom and XSLForms are available to the above
program, we may now run this program:</p>
<pre>python VerySimpleApp.py</pre>
<p>It should then be possible to visit the URL&nbsp;<code>http://localhost:8080/</code>
and edit the form in your Web browser.<br />
</p>
<h2>Further Enhancements</h2>
<p>We should now have an application which can be deployed and tested
using the usual WebStack techniques. However, more advanced templates
can be designed, and we shall consider <a href="multiple.html">multiple-choice
fields</a> in&nbsp;the next activity in the development <a href="overview.html">process</a>.</p>
</body></html>
