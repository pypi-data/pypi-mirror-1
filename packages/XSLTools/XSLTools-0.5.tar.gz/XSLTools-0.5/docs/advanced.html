<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
  <title>Advanced Template Design</title>
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>
<h1>Advanced Template Design</h1>
<p>In the <a href="template-design.html">"Template Design"</a> document, the special XSLForms annotations
were presented as a means to display the information contained in form
data documents (or just general XML documents with no special
connection to Web forms). However, since XSLForms templates build upon
XSL transformations, it is also possible to employ certain XSL
techniques to present the information in various different ways.</p><h2>Templates and Transformations</h2><p>When prepared, XSLForms templates are converted to XSL stylesheets, and
when form data is displayed, such XSL stylesheets are used to
transform the form data to a representation which looks like the
original template, but with different parts of the template populated
with the form data. The process can be illustrated as
follows:</p>
<table style="text-align: left; width: 80%;" align="center" border="0" cellpadding="5" cellspacing="5">
  <tbody>
    <tr>
      <th style="border: 1px solid rgb(0, 0, 0); background-color: rgb(193, 255, 102); text-align: center; vertical-align: top;">Template<br />
      <span class="method">A template presents the general form of the final output.</span></th>
      <th style="border-style: solid; border-width: 1px; text-align: center; vertical-align: top;">Stylesheet<br />
      <span class="method">Templates are converted to stylesheets, which are like programs specially designed to present XML information.</span></th>
      <th style="border: 1px solid rgb(0, 0, 0); background-color: rgb(255, 204, 255); text-align: center; vertical-align: top;">Output<br />
      <span class="method">The final output is produced when a stylesheet is combined with an XML document.</span></th>
    </tr>
  </tbody>
</table>
<p>Since the stylesheet is based on XSL, which is a rich
language in its own right, advanced template design techniques can
involve some of the features of XSL - at least those which do not
affect the simplicity or general structure of our templates.</p><h2>Template Extension Functions and Variables</h2><p>One
area where XSL features are already employed to affect the final output
in XSLForms is in the toolkit's use of template extension
functions and special variables - the latter being used in the output
production process. For example, we might decide to use the lower level
template functions to present the value of an attribute:</p><pre>&lt;span template:attribute="some-attribute" template:value="$this-value"&gt;xxx&lt;/span&gt;</pre><p>In the above example, we reference the special variable <code>$this-value</code> which refers to the value of <code>some-attribute</code>. An example of template functions in use looks like this:</p><pre>&lt;span id="{template:this-element()}"&gt;xxx&lt;/span&gt;</pre><p>In the above example, we invoke the template function <code>template:this-element</code>
in order to create a unique identifier in the final output. Since we
use the function inside an attribute which is not prefixed with <code>template</code>, we must enclose the expression between <code>{</code> and <code>}</code> characters.</p><h2>Beyond Template Extension Functions</h2><p>Since
the above template extension functions and variables are merely special in the
sense that XSLForms provides them to produce its output, and since they
are accessed in the stylesheet using normal XSL-based mechanisms, there
is no technical barrier to using other kinds of valid XSL (or more
precisely, XPath) expressions in cases such as those given above. The
rules for using such expressions in attributes are straightforward:</p><ul><li>Attributes prefixed with <code>template</code> can contain expressions as one would write them normally.</li><li>Other attributes must have their expressions enclosed between <code>{</code> and <code>}</code> characters so that the expression is evaluated and replaced with the result in the final output.</li></ul><p>Here is a trivial example of the usage of an XPath expression, based on one of the above examples:</p><pre>&lt;span template:attribute="some-attribute" template:value="string-length($this-value)"&gt;xxx&lt;/span&gt;</pre><p>In the above example, we invoke the standard XPath function <code>string-length</code> in order to produce within the <code>span</code> element the length of the value of <code>some-attribute</code> (instead of the actual value).</p><p>More
interesting applications of XPath expressions and non-XSLForms
functions arise when using more of the potential of XPath to select
arbitrary elements and attributes and to perform calculations on the
selected nodes. The following example originates from the Configurator
example application:</p><pre>&lt;span template:value="sum(/configuration//*[@value-is-set]/@price) + sum(/configuration//*[@value = ../@value]/@price)"&gt;&lt;/span&gt;</pre><p>This complicated expression, to be inserted within the <code>span</code> element, finds all elements in the system configuration having the <code>value-is-set</code>
attribute and adds their prices together; this total is combined with
the sum of the prices from all elements marked as selected in their
respective lists. In other words, it gets the total of all selected
components and inserts it into the final output.</p></body></html>
