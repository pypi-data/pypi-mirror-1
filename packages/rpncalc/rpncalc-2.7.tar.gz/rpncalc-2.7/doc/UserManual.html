<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
<meta http-equiv="CONTENT-TYPE" content=
"text/html; charset=us-ascii">
<title>RPN Calculator User Manual</title>
</head>
<body lang="en-US" dir="ltr">
<h1 align="center">RPN Calculator User Manual</h1>
<h1>Introduction</h1>
<p>Anyone who uses the Python interactive command line knows that
Python is a good interactive calculator. However, there are many
people who prefer Reverse Polish Notation (RPN) for simple
interactive calculations. The rpncalc module provides an
interpreter for RPN that easily integrates with the standard Python
interpreter.</p>
<h1>Features</h1>
<ul>
<li>
<p>Supports the standard Python numeric data types (integer, long
integer, float, and complex).</p>
</li>
<li>
<p>Uses the <a href="http://www.ginac.de/CLN/">Class Library for
Numbers</a> (CLN) to provide rationals, extended precision floating
point, and their complex counterparts. Defaults to the CLN numeric
types. Requires an explicit conversion to Python float and
complex.</p>
</li>
<li>
<p>Preserves the user's data when exceptions are raised. This helps
the user to debug a calculation or recover from the error and
continue.</p>
</li>
<li>
<p>Division of two integers produces a rational.</p>
</li>
<li>
<p>Supports the Python built-in functions that apply to
numbers.</p>
</li>
<li>
<p>Provides extended precision versions of the functions in the
standard math and cmath libraries.</p>
</li>
<li>
<p>Allows user installation of additional Python functions. This is
the primary mechanism for programming the calculator.</p>
</li>
<li>
<p>Supports smooth transition between RPN and Python interpreters.
This allows a user to use the interpreter that is most convenient
for solving a particular problem.</p>
</li>
<li>
<p>Avoids the complexity of making the RPN interpreter into a full
programming language. In my opinion, Python is a lot easier to
program in than a language like Forth (the classic RPN programming
language). I have used Forth and Forth-like languages for over 20
years. I do not think the RPN interpreter should be turned into yet
another Forth-like language.</p>
</li>
<li>
<p>Leaves the hard things like arrays to the Python interpreter.
Inventing RPN notation for something Python handles well is a waste
of time. Much better to simply switch over to the Python
interpreter.</p>
</li>
</ul>
<h1>References</h1>
<ul>
<li>
<p><a href="http://sourceforge.net/projects/calcrpnpy/">Download
page.</a></p>
</li>
<li>
<p><a href="clnumManual.html">Python interface to Class Library for
Numbers</a></p>
</li>
<li>
<p><a href="ratfunManual.html">Polynomials and Rational
Functions</a></p>
</li>
</ul>
<h1><a name="Tutorial" id="Tutorial"></a>Tutorial</h1>
<p>This tutorial presents the concepts needed to operate the RPN
interpreter. Extending the interpreter is covered in the <a href=
"#Programming">Programming</a> section. Before you get started, you
need to install the interpreter. Follow the instructions in the
<a href="#Installation">Installation</a> section.</p>
<p>There is no attempt to teach you how the Python interactive
interpreter works. If you are new to interactive use of Python, you
should start with the Python tutorial which is included in the
standard Python documentation package.</p>
<p>You will want to start with the rpn.py script from the examples
directory. This script must be run with the -i switch on the Python
command line. If this is not done, a number of interactive features
don't work. In particular, on my Debian box, the command history
doesn't work. The following command will work on most systems if
rpn.py is in the current directory.</p>
<pre>
$ python -i rpn.py
</pre>
<h2>Getting Help</h2>
<p>You can use the <code>help</code> command or its alias
<code>?</code> to display on-line help for any command. As an
example, display the help on the add command.</p>
<pre>
%(help +)s
</pre>
<p>This displays the name of the command, the stack picture, and a
description of what the command does. The stack picture shows how
the stack is altered by the command. There can be other entries on
the stack which are not pictured. The operation has no effect on
these entries. In the above example, the stack picture shows that
the add operation takes two values from the stack and returns the
sum.</p>
<p>Some commands take input from the input stream as well as the
stack. For these cases, the stack picture has a different form as
can be seen in the following example.</p>
<pre>
%(? solve)s
</pre>
<p>This example shows that the <code>solve</code> command takes two
inputs from the stack and the name of the function from the input
stream. If <code>f</code> is the name of a function that computes
<code>x*x-2</code> the following will compute the square root of
2.</p>
<p><code>rp&gt; 1 2 solve f</code></p>
<h2>Basic Operations</h2>
<p>The simplest way to learn to use the RPN interpreter is to see
several examples side by side with the equivalent calculation done
using the Python interpreter. In the following, you can tell which
interpreter is operating by the prompt.</p>
<pre>
%(p:print 1+2
1 2 + .
p:print mpq(2+3)/(5+7)
2 3 + 5 7 + / .
p:print mpq(1,3)+mpq(1,5)
1/3 1/5 + .
p:print 1+1j + 1-1j
1+1j 1-1j + .)s
</pre>
<p>From the above examples, we can make several observations.</p>
<ul>
<li>
<p>Numbers and operators in the RPN interpreter are separated by
white space.</p>
</li>
<li>
<p>Operands precede operators (hence the name Reverse Polish
Notation).</p>
</li>
<li>
<p>The top of the stack is printed by the "dot" operator (a period
character). The value is removed from the stack by this
operator.</p>
</li>
<li>
<p>Rational numbers are expressed in a more obvious form.</p>
</li>
<li>
<p>A print statement is required to get Python to print values in
the same form as the RPN interpreter.</p>
</li>
</ul>
<p>Now lets see a couple of math operations in action. Note that I
prefer the ln name to log so it is provided as an alias.</p>
<pre>
%(p:print sqrt(2)
2 sqrt .
p:print log(2)
2 log .
2 ln . # Alternate name for log)s
</pre>
<p>For those needing complex numbers, the same functions can be
applied to complex inputs. This differs from the Python standard
library which has a separate module to handle complex numbers.</p>
<pre>
%(p:print sqrt(-2+0j)
-2+0j sqrt .
p:print log(2j)
2j log .
2j ln . # Alternate name for log)s
</pre>
<p>The following examples are rather obvious and the Python
versions are verbose (because the Python interpreter does not have
a built-in rational type), so only the RPN form is presented.</p>
<pre>
%(1/2 1/3 sum .
1/2 1/3 prod .
1/2 1/3 1/5 1/7 1/11 1/13 sum .
1/2 1/3 1/5 1/7 1/11 1/13 prod .)s
</pre>
<p>Base conversions are demonstrated in the following example.</p>
<pre>
%(h:clear
0xff .  # Hex input
256 .x  # Hex output
0o377 . # Octal input
256 .o  # Octal output
0b101 . # Binary input
10 .b   # Binary output
h:clear)s
</pre>
<h2>Stack Operations</h2>
<p>The stack is the central data structure of all RPN style
calculators. Eventually, it becomes necessary to manipulate the
items on the stack. This section shows the operations that are
available. Note that these are all borrowed from the Forth
programming language.</p>
<p>In order to show the stack effects, another operator is
introduced (<tt>.s</tt>) which non-destructively prints the stack
contents. This operator is extremely useful if you need to see how
a long calculation is going.</p>
<pre>
%(h:clear
1 dup .s # Duplicate the top of the stack.
clear .s # Clear the stack.
1 2 .s
drop .s  # Remove the top of the stack.
clear
1 2 .s
swap .s  # Swap the top two elements on the stack.
clear
1 2 .s
over .s  # Make a copy of the second element on the stack.
clear
1 2 3 .s
rot .s   # Rotate the third element to the top of the stack.
clear)s
</pre>
<p>In some cases, the stack manipulation can get a lot more complex
than the above operations can accommodate. There are two options
that can be used to handle this problem. One is to use an alternate
stack to hold values out of the way until they are needed. The
other is to use named variables. This second alternative is
demonstrated in the next section.</p>
<p>The alternate stack is another concept borrowed from the Forth
programming language. (If you are familiar with Forth, you will
recognize that the alternate stack is used like the return stack.)
The following operators move data on and off the alternate
stack.</p>
<pre>
%(h:clear
1 &gt;a .s  # Move the top of the main stack to the alternate stack.
a@ .     # Fetch the top of the alternate stack but don't remove it.
a&gt; .     # Move the top of the alternate stack to the main stack.
h:clear)s
</pre>
<p>Since the stack is such a central data structure to the RPN
interpreter, it is necessary to have an easy way to move data on
and off the stack from the Python interpreter. Without this
mechanism, it would be very clumsy to switch back and forth between
interpreters. The following examples show how to switch between
interpreters and move data back and forth.</p>
<pre>
%(h:clear
1 2 3        # Put some values on the stack.
py           # Switch to the Python interpreter.
p:print pop()  # Pop one value.
p:a,b = pop(2) # Pop two values and save them in variables.
p:print a,b
p:push(4,5,6)  # Push some values on the stack.
p:print get(3) # Show that they got there.
p:rpn()        # Switch back to the RPN interpreter.
.s           # Show that the values are on the stack.
h:clear)s
</pre>
<h2>Variables</h2>
<p>Every calculator designed to support extended calculations needs
some kind of memory function. In the RPN interpreter, the memory
function is handled by named variables. The following examples show
how these variables are created and used from both the RPN and
Python interpreters.</p>
<pre>
%(# Create three variables and show that nothing is left on the stack.
1 := a 2 := b 3 := c .s
.v  # Quick way to show the contents of all defined variables.
a b c sum .  # Use the variables in a calculation.
py  # Switch to the Python interpreter.
p:v=getv()  # Get the variables from the RPN environment.
p:print v   # Display them.
p:v.d=4     # Create a new variable.
p:print v
p:setv(v)   # Update the variables in the RPN environment.
p:rpn()
d .  # Verify that the new variable transferred over.
h:clear)s
</pre>
<p>Augmented assignment is a convenient way to update variables.
Since the names of the operators are the same as they are in
Python, a few examples should be sufficient.</p>
<pre>
%(1 := a 1/2 := b 0.5 := c 1+1j := d
1 += a
2 -= b
3 *= c
4 /= d
.v
h:clear)s
</pre>
<p>Variables can be deleted to eliminate clutter.</p>
<pre>
%(.v
delete_variables a b
.v
delete_variables c d
.v)s
</pre>
<h2>Polynomials And Rational Functions</h2>
<p>An interesting extension to the RPN calculator is to add
polynomials in a manner that allows them to be manipulated like
numbers. In order to support polynomials efficiently, it is
necessary to invent a notation that will allow the number
conversion process to convert the notation into a polynomial
object. The notation selected has the following form:</p>
<pre>
coef,exp;coef,exp;...;coef
</pre>
<p>In other words, a string of polynomial coefficient, exponent
pairs. The exponents must be non-negative integers. The
coefficients can be any numeric format recognized by the number
converters currently installed.</p>
<pre>
%(1,2;2,1;1 .
1,1;1 dup .s
* .
1/2,4;-1/3,2;1/5 := p
.v
p .r       # It is instructive to see the representation of an object.
p deg .    # Degree of the polynomial.
p deriv .  # Compute the derivative of the polynomial.
p integ .  # Compute the integral of the polynomial.
p 1 eval . # Evaluate the polynomial at the value 1.
h:delete_variables p)s
</pre>
<p>If you need to compute the coefficients, take advantage of the
fact that polynomials can be mixed with ordinary numbers in a
calculation. The number is converted to a constant polynomial
before the operation is performed. To illustrate this technique,
compute a polynomial that is the truncated series expansion of the
exponential function.</p>
<pre>
%(1;1,1 := p   # Start with the first two terms.
1/2 := c     # Next coefficient
c 1,2 * += p
3 /= c
c 1,3 * += p
4 /= c
c 1,4 * += p
5 /= c
c 1,5 * += p
6 /= c
c 1,6 * += p
7 /= c
c 1,7 * += p
8 /= c
c 1,8 * += p
9 /= c
c 1,9 * += p
p .

# Check this by evaluating it at a few points and comparing with the built-in
# function.  It is tedious to keep typing eval so create a function from the
# polynomial.
p to_fun aexp
0 aexp .
0.5 aexp 0.5 exp - .
1 aexp 1 exp - .
-1 aexp -1 exp - .)s
</pre>
<p>Switch to the Python interpreter to check the polynomial against
the built-in function for a large number of sample points.</p>
<pre>
%(py
p:from math import exp
p:v = getv()
p:err = [abs(y - exp(x)) for x,y in v.p.float().sample(-1,1,100)]
p:print len(err)
p:print max(err)
p:print err[0], err[50], err[-1]
h:delete_variables c p
hp:del rpncalc.userVoc['aexp'])s
</pre>
<p>This notation is extended to support rational functions (ratio
of two polynomials). The rational function is entered as
"<tt>n|d</tt>" where <tt>n</tt> is the numerator polynomial and
<tt>d</tt> is the denominator polynomial. The polynomials are
entered using the notation described above.</p>
<pre>
%(1,1;-1|1,1;1 := z
z .
1/7,7;1/5,5;1/3,3;1,1 := p
p .
# An approximation to the natural log is produced by evaluating the polynomial
# using the rational function as the input.
p z eval 2 * := aln
aln .
# Check it at a couple of points.
aln 1 eval .
aln 2 eval float dup .
# Compare it to the built-in function.
2 ln - float .)s
</pre>
<p>Use the Python interpreter to compare the rational function
approximation with the built-in function at a large number of
sample points.</p>
<pre>
%(py
p:v = getv()
p:# Compute the error relative to the built-in function
p:from math import log
p:err = [abs(log(x) - y) for x,y in v.aln.float().sample(1,2,100)]
p:print len(err)
p:print max(err)
p:print max(err[:50])
h:delete_variables aln p z)s
</pre>
<h1><a name="Programming" id="Programming"></a>Programming</h1>
<p>Programming the calculator is relatively easy. Usually you
simply create an ordinary Python function and install it into the
calculator using one of the wrapper functions. However, some
terminology will help in explaining what is going on behind the
scenes. This terminology is borrowed from the Forth programming
language.</p>
<p>When a token is extracted from the input stream by the RPN
interpreter, the first thing that it does is search a list of
vocabularies for a definition. If the definition is found, the
associated function is called. The called function is responsible
for any stack manipulation that is required to execute the
operation. A vocabulary is nothing more than an augmented Python
dictionary. The dict type is sub classed and a name attribute is
added so that the vocabulary name can be printed when the user asks
for a listing of the contents. You can get a listing of the search
order and the contents of the active vocabularies with the
<code>words</code> command as follows.</p>
<pre>
%(hp:rpncalc.userVoc.clear()
words)s
</pre>
<p>Note that the user defined variables are in their own vocabulary
and it is the first one in the search order. The system vocabulary
is the last one searched so that the user can override any of the
built in operations. The user vocabulary is reserved for installing
user defined operators. As an example, we will install a random
number function by wrapping the random function from the random
module in the standard library. The Python function
<code>function</code> in the rpncalc module is used to install
Python functions for use in the calculator (see the doc string for
more information).</p>
<pre>
%(py
p:from random import random
p:# Install the Python function.
p:function(random,0,name='rand')
p:rpn()
rand .
rand .)s
</pre>
<p>It can get tedious to drop into the Python interpreter to define
and install simple one-liners. The RPN interpreter has a
<code>def</code> command that simplifies the creation of simple
functions. Suppose you want to use the equation solver to compute
the solution to <code>x*x-2=0</code>. The following example shows
how to enter the problem.</p>
<pre>
%(def f(x) x*x-2
1 2 solve f
dup .
2 sqrt - .)s
</pre>
<p>The <code>def</code> command can be used to define more complex
functions as in the following. Note that white space is not allowed
in the specification of the function name and the parameter list
since it must resolve to a single RPN interpreter token.</p>
<pre>
%(def g(x,y) sqrt(x*x + y*y)
1 2 g
dup .
1 2 hypot
- .)s
</pre>
<p>The above example is a poor substitute for the
<code>hypot</code> command because the <code>hypot</code> command
will deliver more accurate results in cases where the squaring
operation looses precision or causes an overflow.</p>
<p>If you need a Chebyshev approximation to some function, you can
create one as demonstrated in the following example.</p>
<pre>
%(py
p:from rpncalc.chebyshev import Chebyshev as cheby
p:pi2 = pi(20)/2
p:sinx = cheby(sin, -pi2, pi2, 20, 20)
p:err = [abs(y - sin(x)) for x,y in sinx.sample(-pi2,pi2,1000)]
p:print max(err)
p:for c in sinx.coef: print c
p:sinx = sinx.edit(1e-16)
p:err = [abs(y - sin(x)) for x,y in sinx.sample(-pi2,pi2,1000)]
p:print max(err)
p:for c in sinx.coef: print c
p:# Install the function.
p:function(sinx,1,name='sinx')
p:rpn()
pi 3 / dup sinx swap sin - .)s
</pre>
<p>Another method of programming the calculator is to define a
function using a string of RPN interpreter commands. The following
example demonstrates this method.</p>
<pre>
%(py
p:prog('log2','ln 2 ln /')
p:rpn()
32 log2 .
256 log2 .
words)s
</pre>
<p>Note that this method does not allow conditional logic or
looping. If you need these operations, program your function in
Python and install it.</p>
<p>Use the rpncalc module itself as a source of further examples.
Note that additional vocabularies can be defined and added to the
search list in priority order.</p>
<h1><a name="Installation" id="Installation"></a>Installation</h1>
<p>The rpncalc package depends on the clnum package. You must
install clnum before proceeding. Refer to the <a href=
"clnumManual.html">clnum user manual</a> for instructions.</p>
<p>The simplest way to install rpncalc is to run the distutils
setup script. This will install the package in a standard place
which will be on your Python path.</p>
<pre>
python setup.py install --prefix=/usr/local
</pre>
<p>If you want to verify that everything is working, you can run
the script rpncalc_test.py from the test directory.</p>
<p>You may also want to copy the script rpn.py from the examples
directory to some place where you can get to it easily. I put it in
the bin directory in my home directory and create the following
alias to it.</p>
<pre>
alias rpn='python -i ~/bin/rpn.py'
</pre>
<p>The rpn.py script may be customized to suit your needs. For
example, you may want to uncomment the line that switches the trig
functions into degrees mode.</p>
<p>After you get set up, proceed with the <a href=
"#Tutorial">Tutorial</a>.</p>
<h1>History</h1>
<p>In the mid 1990's, I built an interpreter for a language that
was designed for use as an interactive calculator. This program
used floating point numbers as its numeric data type. It also
supported programming and was very similar to the Forth programming
language. It was designed to be extensible in C++. Since it was not
mainstream and it was difficult for may users to get used to the
RPN notation, I went looking for a programming environment that was
interactive and extensible. This lead me to Python circa 1998.
Python gave me the same ability to extend it using C/C++ but with a
more widely used language. Python is also easier to program than
Forth-like languages since you don't need to continuously keep
stack effects under control. However, I missed the simplicity of
RPN notation for doing simple calculations.</p>
<p>Rather than resurrecting my old interpreter and continuing to
maintain it, I decided to write the interpreter included in this
package. This has the added advantage that both RPN and the
standard Python interpreter are available.</p>
<p><a href="http://sourceforge.net/"><img src=
"http://sourceforge.net/sflogo.php?group_id=124786&amp;type=1"
name="Graphic1" alt="SourceForge.net Logo" align="bottom" width=
"88" height="31" border="0" id="Graphic1"></a></p>
</body>
</html>
