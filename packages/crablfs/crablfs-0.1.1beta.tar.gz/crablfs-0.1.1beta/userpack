#!/usr/bin/python
# -*- encoding: utf-8 -*-

"""Author: ÖÜÅô(Chowroc)
Date: 2006-12-01
Email: chowroc.z@gmail.com

»ùÓÚÓÃ»§µÄ°ü¹ÜÀíÏµÍ³£¬°ü¹ÜÀíÆ÷
* ¸ù¾İÅäÖÃºÍ²ÎÊıÖ´ĞĞ³õÊ¼»¯¡¢°²×°¡¢Éı¼¶ºÍĞ¶ÔØÔ´´úÂëÈí¼ş°ü£¬ÒÔ¼°ÁĞ±í¡¢²éÕÒ°üµÄÎÄ¼ş¡¢²éÑ¯ÌØ¶¨ÎÄ¼şµÄ°üÊôÖ÷ºÍ²éÑ¯°üĞÅÏ¢µÄ²Ù×÷

* ÀíÂÛÉÏÃ¿Ò»¸öÈí¼ş°ü¶¼ÓĞ×Ô¼º¶ÔÓ¦µÄÓÃ»§ºÍ×é£¬Õâ¸ö°üËùÓĞµÄÎÄ¼şµÄÊôÖ÷¶¼ÊÇ¸ÃÓÃ»§¼°Æä×é

* °ü¶ÔÓ¦µÄÓÃ»§/×éÃû¿ÉÒÔÔÚ²ÎÊıÖĞÖ¸¶¨£¬Ä¬ÈÏÎª°üµÄÃû×Ö

* Ã¿¸ö°üÓÃ»§µÄ $HOME Ä¿Â¼(/usr/src/$PACKAGE)ÏÂ´æ·Å¸Ã°üµÄ¹éµµºÍ²¹¶¡£¬ÒÔÀûÓÚ¼¯ÖĞµÄ±¸·İºÍ»Ö¸´¼°ÏµÍ³Ç¨ÒÆ£¬Òò´ËÓĞÒ»¸ö $HOME Ç°×ºÂ·¾¶ $HOMEPRE(/usr/src)

* ¶Ô°ü¼ÓÈë·ÖÀàÖ§³Ö£¬ÓÃ"."½â¾öÃû×Ö¿Õ¼äÎÊÌâ(ÓÃ»§ÃûÖĞÒ²¿ÉÒÔ°üº¬"."ºÅ)

* Ã¿¸ö°üµÄÏà¹ØĞÅÏ¢´æ·ÅÔÚ×Ô¼ºµÄ $HOME Ä¿Â¼ÖĞ($HOME/.config)£¬Ò»¸ö°üÒ»¸öÅäÖÃĞÅÏ¢ÎÄ¼ş

* °üÅäÖÃĞÅÏ¢°üÀ¨Ãû×Ö¡¢°æ±¾¡¢¹éµµ¼°²¹¶¡Î»ÖÃ¡¢°²×°°üËùĞèÒªµÄËùÓĞÃüÁî¡¢½¨Á¢µÄÊ±¼ä¼°²ÎÊıÒÔ¼°ÒÀÀµ¹ØÏµµÈ(ÒÀÀµ¹ØÏµ´ı½â¾ö)

* ¿ÉÒÔÍ¨¹ı²ÎÊıÖ¸¶¨Ê¹ÓÃÅäÖÃĞÅÏ¢ÎÄ¼şÖ±½Ó°²×°
ÕâÑù¿ÉÒÔÔÚÅú´¦Àí×´Ì¬ÏÂ×Ô¶¯Íê³ÉËùÓĞ°²×°£¬Òò¶ø¿ÉÓÃÓÚÏµÍ³µÄ±¸·İ¡¢»Ö¸´ÒÔ¼°Ç¨ÒÆ»úÖÆ

* °üº¬Ò»¸ö°üÁĞ±íÎÄ¼ş£¬ÆäÖĞÁĞ³öËùÓĞ°üµÄÃû×ÖºÍ°æ±¾ºÅ£¬Ò»ĞĞÒ»¸ö£¬¸ÃÎÄ¼şÎª $PKGLIST($HOMEPRE/packages.list)
*** ±àÂë£ºÒò´ËÔÚ°²×°Ê±£¬Èç¹û³É¹¦£¬Ó¦¸ÃÔÚ $PKGLIST ÖĞÔö¼ÓÏàÓ¦µÄÌõÄ¿£¬Ğ¶ÔØÊ±ÔòÓ¦¸ÃÉ¾³ıÖ®£»¶øÆäËûÈç²éÕÒÎÄ¼ş¡¢²éÑ¯ÊôÖ÷¡¢²éÑ¯ĞÅÏ¢µÄ²Ù×÷ÔòÓ¦ÏÈ¼ì²é°üÊÇ·ñ´æÔÚ

*** °æ±¾¸ñÊ½Ô¼¶¨£º

»ùÓÚÓÃ»§µÄ°ü¹ÜÀíÏµÍ³µÄ»ù±¾Ô­Àí¿ÉÒÔ²Î¿¼ LFS hints£º
More Control and Package Management using Package Users (v1.2)
http://www.linuxfromscratch.org/hints/downloads/files/more_control_and_pkg_man.txt

crablfs Copyright (c) 2006 ÖÜÅô(chowroc.z@gmail.com)

This file is part of crablfs.

crablfs is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

crablfs is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Foobar; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA"""

__version__ = '0.1'

import os
import sys
import re
import getopt
import shutil
import pwd
import grp
import time

from crablfs.plainconf import getconf, setconf
from crablfs import filetools
from crablfs import shadow

PREFIX = '/usr/local'

homepre = '/usr/src'
pkglist = '%s/packages.list' % homepre
lists = '/etc/userpack.dirs:%s/etc/userpack.dirs:directories' % PREFIX
admin = 'install'
timefmt = '%Y%m%d %H:%M:%S %a'
tartype = '.tar.gz'
PACKS_DIR = ''
uprefix = ''
options = ['homepre', 'pkglist', 'lists', 'admin', 'timefmt', 'tartype', 'PACKS_DIR', 'uprefix']
# ÓÃÓÚ²ÎÊıÓĞĞ§ĞÔĞ£Ñé
# ÀûÓÃ plainconf/xmlconf/ldapconf µÃµ½ÒÔÉÏÈ«¾ÖÅäÖÃ(Î´ÊµÏÖ)
cpforce = False
autocmd = False
# confile = '.config'
confile = ''
# pregexp = r'^(?P<pkgname>(\w+-{0,1})+)(-(?P<version>(\d[\w\.]*-{0,1})+))'
# pregexp = '^(?P<pkgname>(\w+-{0,1})+)(-(?P<version>(\d[\w]*[-\.])*\d[\w]*))'
pregexp = '^(?P<pkgname>(\w+[-\.]{0,1})+)(-(?P<version>(\d[\w]*[-\.])*\d[\w]*))'

def __init__():
	"""Ö»ÄÜ¸Ä±ä directories ÁĞ±íÖĞÖ¸Ã÷µÄÄ¿Â¼µÄÈ¨ÏŞ£¬²»ÄÜ°üÀ¨Æä×ÓÄ¿Â¼ºÍÎÄ¼ş¡£
ËùÒÔ²»ÄÜÊ¹ÓÃµİ¹é£¬Òò´ËĞèÒªÏÈ³õÊ¼»¯"""
	global lists
	for option in options:
		exec "temp = option"
		if type(temp) is not str:
			strerr = "%s: %s is not a valid option." % (program, option)
			sys.stderr.write('%s\n' % strerr)
			sys.exit(1)
	temp = lists
	lists = ''
	for dl in temp.split(':'):
		if os.access(dl, os.R_OK): lists = dl; break
	if not lists:
		strerr = "%s: No initializing directories list file found" % program
		sys.stderr.write('%s\n' % strerr) #
		sys.exit(1)

def install(user='', group='', groups=[], package='', archive='', patches=[]):
	"""°²×°Èí¼ş°ü
* ½âÎö²ÎÊıÖĞµÄ°üĞÅÏ¢£¬°üÀ¨°üÃû¡¢°æ±¾¡¢ÎÄ¼şºÍ¸½¼ÓÎÄ¼ş

* Éè¶¨²¢Ìí¼Ó×éºÍÓÃ»§£¬Èç¹ûÓÃ»§ÒÑ´æÔÚÔòÍ¨³£ËµÃ÷°üÒÑ´æÔÚ£¬Ó¦¸ÃÌáÊ¾(Î´ÊµÏÖ)
ÓÃ»§ºÍ×é¿ÉÒÔ´Ó°²×°ÅäÖÃÎÄ¼ş(profile)ÖĞ¶ÁÈ¡£¬µ«ÃüÁîĞĞ¿ÉÒÔ¸²¸ÇÖ®
ÈôÃüÁîĞĞÃ»ÓĞÖ¸¶¨£¬ÔòÊ¹ÓÃ pkgname ×÷ÎªÓÃ»§Ãû

* ÇĞ»»µ½¸ÃÓÃ»§(²ÉÓÃÊÜÏŞ shell£¿)²¢Ö´ĞĞÏàÓ¦µÄ¿½±´²Ù×÷£¬²¢½øÈë $HOME Ä¿Â¼
¼´Èç¹û²ÎÊıÖ¸¶¨ÁË¾ø¶ÔÂ·¾¶µÄ°üºÍ²¹¶¡£¬¿½±´µ½ $HOME£¬·ñÔò²éÅäÖÃĞÅÏ¢£¬×îºóÊ¹ÓÃÄ¬ÈÏ°üÃû

* ÒÔ´ËÆÕÍ¨ÓÃ»§Éú³É×Ó½ø³Ì£¬²¢ÔÚÆäº¯Êı __user_process() ÖĞÍê³ÉÓàÏÂÈÎÎñ"""
	global confile

	try:
		mo = re.match(pregexp, package)
		pkgname = mo.group('pkgname')
		version = mo.group('version')
	except AttributeError: 
	# Ã»ÓĞÆ¥Åä
		strerr = "%s: Not a valid argument, lack of package name or version" % program
		sys.stderr.write('%s\n' % strerr)
		sys.exit(1)

	# Read user/group name from profile !!! 
	uname = ''
	gname = ''
	gnames = ''
	if os.path.isfile(confile):
		try:
			config = open(confile, 'r')
			optmap = getconf(config, 'norm', 'user', 'group', 'groups')
			uname = optmap['user']
			gname = optmap['group']
			gnames = optmap['groups']
			config.close()
		except KeyError:
			pass

	if not user: 
		if uname: user = '%s' % uname 
		else: user = os.path.join(uprefix, pkgname)
	home = os.path.join(homepre, pkgname)
	# ²»Ê¹ÓÃ version ÒÔ·½±ãÉı¼¶£¬µ«×¢Òâ home ±ØĞëÊÇ pkgname
	if not group:
		if gname: group = '%s' % gname
		else: group = user
	if not groups:
		if gnames: groups = gnames.split(',')

	try:
		exists = grp.getgrnam(admin)[2]
		admin_id = exists
	except KeyError:
		strerr = "%s: No admin group %s found" % (program, admin)
		sys.stderr.write("%s\n" % strerr)
		sys.exit(1)

	gids = []
	for g in groups:
		try:
	 		exists = grp.getgrnam(g)[2]
			gids.append(exists)
		except KeyError:
	 		# strerr = "%s: No group '%s' found" % (program, g)
	 		# sys.stderr.write("%s\n" % strerr)
			gids.append(shadow.groupadd(g, 'sysadm'))

	uid, gid = shadow.useradd(user, group, [admin] + groups, home)

	if not confile:
		confile = os.path.join(home, '.config')

	if not archive:
		config = open(confile, 'r')
		optmap = getconf(config, 'norm', 'archive')
		# Ã»ÕÒµ½ÔòÄ¬ÈÏÎªÖ¸¶¨µÄ°ü£¬¼´ install ÖĞµÄ package Öµ
		archive = optmap.get('archive', archive)
		config.close()
		if not patches:
		# patches is optional
		# but the configuration must not overwrite command line parameters.
			config = open(confile, 'r')
			# ÉÏ´Î¶ÁÈ¡Ö®ºó¾Íµ½ÁËÎÄ¼şÎ²£¬¾ÍÔÙÒ²¶Á²»µ½ÅäÖÃÁË£¬ËùÒÔĞèÒªÖØĞÂ´ò¿ªÒ»´Î
			# µ±È»Õâ²»ÊÇºÃµÄ½â¾ö·½°¸£¬´ı×¨ÃÅµÄÅäÖÃ¶ÁÈ¡Ä£¿éÀ´¸ÄÉÆ
			optmap = getconf(config, 'seq', 'patch')
			patches = optmap.get('patch', patches)
			config.close()

	commands = []
	if autocmd:
		config = open(confile, 'r')
		optmap = getconf(config, 'seq', 'command')
		commands = optmap['command']
		config.close()

	pid = os.fork()
	if pid == 0:
		os.setregid(gid, gid)
		os.setgroups([gid, admin_id] + gids)
		# ±ØĞëÊôÓÚÕıÈ·µÄ×é£¬·ñÔò°²×°Ê±Ö´ĞĞ /usr/bin/install »áÓĞÎÊÌâ
		os.setreuid(uid, uid)
		os.chdir(home)
		__user_process(user, group, groups, pkgname, version, archive, patches, commands)
		# ÖÁÉÙ __user_process() ±ØĞëÊÇÒ»¸ö"Ô­×Ó²Ù×÷"
		# __user_process() ÈÎºÎ´íÎóµ½»áµ¼ÖÂÒÔ·Ç 0 ×´Ì¬ÍË³ö
		sys.exit(0)
		# ±ØĞëÍË³ö£¬²¢±£Ö¤ÕıÈ·µÄÍË³ö×´Ì¬£¡
	else:
		status = (not os.wait()[1])
		if status:
			filetools.push_list(pkglist, '%s-%s' % (pkgname, version))
		else:
			try:
				filetools.find_list(pkglist, '%s-%s' % (pkgname, version))
				# If the item could be found, it means that the package
				# 	have been installed successfully the previous time
			except "find_list_error":
				__remove_files(pkgname)
				os.remove('%s/.files' % home)
			# É¾³ıÊ§°Üµ«ÓÉ __user_process ÔËĞĞÃüÁîÔÚÏµÍ³ÖĞ²úÉúµÄ²ĞÓàÎÄ¼ş
			# ÒÔ±£Ö¤²Ù×÷µÄÔ­×ÓĞÔ
			# µ«Èç¹ûÊÇ¸²¸Ç°²×°Ôò²»ÄÜÉ¾³ı
			# *** ×îºÃÊÇ¶Ô install ¾Í½ûÖ¹¸²¸Ç°²×°£¬½» upgrade Íê³É£¿ ***
			sys.exit(1)
			# Èç¹ûÓÉ crablfs µ÷ÓÃ£¬ÔòĞèÒª¸æÖªÊ§°Ü£¬ÒÔÖÕÖ¹ crablfs

def __user_process(user, group, groups, pkgname, version, archive, patches=[], commands=[]):
	"""×Ó½ø³Ì£º
* ¼ÇÂ¼Ïà¹ØµÄ°üĞÅÏ¢µ½ÏàÓ¦µÄÅäÖÃĞÅÏ¢ÎÄ¼ş

* °üĞÅÏ¢Ó¦¸Ã°üº¬´´½¨Ê±¼ä

* Ìí¼Ó¸Ã°üÃûµ½ÁĞ±íÎÄ¼ş pkglist

* ´ò¿ªÒ»¸ö½»»¥Ê½ÃüÁîĞĞ½âÊÍÆ÷£¬Ö´ĞĞ°²×°ÃüÁî²¢½«ÃüÁî¼ÇÂ¼µ½ÅäÖÃĞÅÏ¢ÎÄ¼şÖĞ

* ¿ÉÍ¨¹ı²ÎÊıÖ¸¶¨Ê¹ÓÃÅäÖÃĞÅÏ¢ÎÄ¼şÊ¹ÓÃ·Ç½»»¥°²×°Ä£Ê½

*** ×îµÍÒªÇó£º__user_process() ±ØĞëÊÇÒ»¸ö"Ô­×Ó²Ù×÷"£¬×îºÃ install() Ò²ÊÇ£¡
ÕâÒâÎ¶Õâ¶Ô pkglist µÄÔö¼Ó±ØĞëÔÚ __user_process ³É¹¦Ê±²ÅÄÜ½øĞĞ
Èç¹û install() ÊÇÔ­×Ó²Ù×÷£¬ÔòĞèÒªÆäÏàÓ¦Ôö¼ÓµÄÓÃ»§±»É¾³ı£¬ÆäÊµÏÖÏà¶ÔÀ§ÄÑ

* Îª´ïµ½ÉÏÊöÔ­×Ó²Ù×÷µÄÒªÇó£¬Ôò __user_process ÈÎºÎ³ö´í¶¼±ØĞëµ¼ÖÂ¸Ã(×Ó)½ø³ÌÒÔ·Ç 0 ×´Ì¬ÍË³ö"""
	home = '%s/%s' % (homepre, pkgname)
	# cmdline ¿ÉÄÜ»á chdir£¬µ« .config ±ØĞëĞ´ÔÚ $HOM ÏÂÃæ£¬ËùÒÔÒªÓÃµ½ home. 
	global confile
	if os.path.isfile(confile):
		confile = __get_copy(confile, '.config')
	#	'$HOME/.config' for example.
	# *** ÔõÑùÅĞ¶Ï confile µÄÓĞĞ§ĞÔ£¿***
	# Èç¹û¶Á²»µ½ÅäÖÃ£¬Ôò optmap Î´¿Õ£¬±ØÈ»»áÅ×³ö KeyError£¬¾Í¹»ÁË

	archive = os.path.join(PACKS_DIR, archive)
	archive = __get_copy(archive)
	for i in range(len(patches)):
		file = patches[i]
		file = os.path.join(PACKS_DIR, file)
		patches[i] = __get_copy(file)

	from crablfs.cmdline import cmdline
	instcli = cmdline()
	success = 1
	if not autocmd:
		instcli.cmdloop()
		success = instcli.success
		if not success:
			strerr = "%s: installation failed or terminated" % program
			print >> sys.stderr, strerr
			sys.exit(1)
	else:
		if not commands:
			strerr = "%s: No command found for noninteractive mode" % program
			print >> sys.stderr, strerr
			sys.exit(1)
		# *** When redirect output to log installation, How to print some infomations? *** 
		### fifo = '/tmp/crablfs.fifo'
		### if not os.path.exists(fifo): os.mkfifo(fifo)
		for cmd in commands:
			line = "[33mcrablfs> [32m%s[00m" % cmd
			print line
			### open(fifo, 'w').write("%s\n" % line)
			if not instcli.do_command(cmd):
				strerr = "%s: noninteractive execution failed" % program
				print >> sys.stderr, strerr
				success = 0
				sys.exit(1)
		### os.remove(fifo)

	# Writing profile must be after 'commit'
	config = open('%s/.config' % home, 'w')
	# 'cmdline' maybe chdir£¬so specify 'home' here
	# *** Whether adding file lock is necessary? ***
	setconf(config, 'w', user=user, group=group, groups=','.join(groups), pkgname=pkgname, version=version, archive=archive)
	for patch in patches: setconf(config, 'a', patch=patch)
	# configuration path prefix !!!!!!
	for cmd in instcli.commands:
		setconf(config, 'a', command=cmd)
		# *** ÃüÁîµÄË³ĞòÔÚÅäÖÃÎÄ¼şÖĞÈçºÎ±íÏÖ£¿ ***
	setconf(config, 'a', time=time.strftime(timefmt, time.localtime()))
	config.close()

	__list_files(pkgname, record=1)
	# record all files to '$HOME/.files' for future manipulations
	print "[32minstallation success[00m"

def __get_copy(fsrc, rename=''):
	"""¿½±´µ½±¾µØµ±Ç°¹¤×÷Ä¿Â¼£¬¼´Ã¿¸ö°üµÄ HOME Ä¿Â¼"""
	rtv = os.path.basename(fsrc)
	if (not os.path.exists(rtv)) or cpforce:
		from crablfs import filetrans
		fto = filetrans.build(remote=fsrc)
		fto.getfile(force=cpforce)
	if rename:
		shutil.move(rtv, rename)
		rtv = rename
	os.chmod(rtv, 0664)
	return rtv

def __remove_files(pkgname):
	allfiles = __list_files(pkgname)
	topfiles = __find_topdirs(allfiles)
	for file in topfiles:
		try:
			if os.path.isdir(file):
				shutil.rmtree(file)
			else:
				os.remove(file)
		except OSError, (errno, errstr):
			strerr = "%s: remove file faild: %d, %s" % (program, errno, errstr)
			sys.stderr.write("%s\n" % strerr)

def remove(pkgname, version):
	try:
		# try:
		home = os.path.join(homepre, pkgname)
		filetools.find_list(pkglist, '%s-%s' % (pkgname, version))
		filetools.pull_list(pkglist, '%s-%s' % (pkgname, version))
		# find_list() »áÖ´ĞĞ²éÑ¯ÒÔ¼ì²âÒ»¸öÌõÄ¿ÊÇ·ñ´æÔÚ
		# Èç²»´æÔÚ»áÅ×³öÒì³£
		# finally:
		__remove_files(pkgname)
		os.remove('%s/.files' % home)
	except "find_list_error":
		strerr = "%s: No package %s found" % (program, package)
		print >> sys.stderr, strerr #
		sys.exit(1)
	except "pull_list_error":
		strerr = "%s: remove package item from list failed" % program
		print >> sys.stderr, strerr
		sys.exit(1)

def init(lists):
	"""³õÊ¼»¯ install ×é¼°ËùÓĞ install ĞèÒªµÄÄ¿Â¼£º¹éÈë install ×é²¢Ôö¼Ó write ºÍ sticky Î»"""
	gid = shadow.groupadd(admin, 'sysadm')

	try:
		for dir in open(lists, 'r'):
			dir = dir.strip()
			if not os.access(dir, os.F_OK):
				os.makedirs(dir)	# mkdir -p <dir>
			os.lchown(dir, -1, gid)
			os.chmod(dir, 01775)	# chmod g+w,o+t <dir>
	except (IOError, OSError), strerr:
		sys.stderr.write('%s\n' % strerr)

def list_packs():
	"""ÁĞ³öËùÓĞµÄ°ü

Èç¹ûÖ»ÊÇµ¥´¿Ê¹ÓÃ userpack À´¹ÜÀíµ¥¶ÀµÄ°ü£¬ÄÇÃ´Í¨¹ı²éÑ¯ install ×éµÄËùÓĞÓÃ»§Ò²¿ÉÒÔµÃµ½ËùÓĞµÄ°üÁĞ±í(»¹ĞèÒª²éÑ¯Ïà¹ØµÄÅäÖÃĞÅÏ¢ÎÄ¼ş)¡£µ«¿¼ÂÇµ½ LFS ÅúÁ¿´¦Àí(crablfs)ºÍÇ¨ÒÆµÄĞèÒª£¬Ò»¸öÊµÔÚµÄÎÄ±¾»áÓĞ¸ü¶àµÄºÃ´¦¡£

¶øÇÒÈç¹ûµ¥´¿ÀûÓÃ install ×é£¬ÔòÒªÇó install() ÊÇÔ­×Ó²Ù×÷"""
	try:
		for line in open(pkglist, 'r'):
			line = line.strip()
			print line
	except IOError, (errno, errstr):
		strerr = "%s: No packages list found: %d, %s" % (program, errno, errstr)
		sys.stderr.write("%s\n" % strerr)
		sys.exit(1)

def __list_files(pkgname, record=0):
	home = os.path.join(homepre, pkgname)
	tmpl = open(lists, 'r').readlines()
	tmpl.sort()
	# ÒÔÏÂÕÒ³öËùÓĞµÄ¶¥¼¶Ä¿Â¼ÒÔ½øĞĞ±éÀú
	topdirs = __find_topdirs(tmpl)
	config = open('%s/.config' % home, 'r')
	optmap = getconf(config, 'norm', 'user', 'group')
	user = optmap['user']
	group = optmap['group']
	config.close()
	allFiles = []
	if os.path.isfile('%s/.files' % home) and not record:
		for file in open('%s/.files' % home, 'r'):
			allFiles.append(file.strip())
		return allFiles
	dotfiles = open('%s/.files' % home, 'w')
	for dir1 in topdirs:
		if not os.path.isdir(dir1):
			strerr = "[31m%s is not a valid directory[00m" % dir1
			sys.stderr.write("%s\n" % strerr)
			continue
		# for root, dirs, files in os.walk(dir1):
		FIND = "find %s -path %s -prune -o -user %s -a -print" \
			% (dir1, homepre, user)
		for file in os.popen(FIND):
			dotfiles.write("%s" % file)
			file = file.strip()
			allFiles.append(file)
	dotfiles.close()
	uid = pwd.getpwnam(user)[2]
	gid = grp.getgrnam(group)[2]
	os.lchown('%s/.files' % home, uid, gid)
	return allFiles

def list_files(pkgname, version, force=0):
	"""ÁĞ³öÄ³¸ö°üËùÓĞµÄÎÄ¼şºÍÄ¿Â¼"""
	try:
		# if not version:
		#	config = open('%s/.config' % home)
		#	optmap = getconf(config, 'norm', 'version')
		#	version = optmap['version']
		#	config.close()
		filetools.find_list(pkglist, '%s-%s' % (pkgname, version))
		for file in __list_files(pkgname, force): print file
	except "find_list_error":
		strerr = "%s: No package %s found" % (program, package)
		print >> sys.stderr, strerr
		sys.exit(1)

def __find_topdirs(tmpl):
	topdirs = []
	dir1 = ''
	for item in tmpl:
		item = item.strip()
		if not os.path.exists(item):
			strerr = "%s: [31m%s is not a valid file or directory[00m" % (program, item)
			sys.stderr.write("%s\n" % strerr)
			continue
		if not dir1:
			if item == '': continue #
			dir1 = item; topdirs.append(dir1)
		elif dir1 in item:
			continue
		elif item in dir1:
			dir1 = item; topdirs[-1] = dir1
		else:
			dir1 = item; topdirs.append(dir1)
	return topdirs

def find_owner(fname):
	"""ÕÒ³öÄ³¸öÎÄ¼şËùÊôµÄ°ü"""
	try:
		uid = os.stat(fname)[4]
		user = pwd.getpwuid(uid)[0]
		home = pwd.getpwuid(uid)[5]
		config = open('%s/.config' % home, 'r')
		optmap = getconf(config, 'norm', 'pkgname', 'version')
		pkgname = optmap['pkgname']
		version = optmap['version']
		config.close()
		print '%s-%s' % (pkgname, version)
		strerr = ''
	except OSError, (errno, errstr):
		strerr = "%s: %d, %s" % (fname, errno, errstr)
	except IOError:
		strerr = "No configuration file found: %s/.config" % home
		strerr = "This file may not be under the control of %s:\n\t%s" % (program, strerr)
	except KeyError, ostr:
		strerr = "No such configuration option: %s" % ostr
	if strerr:
		strerr = "%s: No package owner found:\n\t%s" % (program, strerr)
		sys.stderr.write("%s\n" % strerr)
		sys.exit(1)

def __parse_name(package):
	try:
		mo = re.match(pregexp, package)
		pkgname = mo.group('pkgname')
		version = mo.group('version')
		return pkgname, version
	except AttributeError:
		strerr = "%s: %s is an invalid package name" % (program, package)
		print >> sys.stderr, strerr
		sys.exit(1)

if __name__ == '__main__':
	program = os.path.basename(sys.argv[0])
	usage = """program usage: %s ACTION [OPTIONS] PACKAGE/FILENAME
	OPTIONS:
	-u $user, °²×°Ê±Ö¸¶¨ÓÃ»§
	-g $group, °²×°Ê±Ö¸¶¨×é
	-d|--home-prefix $homepre, ËùÓĞ°üÓÃ»§ HOME Ä¿Â¼µÄÇ°×ºÄ¿Â¼
	-s|--home-source $homesrc, ÓµÓĞÓë crablfs HOME ÏàÍ¬Ä¿Â¼½â¹¹µÄÇ°×ºÄ¿Â¼
	-f|--archive $archive, °²×°Ê±Ö¸¶¨Êµ¼ÊµÄ°ü£¬Ä¬ÈÏÔÚ $homepre/$PACKAGE
	-p|--patch $patch [-p $patch2 ...], °²×°Ê±Ö¸¶¨²¹¶¡ÎÄ¼ş£¬Ä¬ÈÏÔÚ homepre/$PACKAGE
	-c|--profile $file, Ö¸¶¨ÅäÖÃĞÅÏ¢ÎÄ¼ş
	-o option=value, ÓÃÀ´¸Ä±äÈç homepre ÕâÑùµÄÅäÖÃ²ÎÊı
	-a|--auto£¬±íÊ¾Ä¬ÈÏ´Ó $HOME/.config ¶ÁÈ¡ÅäÖÃ(Ö´ĞĞÃüÁî)
	-h, ´òÓ¡ÕâÌõ°ïÖúĞÅÏ¢
	-C|--copy-force, Èç¹û¹éµµÎÄ¼ş»ò²¹¶¡ÒÑ´æÔÚ£¬Ôò¸²¸ÇÖ®""" % program
	location = os.path.dirname(sys.argv[0])
	# os.chdir(location)
	usage_en = """program usage: %s ACTION [OPTIONS] PACKAGE/FILENAME
	OPTIONS:
	-u $user, specify user name while install
	-g $group, specify group name while install
	-G $groups, specify other groups the user belogs to
	-d|--home-prefix $homepre
		the prefix to the abs path of all package users' HOME
	-s|--home-source $homesrc
		the directory tree that has same struct as $homepre
	-f|--archive $archive
		.tar.bz2 or .tar.gz compressed source code archive
	-p|--patch $patch [-p $patch2 ...]
		any supplementary files for installation, such patches
	-c|--profile $file
		appoint the installation profile, usually for noninteractive mode
	-a|--auto, noninteractive mode
	-h, print this help message
	-C|--copy-force
		if the archive or patches exists, cover it up""" % program
	if os.environ['LANG'] not in ['zh', 'zh_CN', 
		'zh_CN.GB2312', 'zh_CN.GB18030', 'zh_CN.UTF-8', 'zh_CN.GBK']:
		usage = usage_en

	argv = sys.argv
	try:
		opts, args = getopt.gnu_getopt(argv[2:], 'u:g:G:d:s:f:p:c:o:ahC',
		[
			'home-prefix', 'home-source', 
			'archive', 'patch', 'confile',
			'auto', 'copy-force'
		])

		user = ''
		group = user
		groups = []
		package = ''
		archive = ''
		patches = []
		actions = [ 'install', 'reset', 'upgrade', 'remove', 'init', 'packs', 'files', 'info', 'owner', 'help' ]
		SHORTS = [ 'i', 'R', 'u', 'r', '0', 'a', 'l', 'L', 'I', 'o' ]
		# 'reset' means rebuild a package with new characterastics with new libraries dependencies
		homesrc = ''

		if len(argv) > 1 and (argv[1] in actions or argv[1] in SHORTS):
			action = argv[1]
		else:
			strerr = "Please clarify the action: %s" % ', '.join(actions)
			sys.stderr.write('%s\n' % strerr)
			print usage
			sys.exit(1)

		for o, v in opts:
			if o == '-u':	user = v
			elif o == '-g':	group = v
			elif o == '-G': groups = v.split(',')
			elif o == '-d' or o == '--home-prefix':
				if not autocmd:
					print "change home prefix may cause problems, contnue?(n/y)"
					if raw_input() != 'y': sys.exit(1)
				# At least a warning message is necessary!!!
				# *** Or move and change all things for user automatically??? ***
				homepre = v
				pkglist = '%s/packages.list' % homepre
			elif o == '-s' or o == '--home-source':
				homesrc = v
				# ·½±ãÏµÍ³Ç¨ÒÆ£¬ÕâÒâÎ¶ÕâÒÔÇ°»òËûÈËµÄÏµÍ³¿ÉÒÔÖ±½ÓÄÃÀ´
				# °üÀ¨·ÖÀàµÈ´óÁ¿ĞÅÏ¢²»ÓÃÖØĞÂÉè¶¨
				# ½ÓºÏ crablfs script
			elif o == '-f' or o == '--archive': #
				archive = os.path.abspath(v)
			elif o == '-p' or o == '--patch':
				patches.append(os.path.abspath(v))
			elif o == '-c' or o == '--profile':
				confile = os.path.abspath(v)
			elif o == '-o': # ÓÃ plainconf µÄº¯ÊıÊµÏÖ(Î´ÊµÏÖ)
				try:
					option, value = re.split('\s*=\s*', v)
					# Ê¹ÓÃ plainconf Ä£¿éÏñ¶ÁÈ¡ÅäÖÃÒ»ÑùÀ´´¦Àí£¿
					if option not in options:
						strerr = "%s is an invalid option, skip it." % option
						sys.stderr.write('%s\n' % strerr)
						# sys.exit(1)
					value = value.strip('"\'')
					# Make value support "" or '' quotation for some especial conditions
					exec "%s = '%s'" % (option, value)
				except ValueError, strerr:
					if strerr == "unpack list of wrong size":
						strerr = "Format error, must be: option=value, skip"
					sys.stderr.write('%s\n' % strerr)
			elif o == '-a' or o == '--auto':
				autocmd = True
			elif o == '-C' or '--copy-force':
				cpforce = True
			elif o == '-h':
				print usage
				sys.exit(0)

		try:
			package = args[0]
		except IndexError:
			if action in ['install', 'i']:
				if archive:
					package = os.path.basename(archive)
				else:
					strerr = "Can't get package name: pkgname-version"
					print >> sys.stderr, strerr
					sys.exit(1)
			elif action in ['upgrade', 'remove', 'files', 'u', 'r', 'l']:
				strerr = "Please give the package name: pkgname-version"
				print >> sys.stderr, strerr
				# print usage
				sys.exit(1)
			elif action in ['owner', 'o']:
				strerr = "No file name is given to find the package owner"
				print >> sys.stderr, strerr
				sys.exit(1)

		__init__()
		if action in ['install', 'i']:
			if homesrc:
				pkgname, version = __parse_name(package)
				temp = os.path.join(homesrc, pkgname)
				PACKS_DIR = os.path.abspath(temp)
				temp = os.path.join(PACKS_DIR, '.config')
				confile = os.path.abspath(temp)
			install(user, group, groups, package, archive, patches)
		elif action in ['init', '0']:
			init(lists)
		elif action in ['remove', 'r']:
			pkgname, version = __parse_name(package)
			remove(pkgname, version)
		elif action in ['packs', 'a']:
			list_packs()
		elif action in ['files', 'l', 'L']:
			pkgname, version = __parse_name(package)
			if action == 'L':
				list_files(pkgname, version, 1)
			else:
				list_files(pkgname, version)
		elif action in ['owner', 'o']:
			fname = package
			find_owner(fname)
			
	except getopt.GetoptError, goEx:
		strerr = 'getopt error: %s, %s' % (goEx.opt, goEx.msg)
		sys.stderr.write('%s\n' % strerr)
		sys.exit(1)
# 
