Title: Frequently Asked Questions

If a question is missing you can "contact me":/contact.html about it and I'll answer.

h3.  What is Lamson?

Lamson is a pure Python SMTP server designed to create robust and complex mail
applications in the style of modern web frameworks such as Django. Unlike
traditional SMTP servers like Postfix or Sendmail, Lamson has all the features
of a web application stack (ORM, templates, routing, handlers, state machines,
Python) without needing to configure alias files, run newaliases, or
juggle tons of tiny fragile processes. Lamson also plays well with other web
frameworks and Python libraries.


h3. Where does the name "Lamson" come from?

"Lamson Tubes" is a colloquial name for Pneumatic Tubes which were used last century to 
deliver mail, packages, and hazardous material to the corporate world.  They are still
in use today.


h3. What kind of applications do you envision being built on top of Lamson?

Why, spam of course. As well as spam fighters, greylisters, "campaign
management" applications, mail firewalls, mime strippers (for those Exchange
file shares), help desk support applications, games, mailing lists ('cause
everyone loves writing those), and even SMTP portions of just about any web
site.


h3.  How do I report a BUG/Feature/Question in Lamson?

Best thing to do is to post your bug to the Bugs URL on the Launchpad project page:

"https://bugs.launchpad.net/lamson":https://bugs.launchpad.net/lamson

If you have a feature request, you are better off branching Lamson and working
on the request. Years of open source experience has taught me to never trust
people bearing ideas and no code.


h3.  How do I work on Lamson?

Lamson is currently very small, so read through the code and tell me any ideas
you have. When working on the project, keep the following things in mind:

# Keep things small. If you even think about Greenlets, Twisted, factory patterns, XML, or Java then you are doing it wrong.
# Write as many unit tests as you can, especially if you add a feature.
# Follow the Python style guidelines without being stupid about it.

Other than that, feel free to branch and notify me about changes you've
got.


h3. How do I run the sample application? 

Read the "quick start":/docs/getting_started.html documentation for 
an introduction to starting your own Lamson application and playing
with the various samples.


h3. How do I try out (install) Lamson? 

Best way to do it is to have easy_install and simply do:

<pre>
$ sudo easy_install lamson
</pre>

Then you'll get it installed and can play with it.  Refer to the
"getting started":/docs/getting_started.html documentation for
more information.


h3.  How can I get the code to Lamson?

Lamson lives on Launchpad at "https://launchpad.net/lamson":https://launchpad.net/lamson where you can get the code via:

<pre>
bzr branch lp:lamson
</pre>

Bazaar may ask you to login, but it should still give you the source.

Refer to the "download instructions":/download.html for more information.

h3. What features are planned for the 1.0 release?

I try to make "1.0" what most other people would consider 80% complete.
This let's people get it and work with it, and then I can refine it
for the 2.0 release with 100% of features people actually use.

With this in mind, I'm planning on the 1.0 release to be based on the sample
applications and my own applications and include the smallest set of features.

The most important part of the 1.0 release will be good documentation and 
bug free high quality code.


h3.  What are Lamson's current features?

Lamson is nearly fully capable, having been used to implement about three
applications and a few samples.  It supports running as a relay, a proxy,
and process messages off a queue.  With these options it should deploy
for most people and be usable right away.

It also has these high level features:

* Get an application going quickly with the "lamson gen" command.
* Full set of documented commands for managing and developing a lamson
application.
* Lots of documentation with more to come.
* Sample applications for you to base your work on.
* Handle mail for arbitrary hosts and addresses using simple regex routing.
* Process requests including full access to Python's complete MIME email libraries.
* Routing requests in a standard web application framework style based on addresses.
* Processing mail messages (requests) in either simple generic handlers, or in more complex and robust state machines.
* The state in statemachines is stored in your ORM layer without much work.
* Full access to SQLAlchemy for ORM or Mako for templates.
** You aren't required to use SQLAlchemy except for FSM states, and you can use
any templates you like.  These are just choices made for convenience.
* Craft and send plain text or HTML email including attachments.
* Defer processing to Maildir queues for offline handling of bigger tasks.
* Extensive logging and development tools for debugging your email applications.


h3. Isn't Postfix/Sendmail/Exim Faster?

That is a tough question to answer actually.  If all you need to
do is receive and deliver email then a well established traditional
email server like Postfix or Exim (please don't use Sendmail) is
the way to go.  Hands down these servers are the fastest and the best
at this job.

However, if you need to actually do something smart with your email,
like manage many mailing lists or handle support requests, then
these servers are definitely slower. 

The reason is they require that you configure them to take messages they've
already received and hand them to a separate process like a Perl, Python, or
Ruby script.  This separate process then has to parse the message *again*, do
its job without stepping on any other processes that might be running (that
means locks), and then send response messages back to the server for
even more SMTP parsing.

With the tripple and sometimes quadruple MIME parsing, the heavy weight 
processes, the difficult to manage locking, and the additional configuration
headaches, there's no way traditional mail servers beat Lamson in speed.

Lamson only processes a message once, maybe twice if you defer to a queue.
Once the message is parsed you get full access to Python immediately, without
spawning a separate process.  Even if you defer to a queue, the Lamson dequeue 
server stays resident and processes the queue without forking.  You can even
run many dequeue servers on mulitple machines processing a shared Maildir if 
you need the extra processing.

In the end, threads and function calls beats processes and pipes.


h3.  Why not use Sendmail's Milter?

Sendmail has a protocol named "Milter" that lets you write a mail
processing server that acts as a sort of "slave" to the sendmail
process.  This protocol is supported by at least Postfix as well,
maybe other servers.

Feel free to go try Milter.  When you're done trying to figure out
the protocol from the dense C code, configure the m4 macros, find
a decent milter protocol library that doesn't involve installing
sendmail, and debugging the final setup, then you can come back
and have it easy with Lamson.


h3.  Why does Lamson send messages to a relay host?

Lamson doesn't have to deliver to a relay host, but it is a smarter
more practical use of the technology. 

Lamson is written in Python and does actually run slower than the established
mail servers.  In addition, Lamson is hopefully doing something more than just
routing email around to people.  It is probably processing messages, crafting
replies, querying databases, hitting REST interfaces, and all the other
things you'd want to do with a modern application.  This takes time and
resources and are probably more valuable operations than just simple
delivery.

For this reason, you want to use a dumb workhorse like Postfix to do your
actual delivery, and reserve the smart processing that has value for
Lamson.


h3. What about security?!  Shouldn't Lamson be 20 processes?

Have you ever asked why other mail servers are a bundle of a billion
processes?  Why have one server receiving mail, another routing it, and
another handing it to users?

The answer is back in the 1970's most mail was delivered to Unix users in their
home directories or similar files that required special access rights to modify.
Also in the 1970's special ports like 25 for SMTP required root access, which in
the tiny Internet of the time meant that the server could be "trusted".  These
two realities of the time meant that to receive and deliver mail at least some
part of the system had to run as root.  To keep things safe, modern mail systems
reduce the amount of time spent as the root user by separating their
functionality into different processes.

However, if you never have to deliver to a user, and all you ever do is
process mail and talk to other servers like RDBMS, then why do you need
all this privilege separation?  Sites run just fine with systems running
as one or two processes without the complexity of some illogical privilege
separation getting in their way.

To put this into perspective, imagine that you were writing a Django application
and you were required to have a separate process for the HTTP layers, the view
layer, the model layer, the HTTP responses, and the RDBMS access layers?  Each
one required a different user, a different configuration file, and you needed
another process just to keep them all sane.  All of this just so that if someone
hacks into your HTTP server as root they supposedly can't cause any damage.

Yet, they are on your server as root after all.

In practice, you can run Lamson as a separate root process, and then use another
"dequeue server" to do the real processing, if you feel you need that security.

But, consider delaying that decision until you absolutely need it, because the
security benefits aren't worth the development and deployment hassles.

h3. How come nobody thought of this before?

I don't know why, since it did seem kind of simple.  There's at least one other
project written in Perl called "qpsmtpd":http://smtpd.develooper.com/ that does
something similar, and there may be more.  If you know others feel free to
"contact me":/contact.html and let me know.


