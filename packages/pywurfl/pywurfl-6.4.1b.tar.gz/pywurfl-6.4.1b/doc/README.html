<html>
    <head>
        <title>WURFL and Python</title>
        <style>
            .definition {
                border: thin solid silver;
                background-color: #c8cced;
                padding: 5px;
            }
            a {
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            h1, h2 {
                text-decoration: underline;
            }
            .pyfile {
                color: #0f0f0f;
            }
            .cmdline {
                background-color: #ebf4f1;
                padding-left: 1em;
                padding-right: 1em;
                border: thin solid silver;
            }
        </style>
    </head>
    <body>
        <h1>WURFL and Python</h1>
        <h4>by Armand Lynch (lyncha at users dot sourceforge dot net)</h4>
        <div class="intro"><a href="api/index.html">pywurfl</a> is a <a href="http://www.python.org">Python</a> language package that makes dealing with the <a href="http://wurfl.sourceforge.net/">WURFL</a> in <a href="http://www.python.org">Python</a> a little easier. It contains tools that allow you to retrieve objects that represent devices defined in the <a href="http://wurfl.sourceforge.net/">WURFL</a> or manipulate the WURFL device hierarchy by using a simple set of API functions or a <a href="api/index.html">pywurfl</a> specific <a href="#query">query language</a>. Also included within the package is a <a href="http://wurfl.sourceforge.net/">WURFL</a> <a href="#processor">processor</a> class that provides an event based API that can be used to alleviate some of the work when processing the <a href="http://wurfl.sourceforge.net/">WURFL</a> sequentially.</div>

        <h2>License</h2>
        <p>pywurfl is Copyright 2004-2009, Armand Lynch (lyncha at users dot sourceforge dot net)<br/>
        The code is free software; you can redistribute it and/or modify it under the terms of the <a href="http://www.opensource.org/licenses/lgpl-license.php">LGPL License</a> (see the file LICENSE included with the distribution).</p>

        <h2>Requires</h2>
        <p><a href="http://www.python.org">Python</a> &gt;= 2.4</p>

        <h2>Required Modules</h2>
        <a href="http://effbot.org/zone/element.htm">ElementTree or cElementTree</a> (if <a href="http://www.python.org">Python</a> &lt; 2.5)<br/>
        </p>

        <h2>Optional Modules</h2>
        <p><a href="http://celljam.net/downloads/pywurfl/python-Levenshtein-0.10.1.tar.gz">Levenshtein Module</a> &gt;= 0.10.1 is required if you want to use the Levenshtein distance or Jaro-Winkler algorithms for user agent similarity.<br/>
        <p><a href="http://pyparsing.wikispaces.com/">pyparsing</a> &gt;= 1.4.10 is required if you want to use the <a href="api/index.html">pywurfl</a> <a href="#query">query language</a>.<br/></p>

        <h2>Scripts</h2>
        <p>The <a href="api/index.html">pywurfl</a> package contains a <span class="pyfile">wurfl2python.py</span> script that translates a WURFL compatible XML file into a python class hierarchy that the pywurfl API can use directly. The default name for the output file is <span class="pyfile">wurfl.py</span>. Type the following at the command line to produce it:
        <div class="cmdline">python <span class="pyfile">wurfl2python.py</span> wurfl.xml</div>
        </p>
            
        <h2>A quick usage example</h2>
        <p>After you have created the <span class="pyfile">wurfl.py</span> module, you can use the following code to get a device object based on a user agent and print it to stdout.</p>

<div class="highlight"><pre><span class="k">from</span> <span class="nn">wurfl</span> <span class="k">import</span> <span class="n">devices</span>
<span class="k">from</span> <span class="nn">pywurfl.algorithms</span> <span class="k">import</span> <span class="n">JaroWinkler</span>

<span class="n">user_agent</span> <span class="o">=</span> <span class="s">&quot;Nokia3350/1.0 (05.01)&quot;</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_ua</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="n">JaroWinkler</span><span class="p">(</span><span class="n">accuracy</span><span class="o">=</span><span class="mf">0.85</span><span class="p">))</span>

<span class="c"># Print out the specialized capabilities for this device.</span>
<span class="k">print</span> <span class="n">device</span>
</pre></div>
            
        <p>That's it.</p>

        <a name="api"></a>
        <h2>pywurfl API</h2>
        <p>To get an object that represents a device, you can use one of 2 methods of the 'devices' object imported from the wurfl.py module.</p>

        <h5 class="definition">select_id(string, [actual_device_root=False], [instance=True])</h5>
        <p>This method returns a device object based on the <a href="http://wurfl.sourceforge.net">WURFL</a> ID provided.</p>
        <p>If actual_device_root is True then the select_id method will return the requested device or a device in its fallbacks if it is an actual device.</p>
        <p>If instance is False then the select_id method will return a class object instead of an instance.</p>

        <h5 class="definition">select_ua(string, [actual_device_root=False], [filter_noise=True], [search=False], [instance=True])</h5>
        <p>This method returns a device object based on the user agent provided.</p>
        <p>If actual_device_root is True then the select_ua method will return the requested device or a device in its fallbacks if it is an actual device.</p>
        <p>If filter_noise is True then the user agent will have most noise strings removed before it is tested against the <a href="http://wurfl.sourceforge.net">WURFL</a>. Noise strings are those that are added by gateways or serial numbers that are not included in the <a href="http://wurfl.sourceforge.net">WURFL</a>.</p>
        <p>The search argument takes an instance of pywurfl.algorithms.Algorithm. At this time, only three algorithms are provided: Tokenizer, Levenshtein distance and JaroWinkler. The Tokenizer is the most common algorithm used for determining the similarity between two user agents. I think that the Jaro-Winkler algorithm is much nicer and provides better accuracy than the Tokenizer. You decide.</p>
        <p>If instance is False then the select_ua method will return a class object instead of an instance.</p>

        <h3>More API methods</h3>
        <p>There are a few more methods that you can use on the 'devices' object to manipulate the device class hierarchy itself.
        </p>
        <h5 class="definition">add(parent, devid, devua, [actual_device_root=False], [capabilities=None])</h5>
        <h5 class="definition">add_capability(group, capability, object)</h5>
        <h5 class="definition">add_group(group)</h5>
        <h5 class="definition">insert_after(parent, devid, devua, [actual_device_root=False], [capabilities=None])</h5>
        <h5 class="definition">insert_before(child, devid, devua, [actual_device_root=False], [capabilities=None])</h5>
        <h5 class="definition">remove(devid)</h5>
        <h5 class="definition">remove_capability(capability)</h5>
        <h5 class="definition">remove_group(group)</h5>
        <h5 class="definition">remove_tree(devid)</h5>
        <p>
        Here's an example
        </p>
<div class="highlight"><pre><span class="k">from</span> <span class="nn">wurfl</span> <span class="k">import</span> <span class="n">devices</span>

<span class="c"># Add a new device</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;generic&#39;</span><span class="p">,</span>
            <span class="s">&#39;teledev1&#39;</span><span class="p">,</span>
            <span class="s">&#39;Mozilla/25.0 (X11; U; Linux i686; en-US; rv:25.0.0) Gecko/21000711 Firefox/28.1.5&#39;</span><span class="p">,</span>
            <span class="n">actual_device_root</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Add a new capability group</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_group</span><span class="p">(</span><span class="s">&#39;teleporter&#39;</span><span class="p">)</span>

<span class="c"># Add some capabilities to the teleporter group</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_capability</span><span class="p">(</span><span class="s">&#39;teleporter&#39;</span><span class="p">,</span> <span class="s">&#39;teleportation_device&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_capability</span><span class="p">(</span><span class="s">&#39;teleporter&#39;</span><span class="p">,</span> <span class="s">&#39;distance&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="c"># in km</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_capability</span><span class="p">(</span><span class="s">&#39;teleporter&#39;</span><span class="p">,</span> <span class="s">&#39;can_recover_from_errors&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<span class="c"># Add a new device overriding a default capability value</span>
<span class="c"># Note that no devices had a &#39;teleportation_device&#39; attribute until we added it</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;teledev1&#39;</span><span class="p">,</span>
            <span class="s">&#39;teledev2&#39;</span><span class="p">,</span>
            <span class="s">&#39;Mozilla/25.0 (X11; U; Linux i686; en-US; rv:26.0.0) Gecko/21000712 Firefox/28.1.6&#39;</span><span class="p">,</span>
            <span class="n">actual_device_root</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">capabilities</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;teleportation_device&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>

<span class="c"># Add another group and capabilities</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_group</span><span class="p">(</span><span class="s">&#39;python&#39;</span><span class="p">)</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_capability</span><span class="p">(</span><span class="s">&#39;python&#39;</span><span class="p">,</span> <span class="s">&#39;py_version&#39;</span><span class="p">,</span> <span class="s">&quot;2.5&quot;</span><span class="p">)</span>
<span class="n">devices</span><span class="o">.</span><span class="n">add_capability</span><span class="p">(</span><span class="s">&#39;python&#39;</span><span class="p">,</span> <span class="s">&#39;py_heap_size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c"># Remove an unused group</span>
<span class="n">devices</span><span class="o">.</span><span class="n">remove_group</span><span class="p">(</span><span class="s">&#39;j2me&#39;</span><span class="p">)</span>

<span class="c"># Not interested in tiff files</span>
<span class="n">devices</span><span class="o">.</span><span class="n">remove_capability</span><span class="p">(</span><span class="s">&#39;tiff&#39;</span><span class="p">)</span>
</pre></div>

        <p>
        Check the <a href="api/index.html">documentation</a> for more information.
        </p>

        <h2>Serialization</h2>
        <p>It's also possible to serialize changes that you make to a <a href="http://wurfl.sourceforge.net">WURFL</a> compatible XML file.</p>

<div class="highlight"><pre><span class="k">from</span> <span class="nn">wurfl</span> <span class="k">import</span> <span class="n">devices</span>
<span class="k">from</span> <span class="nn">pywurfl.serialize</span> <span class="k">import</span> <span class="n">Serialize</span>

<span class="c"># Remove some groups and their capabilities from the WURFL hierarchy</span>
<span class="n">devices</span><span class="o">.</span><span class="n">remove_group</span><span class="p">(</span><span class="s">&#39;j2me&#39;</span><span class="p">)</span>
<span class="n">devices</span><span class="o">.</span><span class="n">remove_group</span><span class="p">(</span><span class="s">&#39;mms&#39;</span><span class="p">)</span>

<span class="n">Serialize</span><span class="p">(</span><span class="n">devices</span><span class="p">)</span><span class="o">.</span><span class="n">to_xml</span><span class="p">(</span><span class="s">&quot;no_j2me_or_mms.xml&quot;</span><span class="p">)</span>
</pre></div>

        <h2>Search Algorithm Classes</h2>
        <p>The algorithms module contains three algorithm classes (Tokenizer, JaroWinkler and LevenshteinDistance). When instantiating any of these classes, a callable object will be returned that can be used to search a 'devices' object with the provided user agent.</p>
        <h5 class="definition">Tokenizer([devwindow])</h5>
        <p>The devwindow argument determines the upper limit of device matches before the algorithm would return the generic device.</p>

        <h5 class="definition">JaroWinkler([accuracy=1.0], [weight=0.05])</h5>
        <p>The accuracy argument determines the lower limit at which pywurfl will determine if a user agent matches another. If no device can be found that scores equal to or greater than accuracy, a generic device is returned. Valid values are between 0.0 and 1.0</p>
        <h5 class="definition">LevenshteinDistance()</h5>


<div class="highlight"><pre><span class="k">from</span> <span class="nn">wurfl</span> <span class="k">import</span> <span class="n">devices</span>
<span class="k">from</span> <span class="nn">pywurfl.algorithms</span> <span class="k">import</span> <span class="n">JaroWinkler</span><span class="p">,</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="n">LevenshteinDistance</span>

<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">()</span>
<span class="n">jarow</span> <span class="o">=</span> <span class="n">JaroWinkler</span><span class="p">()</span>
<span class="n">levdis</span> <span class="o">=</span> <span class="n">LevenshteinDistance</span><span class="p">()</span>

<span class="n">user_agent</span> <span class="o">=</span> <span class="s">&quot;Nokia3350/1.0 (05.01)&quot;</span>
<span class="n">device1</span> <span class="o">=</span> <span class="n">jarow</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">devices</span><span class="p">)</span>
<span class="n">device2</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">devices</span><span class="p">)</span>
<span class="n">device3</span> <span class="o">=</span> <span class="n">levdis</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">devices</span><span class="p">)</span>

<span class="n">device4</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_ua</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="n">jarow</span><span class="p">)</span>
<span class="n">device5</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_ua</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="n">tokenizer</span><span class="p">)</span>
<span class="n">device6</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_ua</span><span class="p">(</span><span class="n">user_agent</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="n">levdis</span><span class="p">)</span>
</pre></div>
        <p>It's also very easy to define your own algorithm for use in pywurfl in case the algorithms provided don't serve your needs. Just subclass the pywurfl.algorithms.Algorithm class and follow the protocol.
        </p>
        
        <h2>Device Objects</h2>
        <p>The object returned by either select_id or select_ua is usually a Device instance.</p>


<div class="highlight"><pre><span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_id</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>

        <p>A device object has many attributes. The device id, user agent, fall_back and actual_device_root attributes are exposed with the following attributes of the device object:</p>


<div class="highlight"><pre><span class="n">device</span><span class="o">.</span><span class="n">devid</span>
<span class="n">device</span><span class="o">.</span><span class="n">devua</span>
<span class="n">device</span><span class="o">.</span><span class="n">fall_back</span> <span class="c"># All devices have a fall_back attribute</span>
<span class="n">device</span><span class="o">.</span><span class="n">actual_device_root</span>
</pre></div>

        <p>Any capability that is defined in the <a href="http://wurfl.sourceforge.net">WURFL</a> becomes an attribute of the device object. For example:</p>


<div class="highlight"><pre><span class="n">device</span><span class="o">.</span><span class="n">brand_name</span>
<span class="n">device</span><span class="o">.</span><span class="n">model_name</span>
<span class="n">device</span><span class="o">.</span><span class="n">ringtone</span>
</pre></div>
        <p>All attributes are converted into their respective <a href="http://www.python.org">Python</a> types. For example:</p>


<div class="highlight"><pre><span class="n">device</span><span class="o">.</span><span class="n">ringtone</span>  <span class="c"># Attribute is boolean</span>
<span class="n">device</span><span class="o">.</span><span class="n">preferred_markup</span>  <span class="c"># Attribute is a string</span>
<span class="n">device</span><span class="o">.</span><span class="n">rows</span>  <span class="c"># Attribute is an integer</span>
</pre></div>

        <p>You can iterate over a device object to select each capability and its corresponding value. For example, to print out all capabilities of a device object you can use the code below:</p>


<div class="highlight"><pre><span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">capability</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">device</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">group</span><span class="p">,</span> <span class="n">capability</span><span class="p">,</span> <span class="n">value</span>
</pre></div>

        <p>Every device has a shared groups attribute which is a Python dictionary where the keys are the capability group names as defined in the WURFL and the values are lists of the capability names for that specific group.</p>


<div class="highlight"><pre><span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">sorted</span><span class="p">(</span><span class="n">device</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">group</span>
</pre></div>

        <h3>Classes vs. Instances</h3>
        
        <p>The API methods can also return a class object instead of an instance. What wurfl2python does is produce a module that creates a single inheritance class hierarchy of all <a href="http://wurfl.sourceforge.net">WURFL</a> devices. You can use this to your advantage if you want to change the attributes of a device at run-time and have all of its descendants represent that change.</p>


<div class="highlight"><pre><span class="c"># get an arbitrary device instance</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_id</span><span class="p">(</span><span class="s">&#39;blackberry_generic_ver3_sub2&#39;</span><span class="p">)</span>

<span class="c"># get the generic device *class*</span>
<span class="n">gen</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">select_id</span><span class="p">(</span><span class="s">&#39;generic&#39;</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># modify the generic class</span>
<span class="n">gen</span><span class="o">.</span><span class="n">teleportation_device</span> <span class="o">=</span> <span class="bp">False</span>

<span class="c"># since all devices inherit from the generic device, this will not raise an attribute error now</span>
<span class="n">device</span><span class="o">.</span><span class="n">teleportation_device</span> <span class="c"># == False</span>
</pre></div>
        <p>If you want to maintain the integrity of the class hierarchy, you should use the add/remove/insert API methods on the 'devices' object mentioned above.</p>

        <a name="query"></a>
        <h2>Query Language</h2>
        <p>The <a href="api/index.html">pywurfl</a> package includes a query language that makes it easier to retrieve a list of devices, <a href="http://wurfl.sourceforge.net">WURFL</a> IDs or user agents based on the capabilities of a device. The best way to see what the query language looks like and what it can do is with an example.</p>


<div class="highlight"><pre><span class="k">from</span> <span class="nn">wurfl</span> <span class="k">import</span> <span class="n">devices</span>
<span class="k">from</span> <span class="nn">pywurfl.ql</span> <span class="k">import</span> <span class="n">QL</span>  <span class="c"># Import the query function generator</span>

<span class="c"># Retrieve a function that will query the devices object</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">QL</span><span class="p">(</span><span class="n">devices</span><span class="p">)</span>

<span class="c"># QL also adds a query method to devices (devices.query)</span>

<span class="n">q1</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select id where ringtone=true and rows &lt; 5 and</span>
<span class="s">        columns &gt; 5 and preferred_markup = &#39;wml_1_1&#39;&quot;&quot;&quot;</span>

<span class="k">for</span> <span class="n">wurfl_id</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q1</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">wurfl_id</span>


<span class="c"># Let&#39;s look for some nice phones</span>
<span class="n">q2</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select device where all(ringtone_mp3, ringtone_aac, wallpaper_png,</span>
<span class="s">        streaming_mp4) = true&quot;&quot;&quot;</span>

<span class="c"># Notice that we can also retrieve device classes</span>
<span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">devices</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">device</span><span class="o">.</span><span class="n">brand_name</span><span class="p">,</span> <span class="n">device</span><span class="o">.</span><span class="n">model_name</span>


<span class="c"># We can also use the methods on the capability types to refine our queries.</span>
<span class="c"># Note that you should *always* quote the strings that are passed to functions</span>
<span class="c"># and those that are used in comparisons.</span>
<span class="n">q3</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select ua where brand_name.lower()=&#39;nokia&#39;&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">ua</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q3</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ua</span>

<span class="n">q4</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select ua where brand_name.replace(&#39;No&#39;, &#39;Si&#39;).lower()=&#39;sikia&#39;&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">ua</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q4</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ua</span>

<span class="n">q5</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select ua where model_name.isdigit()=true and actual_device_root=true&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">ua</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q5</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ua</span>

<span class="c"># There are also a couple of regex methods (match and imatch) that were added</span>
<span class="c"># to the string type to make those kind of queries possible. Use imatch to</span>
<span class="c"># ignore case.</span>
<span class="n">q6</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select ua where brand_name.match(&#39;^No&#39;)=true&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">ua</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q6</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ua</span>

<span class="c"># and arbitrary nesting is supported</span>
<span class="n">q7</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;select ua where brand_name.replace(&#39;Nokia&#39;, brand_name.lower())=&#39;nokia&#39;&quot;&quot;&quot;</span>
<span class="k">for</span> <span class="n">ua</span> <span class="ow">in</span> <span class="n">query</span><span class="p">(</span><span class="n">q7</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ua</span>
</pre></div>

        <p>A full description of the query language is included in the <a href="api/pywurfl.ql-module.html">documentation</a>.
        </p>

        <a name="processor"></a>
        <h2>The WURFL Processor</h2>
        <p>The <a href="http://wurfl.sourceforge.net">WURFL</a> processor is a general class that walks a <a href="http://wurfl.sourceforge.net">WURFL</a> XML file and executes hooks as specific events occur in a fashion similar to SAX. The best way to understand the <a href="http://wurfl.sourceforge.net">WURFL</a> processor is to look at its <a href="api/pywurfl.wurflprocessor-module.html">documentation</a>. For an example of how to use use it, look at the source for wurfl2python.py.</p>

        <h2>Contributors</h2>
        <p>I would like to thank the following people for their contributions:</p>
        <p>Thanks <em>Pau Aliagas</em> for the many patches, bug reports and improvements.<br/>
        Thanks <em>Gabriele Fantini</em> for the many patches, bug reports and improvements.<br/>
        Thanks <em>Michele Bariani</em> for the many patches, bug reports and improvements.</p>

        </p>Comments and/or suggestions are appreciated.</p>
    </body>
</html>
