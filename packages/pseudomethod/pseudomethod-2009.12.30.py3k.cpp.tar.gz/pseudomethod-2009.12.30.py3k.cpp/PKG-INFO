Metadata-Version: 1.0
Name: pseudomethod
Version: 2009.12.30.py3k.cpp
Summary: pseudomethod - dynamically call ordinary functions as bound methods
Home-page: http://pypi.python.org/pypi/pseudomethod
Author: kai zhu
Author-email: kaizhu256@gmail.com
License: gpl
Description: pseudomethod - dynamically call ordinary functions as bound methods
        
        REQUIRES LINUX OS AND PYTHON3.1
        
        QUICK TEST: $ python3.1 setup.py build dev --quicktest
        
        DESCRIPTION: pseudomethod - dynamically call ordinary functions as bound methods
        
        SUMMARY:
        pseudomethod is a pure python module.
        pseudomethod hacks python's ast tree, adding the following syntax sugars: '..' '...' '....'
        pseudomethod can 'subclass' restricted, uninheritable python types like types.CodeType (compiled python code object)
        pseudomethod can 'flatten' ugly nested function calls by sequentially binding their return values
        
        RECENT CHANGELOG:
        20091231 - added lambda __printop__: sugar
        20091224 - added pseudomethod interactive console - revamped pseudomethod import hook
        20091224 - modularized package - fix install issues - added sdist check
        20091209 - improved documentation
        20091205 - moved source code to c++
        20091116 - package integrated
        
        DEMO USAGE:
        
        >>> from pseudomethod import *
        >>> pseudomethod_console().interact()
        
        ## dynamically bind function calls to objects
        ## bind the function call print() to 'hello'
        >>> print('hello')
        hello
        >>> 'hello' ..print()
        hello
        >>> 'hello' ..print('world')
        hello world
        >>> 'hello' ..print('world', '!')
        hello world !
        >>> 'hello' ..print('world', '!', file = sys.stdout)
        hello world !
        
        ## create a string pseudomethod which adds an exclamation or a specified string
        >>> def add_end(self, end = '!'): return self + end
        >>> 'hello' ..add_end() ..print()
        hello!
        >>> 'hello'.upper() ..add_end() ..print()
        HELLO!
        >>> 'hello'.upper() ..add_end(' world') ..print()
        HELLO world
        >>> 'hello'.upper() ..add_end(' world').lower() ..print()
        hello world
        >>> 'hello'.upper() ..add_end(' world').lower() ..add_end('!') ..print()
        hello world!
        >>> 'hello'.upper() ..add_end(' world').lower() ..add_end('!') ..add_end(end = '!') ..print()
        hello world!!
        
        ## OPERATOR PRECEDENCE - 'a..b()' has the same operator precedence as 'a.b()' which precedes <and or not + - * /> but not <= == ,>
        >>> def add(aa, bb): return aa + bb
        >>> print( 2 * 3 ..add(4) + 5 == 2 * (3 + 4) + 5 )
        True
        >>> print( 3 == 1 ..add(2) )
        True
        >>> print( 0, 0 ..add(1), 0 )
        0 1 0
        
        
        
        ## the python code object type <class 'code'> cannot be subtyped nor will it accept any method binding.
        ## however, we can extend it by dynamically binding ordinary functions.
        ## here's a pseudomethod, which disassembles an instance of the type to a specified output
        >>> import dis, io, sys
        >>> def disassemble(self, file):
        ...   backup_stdout = sys.stdout ## backup sys.stdout
        ...   try:
        ...     sys.stdout = file
        ...     dis.dis(self) ## disassemble
        ...     return file
        ...   finally:
        ...     sys.stdout = backup_stdout ## restore sys.stdout
        
        >>> code_source = 'print( "hello" )'; code_object = compile(code_source, '', 'exec'); exec( code_object )
        hello
        >>> code_object ..disassemble(file = io.StringIO()).getvalue() ..print()
        1           0 LOAD_NAME                0 (print)
        3 LOAD_CONST               0 ('hello')
        6 CALL_FUNCTION            1
        9 POP_TOP
        10 LOAD_CONST               1 (None)
        13 RETURN_VALUE
        
        
        
        
        ## '...' and '....' syntax
        ## sometimes we instead want the 2nd or 3rd argument of a function bound to an object.
        ## '...' and '....' will do this respectively
        >>> '2nd' ...print(0, 0)
        0 2nd 0
        >>> '3rd' ....print(0, 0)
        0 0 3rd
        
        ## '....' is useful for chaining re.sub
        >>> ss = 'file = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()'; print( ss )
        file = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()
        
        >>> print(
        ...   re.sub('print (.*?)$', 'print( \\1 )',
        ...          re.sub('print (.*) >> (.*?);', 'print( \\1, file = \\2 );', ss)
        ...          )
        ...   )
        file = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )
        
        >>> ss ....re.sub('print (.*) >> (.*?);', 'print( \\1, file = \\2 );') \
        ...    ....re.sub('print (.*?)$', 'print( \\1 )') \
        ...    ..print()
        file = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )
        
        ## in fact, another primary use of pseudomethod is to flatten ugly, hard-to-read, lisp-like nested function calls
        >>> print( dict( enumerate( zip( 'abc',  sorted( 'abc bca cab'.split(' '), key = lambda x: x[1] ) ) ) ) )
        {0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}
        
        >>> 'abc bca cab'.split(' ') ..sorted(key = lambda x: x[1]) ...zip('abc') ..enumerate() ..dict() ..print()
        {0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}
        
        
        
        ## import hook
        ## we can also import modules written using pseudoemethod syntax.
        ## in fact, this package makes liberal use of the pseudomethod syntax
        
        ## enable pseudomethod import hook
        >>> import pseudomethod
        >>> pseudomethod.IMPORTER.add_hook()
        pseudomethod_importer - adding hook <pseudomethod.pseudomethod_importer object at 0x9e4de8c> to sys.meta_path
        
        ## test module
        >>> open('test_module.py', 'w').write('"hello" ..print()\n"bye" ..print()\n')
        
        ## during import, add the magic prefix 'pseudomethod.' to the beginning of the module name
        >>> import pseudomethod.test_module
        hello
        bye
        
        
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: End Users/Desktop
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: GNU General Public License (GPL)
Classifier: Natural Language :: English
Classifier: Operating System :: POSIX
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: C
Classifier: Programming Language :: C++
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.1
Classifier: Topic :: Multimedia
Classifier: Topic :: Multimedia :: Graphics
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Scientific/Engineering :: Visualization
Classifier: Topic :: Software Development
Classifier: Topic :: Software Development :: Code Generators
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Utilities
