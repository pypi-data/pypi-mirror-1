#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#    Copyright (c) 2006 Allen B. Downey
#    License: GNU GPLv3
#
#    This file is coming from : http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496735
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.  See the GNU General Public License
#    for more details.
#

___author__ = 'Allen B. Downey'
__date__ = '$LastChangedDate: 2008-06-10 21:18:33 +0200 (mar, 10 jun 2008) $'
__version__ = '$Rev: 93 $'

"""
Multithreaded Python programs often ignore the SIGINT generated by a
Keyboard Interrupt, especially if the thread that gets the signal is
waiting or sleeping. This module provides a workaround by forking a
child process that executes the rest of the program while the parent
process waits for signals and kills the child process.
"""

import threading
import time
import os
import signal
import sys
import operator



class Watcher:
    """this class solves two problems with multithreaded
    programs in Python, (1) a signal might be delivered
    to any thread (which is just a malfeature) and (2) if
    the thread that gets the signal is waiting, the signal
    is ignored (which is a bug).

    The watcher is a concurrent process (not thread) that
    waits for a signal and the process that contains the
    threads.  See Appendix A of The Little Book of Semaphores.
    http://greenteapress.com/semaphores/
    """
    
    def __init__(self):
        """ Creates a child thread, which returns.  The parent
            thread waits for a KeyboardInterrupt and then kills
            the child thread.
        """
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            # I put the capital B in KeyBoardInterrupt so I can
            # tell when the Watcher gets the SIGINT
            print 'KeyBoardInterrupt'
            self.kill()
        sys.exit()

    def kill(self):
        try:
            os.kill(self.child, signal.SIGKILL)
        except OSError:
            pass

