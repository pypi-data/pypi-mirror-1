Quills browser tests
====================

Here we check for fixed bugs usins tests, that don't fit into the 'narrative' in
the main browser test. First some boilerplate to get our browser up and running:

    >>> self.setRoles(("Contributor",))
    >>> browser = self.getBrowser(logged_in=True)
    >>> browser.handleErrors = False
    >>> entry = self.weblog.addEntry("Blog entry",
    ...                              "Just for testing",
    ...                              "Nothing to see.",
    ...                              ['fishslapping'],
    ...                              id="entry")
    >>> from quills.core.interfaces import IWeblogEntry
    >>> IWeblogEntry.providedBy(entry)
    True

Make it discussable and publish it

    >>> entry = self.weblog.getEntry('entry')
    >>> entry_content = entry.getWeblogEntryContentObject()
    >>> entry_content.allowDiscussion(allowDiscussion=True)
    >>> entry.publish()

    >>> date = entry.getPublicationDate()
    >>> year = str(date.year())
    >>> month = str(date.month()).zfill(2)
    >>> day = str(date.day()).zfill(2)

    >>> self.setRoles(("Contributor", "Reviewer", "Manager"))
    >>> browser.open('http://nohost/plone/weblog/%s/%s/%s/entry' % (year, month, day))
    >>> browser.getControl('Add Comment').click()
    >>> browser.getControl('Subject').value = "Parrot"
    >>> browser.getControl('Comment').value = "Is dead. Is deceased."

Issue #111 shows that the URLs generated by the archive portlet are not correct.
Even when the weblog is not supposed to be using an extra 'archive' URL segment,
the URLs always have that segment in them.

To test this, we'll first make sure that the weblog config is setup to use the
'archive' segment for URLs.

    >>> from quills.core.interfaces import IWeblogConfiguration
    >>> config = IWeblogConfiguration(self.weblog.getWeblogContentObject())
    >>> config.archive_format = 'archive'

Now we'll get a page and check its body for the appropriate link.

    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/archive/%s/%s">'
    >>> url = url % (year, month)
    >>> url in browser.contents
    True

Now, if we change the archive_format, we should get different URLs.

    >>> config.archive_format = ''
    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/%s/%s">'
    >>> url = url % (year, month)
    >>> url in browser.contents
    True


There was an issue whereby the correct comment count didn't get shown for each
weblog entry displayed in the weblog_view.  We verify that this is no longer
the case here.

First, let's add a comment so that we know one is there.

    >>> from Products.CMFCore.utils import getToolByName
    >>> dtool = getToolByName(self.portal, 'portal_discussion')
    >>> entry_discussion = dtool.getDiscussionFor(entry_content)
    >>> comment_id = entry_discussion.createReply(title='Comment Title',
    ...                                           text='a little test body')

Now, when we look at the weblog view, we should find that there is a link to the
comments for `entry', together with a count of how many comments there are on
it.

    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/%s/%s/%s/entry#comments"'
    >>> url = url % (year, month, day)
    >>> url in browser.contents
    True
    >>> '<span>1</span>' in browser.contents
    True

>> repr(browser.contents)

This last line of test is fairly lame as it could potentially match anywhere in
the source.  An example of what we are really trying to match is the following:

"""
          <a href="http://nohost/plone/weblog/2007/09/24/entry#comments"
           style="text-decoration: none;">
          Comments:
          </a>

          <span>3</span>
"""


Issue #112 found that the recent comments portlet was generating incorrect links
to comments as it wasn't utilising the archive URL of the weblog entry objects.

    >>> txt = '<a href="http://nohost/plone/weblog/%s/%s/%s/entry#%s"'
    >>> txt = txt % (year, month, day, comment_id)
    >>> txt in browser.contents
    True


Issue #117 found that the weblog admin portlet got displayed to anonymous users,
rather than being restricted to admin-ish users.  Let's verify that this is no
longer the case.

    >>> self.setRoles([])
    >>> browser = self.getBrowser(logged_in=False)
    >>> browser.handleErrors = False
    >>> browser.open('http://nohost/plone/weblog/')
    >>> 'portletWeblogAdmin' in browser.contents
    False


Issue #143: Portlets do not show up in empty blogs
--------------------------------------------------

This issue is caused by the way BasePortletRenderer implements ``available``.

We do not use one of Quills' portlet here but make our own, as the problem
is located in BasePortletRenderer.

    >>> from plone.app.portlets.portlets import base
    >>> from quills.app.portlets.base import BasePortletRenderer
    >>> class TestRenderer(BasePortletRenderer, base.Renderer):
    ...     """A simple Renderer"""
    ...     pass

Now create a blog. And see if we can get our portlet renderer. We first try
with an empty blog. This a bit overly complicated because this test must work
with both Quills and QuillsEnabled.

    >>> blog = self.createBlog('issue-143')
    >>> blogFolder = self.portal['issue-143']
    >>> from zope.component import getMultiAdapter
    >>> request = blogFolder.REQUEST
    >>> view = getMultiAdapter((blogFolder, request), name='view')
    >>> renderer = TestRenderer(blogFolder, request, view, None, None)
    >>> renderer.available
    True

Now with one private entry in it.

    >>> entry = blog.addEntry('Tesing issue #143', 'Nothing', 'Nothing', id="issue-143")
    >>> renderer.available
    True

And now with that one published. In all three cases the portlet should show up. We cannot
do this directly on entry as it might be only an adapter.

    >>> from Products.CMFCore.utils import getToolByName
    >>> wft = getToolByName(self.getPortal(), 'portal_workflow')
    >>> wft.getInfoFor(blogFolder['issue-143'], 'review_state')
    'private'

    >>> entry.publish()
    >>> renderer.available
    True


Issue #115: Blog posts published in the future should not appear
----------------------------------------------------------------

This was not a bug, really. Quills behave correctly, hiding entries scheduled for
future publication as it should. This test-case confirms this.

We will test here access by Quills API and through the web.

    >>> from quills.core.interfaces.weblog import IWeblog
    >>> blog = self.weblog
    >>> IWeblog.providedBy(blog)
    True

We create a entry and publish, though not yet in the future.
    

    >>> id = 'issue-115'
    >>> entry = blog.addEntry("Issue #115", "Tesing for issue 115",
    ...                       "Nothing.", id=id)
    >>> entry.publish()

This entry should have an effective date before now, or none at best. We cannot
get effective directly from the entry because it might be only an adapter.

    >>> from DateTime import DateTime # We cannot use python datetime here, alas
    >>> effective = self.portal.weblog[id].effective()
    >>> now = DateTime()
    >>> effective is None or effective <= now
    True
    
It is visible.

    >>> id in map(lambda x: x.id, blog.getEntries())
    True

Now make it become effective in the future. It should still be visible since we are
managers and possess the appropriate rights.

    >>> from Products.CMFCore.permissions import AccessInactivePortalContent
    >>> from Products.CMFCore.utils import _checkPermission
    >>> _checkPermission(AccessInactivePortalContent, self.portal.weblog) and True
    True

    >>> futureDate = now + 7
    >>> self.portal.weblog[id].setEffectiveDate(futureDate)
    >>> self.portal.weblog[id].indexObject()
    >>> id in map(lambda x: x.id, blog.getEntries())
    True
        
Now we drop that right. The entry should no longer be visible.

    >>> from AccessControl import getSecurityManager
    >>> self.logout()
    >>> _checkPermission(AccessInactivePortalContent, self.portal.weblog) and True
        
    >>> id in map(lambda x: x.id, blog.getEntries())
    False

If published in the past it should be visible again.
    
    >>> self.portal.weblog[id].setEffectiveDate(effective)
    >>> self.portal.weblog[id].indexObject()
    >>> id in map(lambda x: x.id, blog.getEntries())
    True
    
Login again and set for future publication.

    >>> self.loginAsPortalOwner()
    >>> _checkPermission(AccessInactivePortalContent, self.portal.weblog) and True
    True
    >>> self.portal.weblog[id].setEffectiveDate(futureDate)
    >>> self.portal.weblog[id].indexObject()
    >>> id in map(lambda x: x.id, blog.getEntries())
    True

Now same procedure through the web. Our entry should be invisible.

    >>> browser = self.getBrowser(logged_in=False)
    >>> browser.handleErrors = False
    >>> browser.open('http://nohost/plone/weblog/')
    >>> browser.getLink(url="http://nohost/plone/weblog/%s" % (id,))
    Traceback (most recent call last):
        ...
    LinkNotFoundError

After resetting the date it should be visible again.

    >>> self.portal.weblog[id].setEffectiveDate(effective)
    >>> self.portal.weblog[id].indexObject()
    >>> browser.open('http://nohost/plone/weblog/')
    >>> browser.getLink(url="http://nohost/plone/weblog/%s" % (id,))
    <Link ...>

We do not test for draft stated entries, because those are hidden from public
viewing anyway. We have to check the archive, though.

First some preparations, like getting the archive URL prefix.

    >>> from quills.app.interfaces import IWeblogEnhancedConfiguration
    >>> weblog_config = IWeblogEnhancedConfiguration(self.portal.weblog)
    >>> archivePrefix = weblog_config.archive_format

We check through the web only. First with effective in the past.

    >>> path = "/".join([archivePrefix, "%s" % (effective.year(),)])
    >>> browser.open('http://nohost/plone/weblog/%s' % (path,))
    >>> browser.getLink(url="http://nohost/plone/weblog/%s" % (id,))
    <Link ...>

Then with effective in the future.

    >>> path = "/".join([archivePrefix, "%s" % (futureDate.year(),)])
    >>> self.portal.weblog[id].setEffectiveDate(futureDate)
    >>> self.portal.weblog[id].indexObject()
    >>> browser.open('http://nohost/plone/weblog/%s' % (path,))
    >>> browser.getLink(url="http://nohost/plone/weblog/%s" % (id,))
    Traceback (most recent call last):
        ...
    LinkNotFoundError

Finally we should test syndication, but this would require some package implementing that
feature, which we do not want do depend on here.
