<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>py.test customize</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="../style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div>
          <div><a class="menu" href="../announce/release-1.1.1.html">1.1.1 ANN</a></div></div>
        <div>
          <div><a class="menu" href="../install.html">INSTALL</a></div></div>
        <div>
          <div><a class="menu" href="../contact.html">CONTACT</a></div></div>
        <div>
          <div><a class="menu" href="../changelog.html">CHANGELOG</a></div></div>
        <div>
          <div><a class="menu" href="../faq.html">FAQ</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="index.html">Index</a></div>
            <div><a class="menu" href="quickstart.html">Quickstart</a></div>
            <div><a class="menu" href="features.html">Features</a></div>
            <div><a class="menu" href="plugin/index.html">Plugins</a></div>
            <div><a class="menu" href="funcargs.html">Funcargs</a></div>
            <div><a class="menu" href="customize.html">Customize</a></div>
            <div><a class="menu" href="talks.html">Tutorials</a></div></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="../index.html">Index</a></div>
            <div><a class="menu" href="../path.html">py.path</a></div>
            <div><a class="menu" href="../code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="customizing-and-extending-py-test">
<h1 class="title">Customizing and Extending py.test</h1>

<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#basic-test-configuration" id="id1">basic test configuration</a><ul>
<li><a class="reference internal" href="#available-command-line-options" id="id2">available command line options</a></li>
<li><a class="reference internal" href="#conftest-py-project-specific-hooks-and-configuration" id="id3">conftest.py: project specific hooks and configuration</a></li>
<li><a class="reference internal" href="#setting-persistent-option-defaults" id="id4">setting persistent option defaults</a></li>
<li><a class="reference internal" href="#temporary-directories" id="id5">Temporary directories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plugin-basics" id="id6">Plugin basics</a><ul>
<li><a class="reference internal" href="#project-specific-local-or-named-global-plugins" id="id7">project specific &quot;local&quot; or named &quot;global&quot; plugins</a></li>
<li><a class="reference internal" href="#plugin-discovery-at-tool-startup" id="id8">Plugin discovery at tool startup</a></li>
<li><a class="reference internal" href="#specifying-plugins-in-a-test-module-or-plugin" id="id9">Specifying plugins in a test module or plugin</a></li>
<li><a class="reference internal" href="#writing-per-project-plugins-conftest-py" id="id10">Writing per-project plugins (conftest.py)</a></li>
<li><a class="reference internal" href="#writing-setuptools-registered-plugins" id="id11">Writing setuptools-registered plugins</a></li>
<li><a class="reference internal" href="#accessing-another-plugin-by-name" id="id12">Accessing another plugin by name</a></li>
</ul>
</li>
<li><a class="reference internal" href="#important-py-test-hooks" id="id13">Important py.test hooks</a><ul>
<li><a class="reference internal" href="#command-line-parsing-and-configuration-hooks" id="id14">command line parsing and configuration hooks</a></li>
<li><a class="reference internal" href="#adding-global-py-test-helpers-and-functionality" id="id15">adding global py.test helpers and functionality</a></li>
<li><a class="reference internal" href="#generic-runtest-hooks" id="id16">generic &quot;runtest&quot; hooks</a></li>
<li><a class="reference internal" href="#generic-collection-hooks" id="id17">generic collection hooks</a></li>
<li><a class="reference internal" href="#python-test-function-and-module-hooks" id="id18">Python test function and module hooks</a></li>
<li><a class="reference internal" href="#gateway-initialization-distributed-testing" id="id19">Gateway initialization (distributed testing)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-collection-process" id="id20">Test Collection process</a><ul>
<li><a class="reference internal" href="#the-collection-tree" id="id21">the collection tree</a></li>
<li><a class="reference internal" href="#constructing-the-package-name-for-test-modules" id="id22">constructing the package name for test modules</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="basic-test-configuration">
<h1><a class="toc-backref" href="#id1">basic test configuration</a></h1>
<div class="section" id="available-command-line-options">
<h2><a class="toc-backref" href="#id2">available command line options</a></h2>
<p>You can see command line options by running:</p>
<pre class="literal-block">
py.test -h
</pre>
<p>This will display all available command line options
in your specific environment.</p>
</div>
<div class="section" id="conftest-py-project-specific-hooks-and-configuration">
<span id="collect-ignore"></span><span id="project-specific-test-configuration"></span><h2><a class="toc-backref" href="#id3">conftest.py: project specific hooks and configuration</a></h2>
<p>A unique feature of py.test are its <tt class="docutils literal">conftest.py</tt> files which
allow to:</p>
<ul class="simple">
<li><a class="reference internal" href="#set-option-defaults">set option defaults</a></li>
<li><a class="reference internal" href="#implement-hooks">implement hooks</a></li>
<li><a class="reference external" href="funcargs.html#application-setup-tutorial-example">specify funcargs</a></li>
</ul>
<p>or set particular variables to influence the testing process:</p>
<ul class="simple">
<li><tt class="docutils literal">pytest_plugins</tt>: list of named plugins to load</li>
<li><tt class="docutils literal">collect_ignore</tt>: list of paths to ignore during test collection, relative to the containing <tt class="docutils literal">conftest.py</tt> file</li>
<li><tt class="docutils literal">rsyncdirs</tt>: list of to-be-rsynced directories for distributed
testing, relative to the containing <tt class="docutils literal">conftest.py</tt> file.</li>
</ul>
<p>You may put a conftest.py files in your project root directory or into
your package directory if you want to add project-specific test options.</p>
<p><tt class="docutils literal">py.test</tt> loads all <tt class="docutils literal">conftest.py</tt> files upwards from the command
line file arguments.  It usually looks up configuration values
right-to-left, i.e. the closer conftest files will be checked first.
This means you can have a <tt class="docutils literal">conftest.py</tt> in your very home directory to
have some global configuration values.</p>
</div>
<div class="section" id="setting-persistent-option-defaults">
<span id="set-option-defaults"></span><h2><a class="toc-backref" href="#id4">setting persistent option defaults</a></h2>
<p>py.test will lookup option values in this order:</p>
<ul class="simple">
<li>command line</li>
<li>conftest.py files</li>
<li>environment variables</li>
</ul>
<p>To find out about the particular switches and type:</p>
<pre class="literal-block">
py.test --help-config
</pre>
<p>This will print information about all options in your
environment, including your local plugins.</p>
</div>
<div class="section" id="temporary-directories">
<span id="basetemp"></span><h2><a class="toc-backref" href="#id5">Temporary directories</a></h2>
<p>You can create directories by calling one of two methods
on the config object:</p>
<ul class="simple">
<li><tt class="docutils literal">config.mktemp(basename)</tt>: create and return a new tempdir</li>
<li><tt class="docutils literal">config.ensuretemp(basename)</tt>: create or return a new tempdir</li>
</ul>
<p>temporary directories are created as sub directories of a per-session
testdir and will keep around the directories of the last three test
runs.  You can set the base temporary directory through the command line
<cite>--basetemp`</cite> option.  When distributing tests on the same machine,
<tt class="docutils literal">py.test</tt> takes care to configure a basetemp directory for the sub
processes such that all temporary data lands below below a single
per-test run basetemp directory.</p>
</div>
</div>
<div class="section" id="plugin-basics">
<span id="extensions"></span><h1><a class="toc-backref" href="#id6">Plugin basics</a></h1>
<div class="section" id="project-specific-local-or-named-global-plugins">
<span id="local-plugin"></span><h2><a class="toc-backref" href="#id7">project specific &quot;local&quot; or named &quot;global&quot; plugins</a></h2>
<p>py.test implements much of its functionality by calling <a class="reference internal" href="#well-specified-hooks">well specified
hooks</a>.  Python modules which contain such hook functions are called
plugins.  Hook functions are discovered in <tt class="docutils literal">conftest.py</tt> files or in
<a class="reference external" href="plugin/index.html">named plugins</a>.  <tt class="docutils literal">conftest.py</tt> files are sometimes called
&quot;anonymous&quot; or conftest plugins. They are useful for keeping test
extensions close to your application.  Named plugins are normal python
modules or packages that can be distributed separately.   Named plugins
need to follow a naming pattern; they have an all lowercase <tt class="docutils literal">pytest_</tt>
prefixed name.  While conftest plugins are discovered automatically,
named plugins must be explicitely specified.</p>
</div>
<div class="section" id="plugin-discovery-at-tool-startup">
<span id="test-tool-starts-up"></span><span id="loaded-at-tool-startup"></span><span id="tool-startup"></span><h2><a class="toc-backref" href="#id8">Plugin discovery at tool startup</a></h2>
<p>py.test loads plugin modules at tool startup in the following way:</p>
<ul class="simple">
<li>by loading all plugins registered through <a class="reference internal" href="#setuptools-entry-points">setuptools entry points</a>.</li>
<li>by reading the <tt class="docutils literal">PYTEST_PLUGINS</tt> environment variable
and importing the comma-separated list of named plugins.</li>
<li>by pre-scanning the command line for the <tt class="docutils literal"><span class="pre">-p</span> name</tt> option
and loading the specified plugin before actual command line parsing.</li>
<li>by loading all <a class="reference internal" href="#conftest-py-plugin">conftest.py plugin</a> files as inferred by the command line
invocation (test files and all of its parent directories).
Note that <tt class="docutils literal">conftest.py</tt> files from sub directories are loaded
during test collection and not at tool startup.</li>
<li>by recursively loading all plugins specified by the
<tt class="docutils literal">pytest_plugins</tt> variable in a <tt class="docutils literal">conftest.py</tt> file</li>
</ul>
</div>
<div class="section" id="specifying-plugins-in-a-test-module-or-plugin">
<h2><a class="toc-backref" href="#id9">Specifying plugins in a test module or plugin</a></h2>
<p>You can specify plugins in a test module or a plugin like this:</p>
<p>When the test module or plugin is loaded the specified plugins
will be loaded.  If you specify plugins without the <tt class="docutils literal">pytest_</tt>
prefix it will be automatically added.  All plugin names
must be lowercase.</p>
</div>
<div class="section" id="writing-per-project-plugins-conftest-py">
<span id="conftestplugin"></span><span id="conftest-py-plugin"></span><h2><a class="toc-backref" href="#id10">Writing per-project plugins (conftest.py)</a></h2>
<p>The purpose of <tt class="docutils literal">conftest.py</tt> files is to allow <a class="reference internal" href="#project-specific-test-configuration">project-specific
test configuration</a>.  They thus make for a good place to implement
project-specific test related features through hooks.  For example you may
set the <a class="reference internal" href="#collect-ignore">collect_ignore</a> variable depending on a command line option
by defining the following hook in a <tt class="docutils literal">conftest.py</tt> file:</p>
</div>
<div class="section" id="writing-setuptools-registered-plugins">
<span id="setuptools-entry-points"></span><span id="exclude-file-example"></span><h2><a class="toc-backref" href="#id11">Writing setuptools-registered plugins</a></h2>
<p>If you want to make your plugin publically available, you
can use <a class="reference external" href="http://pypi.python.org/pypi/setuptools">setuptools</a> or <a class="reference external" href="http://pypi.python.org/pypi/distribute">Distribute</a> which both allow
to register an entry point.  <tt class="docutils literal">py.test</tt> will register
all objects with the <tt class="docutils literal">pytest11</tt> entry point.
To make your plugin available you may insert the following
lines in your setuptools/distribute-based setup-invocation:</p>
<p>If a package is installed with this setup, py.test will load
<tt class="docutils literal">myproject.pluginmodule</tt> under the <tt class="docutils literal">name_of_plugin</tt> name
and use it as a plugin.</p>
</div>
<div class="section" id="accessing-another-plugin-by-name">
<h2><a class="toc-backref" href="#id12">Accessing another plugin by name</a></h2>
<p>If a plugin wants to collaborate with code from
another plugin it can obtain a reference through
the plugin manager like this:</p>
<p>If you want to look at the names of existing plugins, use
the <tt class="docutils literal"><span class="pre">--traceconfig</span></tt> option.</p>
</div>
</div>
<div class="section" id="important-py-test-hooks">
<span id="implement-hooks"></span><span id="well-specified-hooks"></span><h1><a class="toc-backref" href="#id13">Important py.test hooks</a></h1>
<p>py.test calls hooks functions to implement its <a class="reference internal" href="#test-collection">test collection</a>,
running and reporting process.  When py.test loads a plugin it validates
that all hook functions conform to the <a class="reference external" href="plugin/hookspec.html">hook definition specification</a>.</p>
<p>The hook function name and its
argument names need to match exactly but it is allowed for an implementation
to accept <em>less</em> parameters.  You'll get useful errors on mistyped hook or
argument names.  Read on for some introductory information on particular
hooks.  It's sensible to look at existing plugins so see example usages
and start off with your own plugin.</p>
<div class="section" id="command-line-parsing-and-configuration-hooks">
<span id="configuration-hooks"></span><h2><a class="toc-backref" href="#id14">command line parsing and configuration hooks</a></h2>
<p>When the <a class="reference internal" href="#test-tool-starts-up">test tool starts up</a> it will invoke all hooks that add
command line options in the python standard optparse style.</p>
<p>After all these hooks have been called, the command line is parser
and a <tt class="docutils literal">config</tt> object is created and another hook is invoked,
for example:</p>
<p>When the test run finishes this corresponding finalizer hook is called:</p>
<blockquote>
<dl class="docutils">
<dt>def pytest_unconfigure(config):</dt>
<dd>...</dd>
</dl>
</blockquote>
</div>
<div class="section" id="adding-global-py-test-helpers-and-functionality">
<h2><a class="toc-backref" href="#id15">adding global py.test helpers and functionality</a></h2>
<p>If you want to make global helper functions or objects available
to your test code you can implement:</p>
<blockquote>
<dl class="docutils">
<dt>def pytest_namespace():</dt>
<dd>&quot;&quot;&quot; return dictionary with items to be made available on py.test. namespace &quot;&quot;&quot;</dd>
</dl>
</blockquote>
<p>All such returned items will be made available directly on
the <tt class="docutils literal">py.test</tt> namespace.</p>
<p>If you want to provide helpers that are specific to a test function run or need
to be setup per test function run, please refer to the <a class="reference external" href="funcargs.html">funcargs mechanism</a>.</p>
</div>
<div class="section" id="generic-runtest-hooks">
<h2><a class="toc-backref" href="#id16">generic &quot;runtest&quot; hooks</a></h2>
<p>Each test item is usually executed by calling the following three hooks:</p>
<p>For each of the three invocations a <a class="reference internal" href="#call-object">call object</a> encapsulates
information about the outcome of the call and is subsequently used
to make a report object:</p>
<p>For example, the <a class="reference external" href="http://bitbucket.org/hpk42/py-trunk/src/tip/py/test/plugin/pytest_pdb.py">pytest_pdb plugin</a> uses this hook to activate
interactive debugging on failures when <tt class="docutils literal"><span class="pre">--pdb</span></tt> is specified on the
command line.</p>
<p>Usually three reports will be generated for a single test item for each
of the three runtest hooks respectively.  If <tt class="docutils literal">pytest_runtest_setup</tt>
fails then <tt class="docutils literal">pytest_runtest_teardown</tt> will be called but not
<tt class="docutils literal">pytest_runtest_call</tt>.</p>
<p>Each of the up to three reports is eventually fed to the logreport hook:</p>
<p>A <tt class="docutils literal">report</tt> object contains status and reporting information:</p>
<p>The <a class="reference external" href="http://bitbucket.org/hpk42/py-trunk/src/tip/py/test/plugin/pytest_terminal.py">pytest_terminal plugin</a> uses this hook to print information
about a test run.</p>
<p>The whole protocol described here is implemented via this hook:</p>
<p id="call-object">The call object contains information about a performed call:</p>
</div>
<div class="section" id="generic-collection-hooks">
<h2><a class="toc-backref" href="#id17">generic collection hooks</a></h2>
<p>py.test calls the following two fundamental hooks for collecting files and directories:</p>
<p>Both return a <a class="reference internal" href="#collection-node">collection node</a> for a given path.  All returned
nodes from all hook implementations will participate in the
collection and running protocol.  The <tt class="docutils literal">parent</tt> object is
the parent node and may be used to access command line
options via the <tt class="docutils literal">parent.config</tt> object.</p>
</div>
<div class="section" id="python-test-function-and-module-hooks">
<h2><a class="toc-backref" href="#id18">Python test function and module hooks</a></h2>
<p>For influencing the collection of objects in Python modules
you can use the following hook:</p>
<p>This hook will be called for each Python object in a collected
Python module.  The return value is a custom <a class="reference internal" href="#collection-node">collection node</a> or None.</p>
<!-- XXX or ``False`` if you want to indicate that the given item should not be collected. -->
</div>
<div class="section" id="gateway-initialization-distributed-testing">
<h2><a class="toc-backref" href="#id19">Gateway initialization (distributed testing)</a></h2>
<p>(alpha) For distributed testing it can be useful to prepare the
remote environment.  For this you can implement the newgateway hook:</p>
<p>The <tt class="docutils literal">gateway</tt> object here has a <tt class="docutils literal">spec</tt> attribute which is an <tt class="docutils literal">execnet.XSpec</tt>
object, which has attributes that map key/values as specified from a <tt class="docutils literal"><span class="pre">--txspec</span></tt>
option. The platinfo object is a dictionary with information about the remote process:</p>
<ul class="simple">
<li><tt class="docutils literal">version</tt>: remote python's <tt class="docutils literal">sys.version_info</tt></li>
<li><tt class="docutils literal">platform</tt>: remote <tt class="docutils literal">sys.platform</tt></li>
<li><tt class="docutils literal">cwd</tt>: remote <tt class="docutils literal">os.getcwd</tt></li>
</ul>
</div>
</div>
<div class="section" id="test-collection-process">
<span id="test-collection"></span><span id="collection-node"></span><span id="collection-process"></span><h1><a class="toc-backref" href="#id20">Test Collection process</a></h1>
<div class="section" id="the-collection-tree">
<h2><a class="toc-backref" href="#id21">the collection tree</a></h2>
<p>The collecting process is iterative so that distribution
and execution of tests can start as soon as the first test
item is collected.  Collection nodes with children are
called &quot;Collectors&quot; and terminal nodes are called &quot;Items&quot;.
Here is an example of such a tree, generated with the
command <tt class="docutils literal">py.test <span class="pre">--collectonly</span> py/xmlobj</tt>:</p>
<pre class="literal-block">
&lt;Directory 'xmlobj'&gt;
    &lt;Directory 'testing'&gt;
        &lt;Module 'test_html.py' (py.__.xmlobj.testing.test_html)&gt;
            &lt;Function 'test_html_name_stickyness'&gt;
            &lt;Function 'test_stylenames'&gt;
            &lt;Function 'test_class_None'&gt;
            &lt;Function 'test_alternating_style'&gt;
        &lt;Module 'test_xml.py' (py.__.xmlobj.testing.test_xml)&gt;
            &lt;Function 'test_tag_with_text'&gt;
            &lt;Function 'test_class_identity'&gt;
            &lt;Function 'test_tag_with_text_and_attributes'&gt;
            &lt;Function 'test_tag_with_subclassed_attr_simple'&gt;
            &lt;Function 'test_tag_nested'&gt;
            &lt;Function 'test_tag_xmlname'&gt;
</pre>
<p>By default all directories not starting with a dot are traversed,
looking for <tt class="docutils literal"><span class="pre">test_*.py</span></tt> and <tt class="docutils literal">*_test.py</tt> files.  Those Python
files are imported under their <a class="reference internal" href="#package-name">package name</a>.</p>
<p>The Module collector looks for test functions
and test classes and methods. Test functions and methods
are prefixed <tt class="docutils literal">test</tt> by default.  Test classes must
start with a capitalized <tt class="docutils literal">Test</tt> prefix.</p>
</div>
<div class="section" id="constructing-the-package-name-for-test-modules">
<span id="package-name"></span><h2><a class="toc-backref" href="#id22">constructing the package name for test modules</a></h2>
<p>Test modules are imported under their fully qualified
name.  Given a filesystem <tt class="docutils literal">fspath</tt> it is constructed as follows:</p>
<ul class="simple">
<li>walk the directories up to the last one that contains
an <tt class="docutils literal">__init__.py</tt> file.</li>
<li>perform <tt class="docutils literal">sys.path.insert(0, basedir)</tt>.</li>
<li>import the root package as <tt class="docutils literal">root</tt></li>
</ul>
</div>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>