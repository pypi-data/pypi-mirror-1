<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>faq</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div style="font-style: italic;">1.0.2</div>
        <div>
          <div><a class="menu" href="download.html">install</a></div></div>
        <div>
          <div><a class="menu" href="contact.html">contact</a></div></div>
        <div>
          <div><a class="menu" href="changelog.html">changelog</a></div></div>
        <div>
          <div><a class="menu" href="faq.html">faq</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="test/index.html">doc index</a></div>
            <div><a class="menu" href="test/features.html">features</a></div>
            <div><a class="menu" href="test/quickstart.html">quickstart</a></div>
            <div><a class="menu" href="test/talks.html">tutorials</a></div>
            <div><a class="menu" href="test/plugin/index.html">plugins</a></div>
            <div><a class="menu" href="test/funcargs.html">funcargs</a></div>
            <div><a class="menu" href="test/customize.html">customize</a></div></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="index.html">pylib index</a></div>
            <div><a class="menu" href="execnet.html">py.execnet</a></div>
            <div><a class="menu" href="path.html">py.path</a></div>
            <div><a class="menu" href="code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="frequently-asked-questions">
<h1 class="title">Frequently Asked Questions</h1>

<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#on-naming-nose-and-magic" id="id1">On naming, nose and magic</a><ul>
<li><a class="reference internal" href="#why-the-py-naming-what-is-it" id="id2">Why the <tt class="docutils literal"><span class="pre">py</span></tt> naming? what is it?</a></li>
<li><a class="reference internal" href="#why-the-py-test-naming" id="id3">Why the <tt class="docutils literal"><span class="pre">py.test</span></tt> naming?</a></li>
<li><a class="reference internal" href="#what-s-the-relation-to-nosetests" id="id4">What's the relation to <tt class="docutils literal"><span class="pre">nosetests</span></tt>?</a></li>
<li><a class="reference internal" href="#what-s-all-this-magic-with-py-test" id="id5">What's all this &quot;magic&quot; with py.test?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-arguments-and-parametrized-tests" id="id6">function arguments and parametrized tests</a><ul>
<li><a class="reference internal" href="#why-the-pytest-funcarg-name-for-funcarg-factories" id="id7">Why the <tt class="docutils literal"><span class="pre">pytest_funcarg__*</span></tt> name for funcarg factories?</a></li>
<li><a class="reference internal" href="#can-i-yield-multiple-values-from-a-factory-function" id="id8">Can i yield multiple values from a factory function?</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="on-naming-nose-and-magic">
<h1><a class="toc-backref" href="#id1">On naming, nose and magic</a></h1>
<div class="section" id="why-the-py-naming-what-is-it">
<h2><a class="toc-backref" href="#id2">Why the <tt class="docutils literal"><span class="pre">py</span></tt> naming? what is it?</a></h2>
<p>Because the name was kind of available and there was the
idea to have the package evolve into a &quot;standard&quot; library
kind of thing that works cross-python versions and is
not tied to a particular CPython revision or its release
cycle.  Clearly, this was ambitious and the naming
has maybe haunted the project rather than helping it.
There may be a project name change and possibly a
split up into different projects sometime.</p>
</div>
<div class="section" id="why-the-py-test-naming">
<h2><a class="toc-backref" href="#id3">Why the <tt class="docutils literal"><span class="pre">py.test</span></tt> naming?</a></h2>
<p>the py lib contains other command line tools that
all share the <tt class="docutils literal"><span class="pre">py.</span></tt> prefix which makes it easy
to use TAB-completion on the shell.  Another motivation
was to make it obvious where testing functionality
for the <tt class="docutils literal"><span class="pre">py.test</span></tt> command line tool is: in the
<tt class="docutils literal"><span class="pre">py.test</span></tt> package name space.</p>
</div>
<div class="section" id="what-s-the-relation-to-nosetests">
<h2><a class="toc-backref" href="#id4">What's the relation to <tt class="docutils literal"><span class="pre">nosetests</span></tt>?</a></h2>
<p>py.test and <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/0.11.1/">nose</a> share basic philosophy when it comes
to running Python tests.  In fact,
with py.test-1.0.1 it is easy to run many test suites
that currently work with <tt class="docutils literal"><span class="pre">nosetests</span></tt>.  <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/0.11.1/">nose</a> was created
as a clone of <tt class="docutils literal"><span class="pre">py.test</span></tt> when it was in the <tt class="docutils literal"><span class="pre">0.8</span></tt> release
cycle so some of the newer <a class="reference external" href="test/features.html">features</a> introduced with py.test-1.0
have no counterpart in <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/0.11.1/">nose</a>.</p>
</div>
<div class="section" id="what-s-all-this-magic-with-py-test">
<h2><a class="toc-backref" href="#id5">What's all this &quot;magic&quot; with py.test?</a></h2>
<p>&quot;All this magic&quot; usually boils down to two issues:</p>
<ul class="simple">
<li>There is a special tweak to importing: <a class="reference external" href="http://bitbucket.org/hpk42/py-trunk/src/1.0.x/py/__init__.py">py/__init__.py</a> contains
a dictionary which maps the importable <tt class="docutils literal"><span class="pre">py.*</span></tt> namespaces to
objects in files.  When looking at the project source code
you see imports like <tt class="docutils literal"><span class="pre">from</span> <span class="pre">py.__.test.session</span> <span class="pre">import</span> <span class="pre">Session</span></tt>. The
the double <tt class="docutils literal"><span class="pre">__</span></tt> underscore indicates the &quot;normal&quot; python
filesystem/namespace coupled import, i.e. it points to
<tt class="docutils literal"><span class="pre">py/test/session.py</span></tt>'s <tt class="docutils literal"><span class="pre">Session</span></tt> object.  However,
from the outside you use the &quot;non-underscore&quot; <a class="reference external" href="index.html">py namespaces</a>
so this distinction usually only shows up if you hack
on internal code or see internal tracebacks.</li>
<li>when an <tt class="docutils literal"><span class="pre">assert</span></tt> fails, py.test re-interprets the expression
to show intermediate values.  This allows to use the plain <tt class="docutils literal"><span class="pre">assert</span></tt>
statement instead of the many methods that you otherwise need
to mimick this behaviour.  This means that in case of a failing
assert, your expressions gets evaluated <em>twice</em>.  If your expression
has side effects the outcome may be different.  If the test suddenly
passes you will get a detailed message.  It is good practise, anyway,
to not have asserts with side effects.  <tt class="docutils literal"><span class="pre">py.test</span> <span class="pre">--nomagic</span></tt> turns
off assert re-intepretation.</li>
</ul>
<p>Other than that, <tt class="docutils literal"><span class="pre">py.test</span></tt> has bugs or quirks like any other computer
software.  In fact, it has a <em>strong</em> focus on running robustly and has
over a thousand automated tests for its own code base.</p>
</div>
</div>
<div class="section" id="function-arguments-and-parametrized-tests">
<h1><a class="toc-backref" href="#id6">function arguments and parametrized tests</a></h1>
<div class="section" id="why-the-pytest-funcarg-name-for-funcarg-factories">
<span id="why-pytest-pyfuncarg-methods"></span><h2><a class="toc-backref" href="#id7">Why the <tt class="docutils literal"><span class="pre">pytest_funcarg__*</span></tt> name for funcarg factories?</a></h2>
<p>When experimenting with funcargs an explicit registration mechanism
was considered.  But lacking a good use case for this indirection and
flexibility we decided to go for <a class="reference external" href="http://en.wikipedia.org/wiki/Convention_over_Configuration">Convention over Configuration</a> and
allow to directly specify the factory.  Besides removing the need
for an indirection it allows to &quot;grep&quot; for <tt class="docutils literal"><span class="pre">pytest_funcarg__MYARG</span></tt>
and will safely find all factory functions for the <tt class="docutils literal"><span class="pre">MYARG</span></tt> function
argument.  It helps to alleviates the de-coupling of function
argument usage and creation.</p>
</div>
<div class="section" id="can-i-yield-multiple-values-from-a-factory-function">
<h2><a class="toc-backref" href="#id8">Can i yield multiple values from a factory function?</a></h2>
<p>There are two reasons why yielding from a factory function
is not possible:</p>
<ul class="simple">
<li>Calling factories for obtaining test function arguments
is part of setting up and running a test.  At that
point it is not possible to add new test calls to
the test collection anymore.</li>
<li>If multiple factories yielded values there would
be no natural place to determine the combination
policy - in real-world examples some combinations
often should not run.</li>
</ul>
<p>Use the <a class="reference external" href="test/funcargs.html#parametrizing-tests">pytest_generate_tests</a> hook to solve both issues
and implement the <a class="reference external" href="http://tetamap.wordpress.com/2009/05/13/parametrizing-python-tests-generalized/">parametrization scheme of your choice</a>.</p>
</div>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>