<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>execnet</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div style="font-style: italic;">1.0.2</div>
        <div>
          <div><a class="menu" href="download.html">install</a></div></div>
        <div>
          <div><a class="menu" href="contact.html">contact</a></div></div>
        <div>
          <div><a class="menu" href="changelog.html">changelog</a></div></div>
        <div>
          <div><a class="menu" href="faq.html">faq</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="test/index.html">doc index</a></div>
            <div><a class="menu" href="test/features.html">features</a></div>
            <div><a class="menu" href="test/quickstart.html">quickstart</a></div>
            <div><a class="menu" href="test/talks.html">tutorials</a></div>
            <div><a class="menu" href="test/plugin/index.html">plugins</a></div>
            <div><a class="menu" href="test/funcargs.html">funcargs</a></div>
            <div><a class="menu" href="test/customize.html">customize</a></div></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="index.html">pylib index</a></div>
            <div><a class="menu" href="execnet.html">py.execnet</a></div>
            <div><a class="menu" href="path.html">py.path</a></div>
            <div><a class="menu" href="code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="py-execnet-elastic-distributed-programming">
<h1 class="title">py.execnet: <em>elastic</em> distributed programming</h1>

<p><tt class="docutils literal"><span class="pre">execnet</span></tt> helps you to:</p>
<ul class="simple">
<li>ad-hoc instantiate local or remote Python Processes</li>
<li>send code for execution in one or many processes</li>
<li>send and receive data between processes through channels</li>
</ul>
<p>One of it's unique features is that it uses a <strong>zero-install</strong>
technique: no manual installation steps are required on
remote places, only a basic working Python interpreter
and some input/output connection to it.</p>
<p>There is a <a class="reference external" href="http://codespeak.net/download/py/ep2009-execnet.pdf">EuroPython2009 talk</a> from July 2009 with
examples and some pictures.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#gateways-immediately-spawn-local-or-remote-process" id="id1">Gateways: immediately spawn local or remote process</a></li>
<li><a class="reference internal" href="#remote-exec-execute-source-code-remotely" id="id2">remote_exec: execute source code remotely</a></li>
<li><a class="reference internal" href="#channels-bidirectionally-exchange-data-between-hosts" id="id3">Channels: bidirectionally exchange data between hosts</a></li>
<li><a class="reference internal" href="#xspec-string-specification-for-gateway-type-and-configuration" id="id4">XSpec: string specification for gateway type and configuration</a></li>
<li><a class="reference internal" href="#examples-of-py-execnet-usage" id="id5">Examples of py.execnet usage</a><ul>
<li><a class="reference internal" href="#compare-cwd-of-popen-gateways" id="id6">Compare cwd() of Popen Gateways</a></li>
<li><a class="reference internal" href="#synchronously-receive-results-from-two-sub-processes" id="id7">Synchronously receive results from two sub processes</a></li>
<li><a class="reference internal" href="#asynchronously-receive-results-from-two-sub-processes" id="id8">Asynchronously receive results from two sub processes</a></li>
<li><a class="reference internal" href="#receive-file-contents-from-remote-ssh-account" id="id9">Receive file contents from remote SSH account</a></li>
<li><a class="reference internal" href="#instantiate-a-socket-server-in-a-new-subprocess" id="id10">Instantiate a socket server in a new subprocess</a></li>
<li><a class="reference internal" href="#sending-a-module-checking-if-run-through-remote-exec" id="id11">Sending a module / checking if run through remote_exec</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="gateways-immediately-spawn-local-or-remote-process">
<h1><a class="toc-backref" href="#id1">Gateways: immediately spawn local or remote process</a></h1>
<p>In order to send code to a remote place or a subprocess
you need to instantiate a so-called Gateway object.
There are currently three Gateway classes:</p>
<ul class="simple">
<li><a class="reference external" href="api/execnet.PopenGateway.html">py.execnet.PopenGateway</a> to open a subprocess
on the local machine.  Useful for making use
of multiple processors to to contain code execution
in a separated environment.</li>
<li><a class="reference external" href="api/execnet.SshGateway.html">py.execnet.SshGateway</a> to connect to
a remote ssh server and distribute execution to it.</li>
<li><a class="reference external" href="api/execnet.SocketGateway.html">py.execnet.SocketGateway</a> a way to connect to
a remote Socket based server. <em>Note</em> that this method
requires a manually started
:source:py/execnet/script/socketserver.py
script.  You can run this &quot;server script&quot; without
having the py lib installed on the remote system
and you can setup it up as permanent service.</li>
</ul>
</div>
<div class="section" id="remote-exec-execute-source-code-remotely">
<h1><a class="toc-backref" href="#id2">remote_exec: execute source code remotely</a></h1>
<p>All gateways offer remote code execution via this high level function:</p>
<pre class="literal-block">
def remote_exec(source):
    &quot;&quot;&quot;return channel object for communicating with the asynchronously
    executing 'source' code which will have a corresponding 'channel'
    object in its executing namespace.&quot;&quot;&quot;
</pre>
<p>With <cite>remote_exec</cite> you send source code to the other
side and get both a local and a remote <a class="reference internal" href="#channel">Channel</a> object,
which you can use to have the local and remote site
communicate data in a structured way.   Here is
an example for reading the PID:</p>
<pre class="literal-block">
&gt;&gt;&gt; import py
&gt;&gt;&gt; gw = py.execnet.PopenGateway()
&gt;&gt;&gt; channel = gw.remote_exec(&quot;&quot;&quot;
...     import os
...     channel.send(os.getpid())
... &quot;&quot;&quot;)
&gt;&gt;&gt; remote_pid = channel.receive()
&gt;&gt;&gt; remote_pid != py.std.os.getpid()
True
</pre>
</div>
<div class="section" id="channels-bidirectionally-exchange-data-between-hosts">
<span id="exchange-data"></span><span id="channel-api"></span><span id="channel"></span><h1><a class="toc-backref" href="#id3">Channels: bidirectionally exchange data between hosts</a></h1>
<p>A channel object allows to send and receive data between
two asynchronously running programs.  When calling
<cite>remote_exec</cite> you will get a channel object back and
the code fragment running on the other side will
see a channel object in its global namespace.</p>
<p>Here is the interface of channel objects:</p>
<pre class="literal-block">
#
# API for sending and receiving anonymous values
#
channel.send(item):
    sends the given item to the other side of the channel,
    possibly blocking if the sender queue is full.
    Note that items need to be marshallable (all basic
    python types are).

channel.receive():
    receives an item that was sent from the other side,
    possibly blocking if there is none.
    Note that exceptions from the other side will be
    reraised as gateway.RemoteError exceptions containing
    a textual representation of the remote traceback.

channel.waitclose(timeout=None):
    wait until this channel is closed.  Note that a closed
    channel may still hold items that will be received or
    send. Note that exceptions from the other side will be
    reraised as gateway.RemoteError exceptions containing
    a textual representation of the remote traceback.

channel.close():
    close this channel on both the local and the remote side.
    A remote side blocking on receive() on this channel
    will get woken up and see an EOFError exception.
</pre>
</div>
<div class="section" id="xspec-string-specification-for-gateway-type-and-configuration">
<span id="xspec"></span><h1><a class="toc-backref" href="#id4">XSpec: string specification for gateway type and configuration</a></h1>
<p><tt class="docutils literal"><span class="pre">py.execnet</span></tt> supports a simple extensible format for
specifying and configuring Gateways for remote execution.
You can use a string specification to instantiate a new gateway,
for example a new SshGateway:</p>
<pre class="literal-block">
gateway = py.execnet.makegateway(&quot;ssh=myhost&quot;)
</pre>
<p>Let's look at some examples for valid specifications.
Specification for an ssh connection to <cite>wyvern</cite>, running on python2.4 in the (newly created) 'mycache'  subdirectory:</p>
<pre class="literal-block">
ssh=wyvern//python=python2.4//chdir=mycache
</pre>
<p>Specification of a python2.5 subprocess; with a low CPU priority (&quot;nice&quot; level). Current dir will be the current dir of the instantiator (that's true for all 'popen' specifications unless they specify 'chdir'):</p>
<pre class="literal-block">
popen//python=2.5//nice=20
</pre>
<p>Specification of a Python Socket server process that listens on 192.168.1.4:8888; current dir will be the 'pyexecnet-cache' sub directory which is used a default for all remote processes:</p>
<pre class="literal-block">
socket=192.168.1.4:8888
</pre>
<p>More generally, a specification string has this general format:</p>
<pre class="literal-block">
key1=value1//key2=value2//key3=value3
</pre>
<p>If you omit a value, a boolean true value is assumed.  Currently
the following key/values are supported:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">popen</span></tt> for a PopenGateway</li>
<li><tt class="docutils literal"><span class="pre">ssh=host</span></tt> for a SshGateway</li>
<li><tt class="docutils literal"><span class="pre">socket=address:port</span></tt> for a SocketGateway</li>
<li><tt class="docutils literal"><span class="pre">python=executable</span></tt> for specifying Python executables</li>
<li><tt class="docutils literal"><span class="pre">chdir=path</span></tt> change remote working dir to given relative or absolute path</li>
<li><tt class="docutils literal"><span class="pre">nice=value</span></tt> decrease remote nice level if platforms supports it</li>
</ul>
</div>
<div class="section" id="examples-of-py-execnet-usage">
<h1><a class="toc-backref" href="#id5">Examples of py.execnet usage</a></h1>
<div class="section" id="compare-cwd-of-popen-gateways">
<h2><a class="toc-backref" href="#id6">Compare cwd() of Popen Gateways</a></h2>
<p>A PopenGateway has the same working directory as the instantiatior:</p>
<pre class="literal-block">
&gt;&gt;&gt; import py, os
&gt;&gt;&gt; gw = py.execnet.PopenGateway()
&gt;&gt;&gt; ch = gw.remote_exec(&quot;import os; channel.send(os.getcwd())&quot;)
&gt;&gt;&gt; res = ch.receive()
&gt;&gt;&gt; assert res == os.getcwd()
&gt;&gt;&gt; gw.exit()
</pre>
</div>
<div class="section" id="synchronously-receive-results-from-two-sub-processes">
<h2><a class="toc-backref" href="#id7">Synchronously receive results from two sub processes</a></h2>
<p>Use MultiChannels for receiving multiple results from remote code:</p>
<pre class="literal-block">
&gt;&gt;&gt; import py
&gt;&gt;&gt; ch1 = py.execnet.PopenGateway().remote_exec(&quot;channel.send(1)&quot;)
&gt;&gt;&gt; ch2 = py.execnet.PopenGateway().remote_exec(&quot;channel.send(2)&quot;)
&gt;&gt;&gt; mch = py.execnet.MultiChannel([ch1, ch2])
&gt;&gt;&gt; l = mch.receive_each()
&gt;&gt;&gt; assert len(l) == 2
&gt;&gt;&gt; assert 1 in l
&gt;&gt;&gt; assert 2 in l
</pre>
</div>
<div class="section" id="asynchronously-receive-results-from-two-sub-processes">
<h2><a class="toc-backref" href="#id8">Asynchronously receive results from two sub processes</a></h2>
<p>Use <tt class="docutils literal"><span class="pre">MultiChannel.make_receive_queue()</span></tt> for asynchronously receiving
multiple results from remote code.  This standard Queue provides
<tt class="docutils literal"><span class="pre">(channel,</span> <span class="pre">result)</span></tt> tuples which allows to determine where
a result comes from:</p>
<pre class="literal-block">
&gt;&gt;&gt; import py
&gt;&gt;&gt; ch1 = py.execnet.PopenGateway().remote_exec(&quot;channel.send(1)&quot;)
&gt;&gt;&gt; ch2 = py.execnet.PopenGateway().remote_exec(&quot;channel.send(2)&quot;)
&gt;&gt;&gt; mch = py.execnet.MultiChannel([ch1, ch2])
&gt;&gt;&gt; queue = mch.make_receive_queue()
&gt;&gt;&gt; chan1, res1 = queue.get()  # you may also specify a timeout
&gt;&gt;&gt; chan2, res2 = queue.get()
&gt;&gt;&gt; res1 + res2
3
&gt;&gt;&gt; assert chan1 in (ch1, ch2)
&gt;&gt;&gt; assert chan2 in (ch1, ch2)
&gt;&gt;&gt; assert chan1 != chan2
</pre>
</div>
<div class="section" id="receive-file-contents-from-remote-ssh-account">
<h2><a class="toc-backref" href="#id9">Receive file contents from remote SSH account</a></h2>
<p>Here is a small program that you can use to retrieve
contents of remote files:</p>
<pre class="literal-block">
import py
# open a gateway to a fresh child process
gw = py.execnet.SshGateway('codespeak.net')
channel = gw.remote_exec(&quot;&quot;&quot;
        for fn in channel:
            f = open(fn, 'rb')
            channel.send(f.read())
            f.close()
&quot;&quot;&quot;)

for fn in somefilelist:
    channel.send(fn)
    content = channel.receive()
    # process content

# later you can exit / close down the gateway
gw.exit()
</pre>
</div>
<div class="section" id="instantiate-a-socket-server-in-a-new-subprocess">
<h2><a class="toc-backref" href="#id10">Instantiate a socket server in a new subprocess</a></h2>
<p>The following example opens a PopenGateway, i.e. a python
child process, and starts a socket server within that process
and then opens a second gateway to the freshly started
socketserver:</p>
<pre class="literal-block">
import py

popengw = py.execnet.PopenGateway()
socketgw = py.execnet.SocketGateway.new_remote(popengw, (&quot;127.0.0.1&quot;, 0))

print socketgw._rinfo() # print some info about the remote environment
</pre>
</div>
<div class="section" id="sending-a-module-checking-if-run-through-remote-exec">
<h2><a class="toc-backref" href="#id11">Sending a module / checking if run through remote_exec</a></h2>
<p>You can pass a module object to <tt class="docutils literal"><span class="pre">remote_exec</span></tt> in which case
its source code will be sent.  No dependencies will be transferred
so the module must be self-contained or only use modules that are
installed on the &quot;other&quot; side.  Module code can detect if it is
running in a remote_exec situation by checking for the special
<tt class="docutils literal"><span class="pre">__name__</span></tt> attribute like this:</p>
<pre class="literal-block">
if __name__ == '__channelexec__':
    # ... call module functions ...
</pre>
</div>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>