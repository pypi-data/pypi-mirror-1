<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>py.test features</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="../style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div>
          <div><a class="menu" href="../announce/release-1.1.0.html">1.1.0 ANN</a></div></div>
        <div>
          <div><a class="menu" href="../install.html">INSTALL</a></div></div>
        <div>
          <div><a class="menu" href="../contact.html">CONTACT</a></div></div>
        <div>
          <div><a class="menu" href="../changelog.html">CHANGELOG</a></div></div>
        <div>
          <div><a class="menu" href="../faq.html">FAQ</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="index.html">Index</a></div>
            <div><a class="menu" href="quickstart.html">Quickstart</a></div>
            <div><a class="menu" href="features.html">Features</a></div>
            <div><a class="menu" href="plugin/index.html">Plugins</a></div>
            <div><a class="menu" href="funcargs.html">Funcargs</a></div>
            <div><a class="menu" href="customize.html">Customize</a></div>
            <div><a class="menu" href="talks.html">Tutorials</a></div></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="../index.html">Index</a></div>
            <div><a class="menu" href="../path.html">py.path</a></div>
            <div><a class="menu" href="../code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="py-test-feature-overview">
<h1 class="title">py.test feature overview</h1>

<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#mature-command-line-testing-tool" id="id1">mature command line testing tool</a></li>
<li><a class="reference internal" href="#automatically-collects-and-executes-tests" id="id2">automatically collects and executes tests</a></li>
<li><a class="reference internal" href="#supports-several-testing-practises-and-methods" id="id3">supports several testing practises and methods</a></li>
<li><a class="reference internal" href="#no-boilerplate-test-functions-with-python" id="id4">no-boilerplate test functions with Python</a></li>
<li><a class="reference internal" href="#advanced-skipping-of-tests" id="id5">advanced skipping of tests</a></li>
<li><a class="reference internal" href="#load-balance-test-runs-to-multiple-cpus" id="id6">load-balance test runs to multiple CPUs</a></li>
<li><a class="reference internal" href="#ad-hoc-run-tests-cross-platform" id="id7">ad-hoc run tests cross-platform</a></li>
<li><a class="reference internal" href="#advanced-test-selection-and-running-modes" id="id8">advanced test selection and running modes</a></li>
<li><a class="reference internal" href="#easy-to-extend" id="id9">easy to extend</a></li>
</ul>
</div>
<div class="section" id="mature-command-line-testing-tool">
<h1><a class="toc-backref" href="#id1">mature command line testing tool</a></h1>
<p>py.test is a command line tool to collect and run automated tests.  It
runs well on Linux, Windows and OSX Python 2.4 through to 2.6 versions.
It can distribute a single test run to multiple machines.  It is used in
many projects, ranging from running 10 thousands of tests integrated
with buildbot to a few inlined tests on a command line script.</p>
</div>
<div class="section" id="automatically-collects-and-executes-tests">
<span id="autocollect"></span><h1><a class="toc-backref" href="#id2">automatically collects and executes tests</a></h1>
<p>py.test discovers tests automatically by looking at
specified directories and its files for common
naming patterns.  As <tt class="docutils literal"><span class="pre">py.test</span></tt> operates as a separate
cmdline tool you can easily have a command line utility and
some tests in the same file.</p>
</div>
<div class="section" id="supports-several-testing-practises-and-methods">
<h1><a class="toc-backref" href="#id3">supports several testing practises and methods</a></h1>
<p>py.test supports many testing methods conventionally used in
the Python community. It runs traditional <a class="reference external" href="http://docs.python.org/library/unittest.html">unittest.py</a>,
<a class="reference external" href="http://docs.python.org/library/doctest.html">doctest.py</a>, supports <a class="reference external" href="xunit_setup.html">xUnit style setup</a> and <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/">nose</a> specific
setups and test suites.  It offers minimal no-boilerplate model
for configuring and deploying tests written as simple Python
functions or methods.  It also integrates <a class="reference external" href="plugin/figleaf.html">coverage testing
with figleaf</a> or <a class="reference external" href="plugin/oejskit.html">Javasript unit- and functional testing</a>.</p>
</div>
<div class="section" id="no-boilerplate-test-functions-with-python">
<h1><a class="toc-backref" href="#id4">no-boilerplate test functions with Python</a></h1>
<div class="section" id="automatic-python-test-discovery">
<h2>automatic Python test discovery</h2>
<p>By default, all python modules with a <tt class="docutils literal"><span class="pre">test_*.py</span></tt>
filename are inspected for finding tests:</p>
<ul class="simple">
<li>functions with a name beginning with <tt class="docutils literal"><span class="pre">test_</span></tt></li>
<li>classes with a leading <tt class="docutils literal"><span class="pre">Test</span></tt> name and <tt class="docutils literal"><span class="pre">test</span></tt> prefixed methods.</li>
<li><tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> subclasses</li>
</ul>
</div>
<div class="section" id="test-functions-can-run-with-different-argument-sets">
<h2>test functions can run with different argument sets</h2>
<p>py.test offers the unique <a class="reference external" href="funcargs.html">funcargs mechanism</a> for setting up
and passing project-specific objects to Python test functions.
Test Parametrization happens by triggering a call to the same test
functions with different argument values.</p>
</div>
<div class="section" id="per-test-capturing-of-output-including-subprocesses">
<h2>per-test capturing of output, including subprocesses</h2>
<p>By default, <tt class="docutils literal"><span class="pre">py.test</span></tt> captures all writes to stdout/stderr.
Output from <tt class="docutils literal"><span class="pre">print</span></tt> statements as well as from subprocesses
is <a class="reference external" href="plugin/capture.html">captured</a>.  When a test fails, the associated captured outputs are shown.
This allows you to put debugging print statements in your code without
being overwhelmed by all the output that might be generated by tests
that do not fail.</p>
</div>
<div class="section" id="assert-with-the-assert-statement">
<h2>assert with the <tt class="docutils literal"><span class="pre">assert</span></tt> statement</h2>
<p><tt class="docutils literal"><span class="pre">py.test</span></tt> allows to use the standard python
<tt class="docutils literal"><span class="pre">assert</span> <span class="pre">statement</span></tt> for verifying expectations
and values in Python tests.  For example, you can
write the following in your tests:</p>
<pre class="literal-block">
assert hasattr(x, 'attribute')
</pre>
<p>to state that your object has a certain <tt class="docutils literal"><span class="pre">attribute</span></tt>. In case this
assertion fails you will see the value of <tt class="docutils literal"><span class="pre">x</span></tt>.  Intermediate
values are computed by executing the assert expression a second time.
If you execute code with side effects, e.g. read from a file like this:</p>
<pre class="literal-block">
assert f.read() != '...'
</pre>
<p>then you may get a warning from pytest if that assertions
first failed and then succeeded.</p>
</div>
<div class="section" id="asserting-expected-exceptions">
<h2>asserting expected exceptions</h2>
<p>In order to write assertions about exceptions, you use
one of two forms:</p>
<pre class="literal-block">
py.test.raises(Exception, func, *args, **kwargs)
py.test.raises(Exception, &quot;func(*args, **kwargs)&quot;)
</pre>
<p>both of which execute the specified function with args and kwargs and
asserts that the given <tt class="docutils literal"><span class="pre">Exception</span></tt> is raised.  The reporter will
provide you with helpful output in case of failures such as <em>no
exception</em> or <em>wrong exception</em>.</p>
</div>
<div class="section" id="information-rich-tracebacks-pdb-introspection">
<h2>information-rich tracebacks, PDB introspection</h2>
<p>A lot of care is taken to present useful failure information
and in particular nice and concise Python tracebacks.  This
is especially useful if you need to regularly look at failures
from nightly runs, i.e. are detached from the actual test
running session.  Here are <a class="reference external" href="http://paste.pocoo.org/show/134814/">example tracebacks</a> for a number of failing
test functions.  You can modify traceback printing styles through the
command line.  Using the <cite>--pdb`</cite> option you can automatically activate
a PDB <a class="reference external" href="http://docs.python.org/lib/module-pdb.html">Python debugger</a> when a test fails.</p>
</div>
</div>
<div class="section" id="advanced-skipping-of-tests">
<h1><a class="toc-backref" href="#id5">advanced skipping of tests</a></h1>
<p>py.test has <a class="reference external" href="plugin/skipping.html">advanced support for skipping tests</a> or expecting
failures on tests on certain platforms.  Apart from the
minimal py.test style also unittest- and nose-style tests
can make use of this feature.</p>
</div>
<div class="section" id="load-balance-test-runs-to-multiple-cpus">
<h1><a class="toc-backref" href="#id6">load-balance test runs to multiple CPUs</a></h1>
<p>For large test suites you can distribute your
tests to multiple CPUs by issuing for example:</p>
<pre class="literal-block">
py.test -n 3
</pre>
<p>Read more on <a class="reference external" href="dist.html">distributed testing</a>.</p>
</div>
<div class="section" id="ad-hoc-run-tests-cross-platform">
<h1><a class="toc-backref" href="#id7">ad-hoc run tests cross-platform</a></h1>
<p>py.test supports the sending of tests to
remote ssh-accounts, socket servers.
It can <cite>ad-hoc run your test on multiple
platforms one a single test run</cite>. Ad-hoc
means that there are <strong>no installation
requirements whatsoever</strong> on the remote side.</p>
</div>
<div class="section" id="advanced-test-selection-and-running-modes">
<h1><a class="toc-backref" href="#id8">advanced test selection and running modes</a></h1>
<p id="selection-by-keyword"><tt class="docutils literal"><span class="pre">py.test</span> <span class="pre">--looponfailing</span></tt> allows to run a test suite,
memorize all failures and then loop over the failing set
of tests until they all pass.  It will re-start running
the tests when it detects file changes in your project.</p>
<p>You can selectively run tests by specifiying a keyword
on the command line.  Examples:</p>
<pre class="literal-block">
py.test -k test_simple
py.test -k &quot;-test_simple&quot;
</pre>
<p>will run all tests matching (or not matching) the
&quot;test_simple&quot; keyword.  Note that you need to quote
the keyword if &quot;-&quot; is recognized as an indicator
for a commandline option.  Lastly, you may use:</p>
<pre class="literal-block">
py.test. -k &quot;test_simple:&quot;
</pre>
<p>which will run all tests after the expression has <em>matched once</em>, i.e.
all tests that are seen after a test that matches the &quot;test_simple&quot;
keyword.</p>
<p>By default, all filename parts and
class/function names of a test function are put into the set
of keywords for a given test.  You can specify additional
kewords like this:</p>
<pre class="literal-block">
&#64;py.test.mark.webtest
def test_send_http():
    ...
</pre>
<p>and then use those keywords to select tests.  See the <a class="reference external" href="plugin/mark.html">pytest_keyword</a>
plugin for more information.</p>
</div>
<div class="section" id="easy-to-extend">
<h1><a class="toc-backref" href="#id9">easy to extend</a></h1>
<p>py.test has advanced <a class="reference external" href="customize.html#extensions">extension mechanisms</a>
with a growing <a class="reference external" href="plugin/index.html">list of default plugins</a>.
One can can easily modify or add aspects for for
purposes such as:</p>
<ul class="simple">
<li>reporting extensions</li>
<li>customizing collection and execution of tests</li>
<li>running and managing non-python tests</li>
<li>managing domain-specific test state setup</li>
</ul>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>