<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Tag Howto | Jinja Documentation</title>
    <style text="text/css">
        body {
            font-family: 'Arial', sans-serif;
            margin: 1em;
            padding: 0;
        }

        #navigation {
            float: right;
            margin: -1em -1em 1em 1em;
            padding: 1em 2em 0 2em;
            border: 1px solid #bbb;
            border-width: 0 0 1px 1px;
            background-color: #f8f8f8;
        }

        #page {
            width: 45em;
        }

        a {
            color: #d00;
        }

        a:hover {
            color: #d40;
        }

        h1 {
            font-size: 2em;
            color: #d00;
            margin: 0.5em 0 0.5em 0;
            padding: 0;
        }

        h2 {
            font-size: 1.7em;
            color: #bd2121;
            margin: 1em 0 0.5em 0;
        }

        h3 {
            font-size: 1.3em;
            color: #8a2424;
            margin: 0.5em 0 0 0;
        }

        p {
            margin: 0.5em 1em 0.5em 1em;
        }

        pre {
            margin: 1em 0 1em 2em;
            padding: 0.5em;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            background-color: #f2f2f2;
            overflow: auto;
        }
        
        li {
            line-height: 1.4em;
        }
        
        hr {
            margin: 1em;
            padding: 0;
            height: 1px!important;
            background-color: #ccc;
            border: none!important;
        }
        
        div.admonition {
            margin: 1em 0 1em 1.5em;
            padding: 0.5em 0.5em 0.5em 2em;
            background-color: #f6e3e3;
            border: 1px solid #d50000;
            border-left: none;
            border-right: none;
        }
        
        div.admonition p.admonition-title {
            font-size: 1.1em;
            color: #d40;
            font-weight: bold;
            margin: 0 0 0.5em -1em;
        }
        
        table {
            border-collapse: collapse;
            margin: 1em 2em 1em 1.5em;
        }
        
        table td, table th {
            text-align: left;
            border: 1px solid #eee;
            padding: 0.3em;
        }
        
        table th {
            background-color: #d00000;
            color: white;
            border: 1px solid #d00000;
            border-bottom: 1px solid #eee;
        }
    </style>
</head>
<body>
    <div id="navigation">
        <h3>Documentation</h3>
        <ul>
            
            <li><a href="index.html">back to index</a></li>
            
            <li><a href="http://wsgiarea.pocoo.org/repos/jinja/trunk/docs/source/tag-dev.txt">view source online</a></li>
        </ul>
        
            <h3>Table of Contents</h3>
            <ul>
            
                <li><a href="#diving-in">Diving In</a></li>
            
                <li><a href="#example">Example</a></li>
            
                <li><a href="#nodes">Nodes</a></li>
            
                <li><a href="#keywordnode">KeywordNode</a></li>
            
                <li><a href="#variablenode">VariableNode</a></li>
            
                <li><a href="#valuenode">ValueNode</a></li>
            
                <li><a href="#choicenode">ChoiceNode</a></li>
            
                <li><a href="#collectionnode">CollectionNode</a></li>
            
                <li><a href="#one-way-parsing">One-Way Parsing</a></li>
            
                <li><a href="#two-way-parsing">Two-Way Parsing</a></li>
            
            </ul>
        
    </div>
    <h1>Tag Howto</h1>
    <div id="page">
        <p>Tags are much more complex than <a class="reference" href="./filter-dev.html">filters</a>, because with tags you can do
everything.</p>
<p>While filters only extend the behavior of tags like <tt class="docutils literal"><span class="pre">print</span></tt> and <tt class="docutils literal"><span class="pre">filter</span></tt>,
the whole Jinja core uses tags to handle loops, conditions...</p>
<p>When Jinja compiles a template, it splits the raw template text into
''nodes''. Each node is an instance of <tt class="docutils literal"><span class="pre">jinja.nodes.Node</span></tt> and has a
<tt class="docutils literal"><span class="pre">render(context)</span></tt> method. A compiled template is, simply, a list of <tt class="docutils literal"><span class="pre">Node</span></tt>
objects. When you call <tt class="docutils literal"><span class="pre">render()</span></tt> on a compiled template object, the template
calls <tt class="docutils literal"><span class="pre">render()</span></tt> on each <tt class="docutils literal"><span class="pre">Node</span></tt> in its node list, with the given context.
The results are all concatenated together to form the output of the template.</p>
<p>When Jinja encounters a <tt class="docutils literal"><span class="pre">BlockToken</span></tt> in the template it looks at the defined
library and let it parse the token content (e.g. <tt class="docutils literal"><span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">sequence</span></tt>).</p>
<p>When no library is defined it uses the standard library <tt class="docutils literal"><span class="pre">stdlib</span></tt>.</p>
<div class="section">
<h2><a id="diving-in" name="diving-in">Diving In</a></h2>
<p>Each Tag object has to look at least like this:</p>
<pre class="literal-block">
from jinja.lib import stdlib
from jinja.nodes import *

class MyTag(Node):
    rules = {}

    def __init__(self, parser, matched_tag, handler_args, stack):
        pass

    def render(self, context):
        return ''

stdlib.register_tag(MyTag)
</pre>
<p><tt class="docutils literal"><span class="pre">rules</span></tt> is a dict of parser instructions:</p>
<pre class="literal-block">
rules = {
    'default': [KeywordNode('mytag')],
    'witharg': [KeywordNode('mytag'), ChoiceNode()]
}
</pre>
<p>This rule definition would match all <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">mytag</span> <span class="pre">%}</span></tt> and <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">mytag</span> <span class="pre">arg</span> <span class="pre">%}</span></tt>
tags.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> method gets called on tag creation. When you're using a cached
loader it will save the tag in the state of leaving the <tt class="docutils literal"><span class="pre">__init__</span></tt> method.</p>
<p>The arguments are these:</p>
<ul class="simple">
<li><strong>parser</strong> - a template parser instance which can be used to parse parts
of the template.</li>
<li><strong>matched_tag</strong> - a string containing the name of the matched rule.
(e.g. <tt class="docutils literal"><span class="pre">witharg</span></tt> or <tt class="docutils literal"><span class="pre">default</span></tt> in the example above)</li>
<li><strong>handler_args</strong> - the list of argument nodes.</li>
<li><strong>stack</strong> - list of piped filters</li>
</ul>
</div>
<div class="section">
<h2><a id="example" name="example">Example</a></h2>
<p>To understand this here is the defintion of the <tt class="docutils literal"><span class="pre">print</span></tt> tag:</p>
<pre class="literal-block">
class VariableTag(Node):
    rules = {
        'default': [KeywordNode('print'), ChoiceNode()]
    }

    def __init__(self, parser, matched_tag, handler_args, stack):
        self._variable = handler_args[1]
        self._filters = [(f, args[1:][0]) for f, _, args in stack]

    def findnodes(self):
        yield self._variable

    def render(self, context):
        if not self._filters:
            return self._variable.render(context)
        var = self._variable.resolve(context)
        for f, args in self._filters:
            var = f(var, *[arg.resolve(context) for arg in args])
        return var

stdlib.register_tag(VariableTag)
</pre>
<p>The <tt class="docutils literal"><span class="pre">rules</span></tt> dict defines a rule matching all <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">print</span> <span class="pre">variable</span> <span class="pre">%}</span></tt>.</p>
<p>A <tt class="docutils literal"><span class="pre">ChoiceNode</span></tt> matches per default all variables and string/integer
constants.</p>
<p>The <tt class="docutils literal"><span class="pre">__init__</span></tt> methods saves the variable node and the list of filters
in the Tag.</p>
<p>The <tt class="docutils literal"><span class="pre">findnodes</span></tt> method has to return a iterable of all nodes defined
in the <tt class="docutils literal"><span class="pre">Tag</span></tt>.</p>
<p>In the render method the <tt class="docutils literal"><span class="pre">VariableTag</span></tt> returns a parsed content of the
variable by applying all filters.</p>
</div>
<div class="section">
<h2><a id="nodes" name="nodes">Nodes</a></h2>
<p>Jinja shipps a number of nodes the parser can match. All this nodes are
defined in the <tt class="docutils literal"><span class="pre">jinja.nodes</span></tt> module.</p>
<div class="section">
<h3><a id="keywordnode" name="keywordnode">KeywordNode</a></h3>
<p>A keyword node matches against a constant keyword value. You can compare
Keywords with strings which simplyfies the postprocessing:</p>
<pre class="literal-block">
if my_keyword_node == &quot;foo&quot;:
    ...
else:
    ...
</pre>
<p>It isn't possible to resolve or render keyworde nodes.</p>
</div>
<div class="section">
<h3><a id="variablenode" name="variablenode">VariableNode</a></h3>
<p>A variable node matches all possible variables by saving the name.
Variable nodes provide a <tt class="docutils literal"><span class="pre">define</span></tt> method for updating their value:</p>
<pre class="literal-block">
varnode.define(context, 'new value')
</pre>
<p>You can get the value of a <tt class="docutils literal"><span class="pre">VariableNode</span></tt> using resolve:</p>
<pre class="literal-block">
value = varnode.resolve(context)
</pre>
<p>variable nodes do also provide a render method which acts like the resolve
method but returns a string.</p>
</div>
<div class="section">
<h3><a id="valuenode" name="valuenode">ValueNode</a></h3>
<p>Value nodes behaves like variable nodes but match strings, integers, boolean
values and &quot;none&quot;.</p>
<p>It provides the same functionallity like the <tt class="docutils literal"><span class="pre">VariableNode</span></tt>, but resolve
can also get called without the context which allows you to fetch the constant
value inside the <tt class="docutils literal"><span class="pre">__init__</span></tt> method of a tag.</p>
</div>
<div class="section">
<h3><a id="choicenode" name="choicenode">ChoiceNode</a></h3>
<p>A choice node matches more than one one nodetype:</p>
<pre class="literal-block">
ChoiceNode(Node1(), Node2())
</pre>
<p>When not given any arguments it will match eigther one <tt class="docutils literal"><span class="pre">VariableNode</span></tt> or
<tt class="docutils literal"><span class="pre">ValueNode</span></tt>.</p>
</div>
<div class="section">
<h3><a id="collectionnode" name="collectionnode">CollectionNode</a></h3>
<p>A collection node matches an unlimited number of Nodes:</p>
<pre class="literal-block">
CollectionNode(Node1(), Node2())
</pre>
<p>When not given any arguments it will match all variable and/or value nodes.</p>
</div>
</div>
<div class="section">
<h2><a id="one-way-parsing" name="one-way-parsing">One-Way Parsing</a></h2>
<p>One way parsing is very basic:</p>
<pre class="literal-block">
{% mynode %}
    ...
{% endmynode %}
</pre>
<p>You can fetch the <tt class="docutils literal"><span class="pre">body</span></tt> between those two tags inside the <tt class="docutils literal"><span class="pre">__init__</span></tt>
method of you <tt class="docutils literal"><span class="pre">MyTag</span></tt> class:</p>
<pre class="literal-block">
self._body = parser.subparse('endmynode')
</pre>
<p>This will store all the nodes from <tt class="docutils literal"><span class="pre">mynode</span></tt> to <tt class="docutils literal"><span class="pre">endmynode</span></tt> which you can
render using <tt class="docutils literal"><span class="pre">self._body.render(context)</span></tt>.</p>
</div>
<div class="section">
<h2><a id="two-way-parsing" name="two-way-parsing">Two-Way Parsing</a></h2>
<p>Two way parsing is a bit more complicated:</p>
<pre class="literal-block">
{% mynode %}
    ...
{% switchmynode %}
    ...
{% endmynode %}
</pre>
<p>But it would also match:</p>
<pre class="literal-block">
{% mynode %}
    ...
{% endmynode %}
</pre>
<p>Parsing this would result in two bodies:</p>
<pre class="literal-block">
self._body_one, self._body_two = parser.forkparse('switchmynode', 'endmynode')
</pre>
<p>When the parser doesn't find the <tt class="docutils literal"><span class="pre">switchmynode</span></tt> tag it will returns an
empty <tt class="docutils literal"><span class="pre">NodeList</span></tt> for <tt class="docutils literal"><span class="pre">self._body_two</span></tt>.</p>
<p>For more informations have a look at the <a class="reference" href="http://wsgiarea.pocoo.org/trac/browser/jinja/trunk/jinja/tags.py">Tags</a> module in the jinja source.</p>
</div>

    </div>
</body>
</html>
