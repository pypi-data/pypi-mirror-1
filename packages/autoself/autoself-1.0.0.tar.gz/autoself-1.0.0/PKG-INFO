Metadata-Version: 1.0
Name: autoself
Version: 1.0.0
Summary: Automagically add 'self' argument to method definitions
Home-page: http://www.rfk.id.au/software/autoself/
Author: Ryan Kelly
Author-email: ryan@rfk.id.au
License: Public Domain
Description: 
        
        autoself:  automagically add 'self' argument to method definitions.
        
        First, a disclaimer.  Explicit self is good.  Bytecode hacks are bad.
        Put them together and it's quite clear that THIS MODULE IS AN ABOMINATION!
        But, it's a neat excursion into python's lower levels and if you *really*
        *really* want to save yourself some keystrokes (like, you're desperately
        trying to hack into the Death Star's security system to override the trash
        compactor as its cold metal jaws slowly squeeze you to a purple paste) then
        it can help you do that.  But, stop and consider Guido's proclamation on
        the matter:
        
        Having self be explicit is a *good thing*. It makes the code clear by
        removing ambiguity about how a variable resolves. It also makes the
        difference between functions and methods small.
        "Things that will Not Change in Python 3000":
        http://www.python.org/dev/peps/pep-3099/#core-language
        
        This module is not about making 'self' implicit.  It doesn't try to change
        the way methods work, or make any semantic changes whatsoever.  It does one
        simple thing: automatically adds the 'self' argument to method definitions.
        Think of it as a post-processor for method definitions.
        
        It provides a single function <autoself>.  Given a function as argument,
        <autoself> will return an equivalent function that takes the variable 'self'
        as an extra argument in position zero.  If the function does not refer to a
        variable named 'self', then it is returned unmodified.
        
        For example, defining the method <likes>  using:
        
        def likes(self,ham,eggs):
        print self, "likes", ham, "and", eggs
        
        Is equivalent to defining it in the following way:
        
        def likes(ham,eggs):
        print self, "likes", ham, "and", eggs
        likes = autoself(likes)
        
        Or neater, using the @autoself decorator.  Of course, this isn't going to save
        you any typing!  <autoself> can also be applied to a class, and will autoselfify
        all functions in that class's dict:
        
        class HeapsLessTyping:
        def likes(ham,eggs):
        print self, "likes", ham, "and", eggs
        def hates(spam):
        print self, "hates", spam
        HeapsLessTyping = autoself(HeapsLessTyping)
        
        When its becomes available (Python 2.6?), it will be even more convenient to
        use this with the class decorator syntax:
        
        @autoself
        class HeapsLessTyping:
        def likes(ham,eggs):
        print self, "likes", ham, "and", eggs
        def hates(spam):
        print self, "hates", spam
        
        Want to save even more typing?  <autoself> can be used as a metaclass to
        work it's magic on all classes defined in a module:
        
        __metaclass__=autoself
        class LookNoSelf:
        def __init__(my,special,args):
        self.my = my
        self.special = special
        self.args = args
        class FiveKeystrokesSaved:
        def __init__(this,works,great):
        self.this = this
        self.works = works
        self.great = great
        
        Using this style, you will see a net saving in keystrokes with only
        five method definitions per module!
        
        
Keywords: self method
Platform: UNKNOWN
