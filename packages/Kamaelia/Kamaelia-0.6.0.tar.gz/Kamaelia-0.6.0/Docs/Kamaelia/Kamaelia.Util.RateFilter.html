<html>
<head>
<title> Components/pydoc/Kamaelia.Util.RateFilter </title>

<style>
a {
    text-decoration: none;
}
*.thinborder {
    border-style: solid;
    border-width: thin;
}
.boxright {
    float: right;
    width: 20em;
    padding: 0.5em;
    margin: 1em;
    clear: right;
    border: 1px solid;
    text-align: left;
}
.leftbar {
    float: left;
    width: 10em;
    padding-left: 1.0em;
    padding-right: 0.5em;
    padding-top: 0em;
    margin-top: 0em;
    margin-bottom: 1em;
    margin-left: 0em;
    margin-right: 1em;
    clear: left;
    text-align: left;
}
.boxleft{
    float: left;
    width: 9.5em;
    padding-top: 0.5em;
    padding-bottom: 0.5em;
    padding-left: 1.0em;
    padding-right: 1.0em;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 0em;
    margin-right: 1em;
    clear: left;
    border-top: 5px solid;
    border-bottom: 5px solid;
    text-align: left;
}
.none { width: 100%;
        clear: both;
}

.subsection { }
.sectionheader {
                 text-align: center;
                 font-weight: bold;
                 padding-bottom: 1em;
               }
.sectioncontent { font-size: 0.9em;
                  margin-left: 2em;
                  line-height: 1.5;
                  text-align: left;
                }
.verticaldivider { float: bottom;
                   width: 100%;
                 }

 .rbroundbox_green { background: url(/t/green.corners-top.png) repeat-x; 
               width: 50%;
               float: right;
               }
 .rbtop_green div { background: url(/t/green.corners-topleft.png) no-repeat top left; }
 .rbtop_green { background: url(/t/green.corners-topright.png) no-repeat top right; }

 .rbcontent_green div { background: url(/t/green.corners-right.png) repeat-y right; 
                }
 .rbcontent_green { background: url(/t/green.corners-left.png) repeat-y left; 
              padding-left: 1.5em;
            }

 .rbbot_green div { background: url(/t/green.corners-bottomleft.png) no-repeat bottom left; }
 .rbbot_green { background: url(/t/green.corners-bottomright.png) no-repeat bottom right; }
 .rbbottom_green { background: url(/t/green.corners-bottom.png) repeat-x; }
 .rbtop_green div, .rbtop_green, .rbbot_green div, .rbbot_green {
 width: 100%;
 height: 23px;
 font-size: 1px;
 }
body {
   text-align: justify;
}

.sidebar {
    width: 10em;
    float: left;
    padding-left: 1em;
    padding-right: 1em;

}
.bodytext {

    margin: 0 5em 0em 5em;
    float: auto;
    padding-left: 1em;
    padding-right: 1em;
}
.topnav {
    padding-top: 0em;
    margin-top: 0em;
    float: right;
}
</style>

</head>
<body style="font-size: 10pt; font-family: verdana,arial,helvetica,sans-serif; line-height: 1.8;">
</div>

</span></p>
<div class="bodytext">
<html>
<head>
<title>Kamaelia docs : Kamaelia.Util.RateFilter</title>
<style type="test/css">
pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }
</style>
</head>
<body>
<div class="container">
<div class="section">
<h1><a class="reference" href="Kamaelia.html">Kamaelia</a>.<a class="reference" href="Kamaelia.Util.html">Util</a>.<a class="reference" href="Kamaelia.Util.RateFilter.html">RateFilter</a></h1>
</div>
<div class="section">
<div class="container">
<ul class="simple">
<li><strong>component <a class="reference" href="Kamaelia.Util.RateFilter.ByteRate_RequestControl.html">ByteRate_RequestControl</a></strong></li>
<li><strong>component <a class="reference" href="Kamaelia.Util.RateFilter.MessageRateLimit.html">MessageRateLimit</a></strong></li>
<li><strong>component <a class="reference" href="Kamaelia.Util.RateFilter.OnDemandLimit.html">OnDemandLimit</a></strong></li>
<li><strong>component <a class="reference" href="Kamaelia.Util.RateFilter.VariableByteRate_RequestControl.html">VariableByteRate_RequestControl</a></strong></li>
</ul>
</div>
<ul class="simple">
<li><a class="reference" href="#168">Message Rate limiting</a><ul>
<li><a class="reference" href="#169">Example Usage</a><ul>
</ul>
</li>
<li><a class="reference" href="#170">How does it work?</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#171">Rate Control</a><ul>
<li><a class="reference" href="#172">Example Usage</a><ul>
</ul>
</li>
<li><a class="reference" href="#173">How does it work?</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#174">Flow limiting by request</a><ul>
<li><a class="reference" href="#175">Example Usage</a><ul>
</ul>
</li>
<li><a class="reference" href="#176">How does it work?</a><ul>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section">
<p>These components limit the rate of data flow, either by buffering or by taking
charge and requesting data at a given rate.</p>
<div class="section">
<h2 id="168"><a id="message-rate-limiting" name="message-rate-limiting">Message Rate limiting</a></h2>
<p>This component buffers incoming messages and limits the rate at which they are
sent on.</p>
<div class="section">
<h3 id="169"><a id="example-usage" name="example-usage">Example Usage</a></h3>
<p>Regulating video to a constant framerate, buffering 2 seconds of data before
starting to emit frames:</p>
<pre class="literal-block">
Pipeline( RateControlledFileReader(...),
          DiracDecoder(),
          MessageRateLimit(messages_per_second=framerate, buffer=2*framerate),
          VideoOverlay(),
        ).activate()
</pre>
</div>
<div class="section">
<h3 id="170"><a id="how-does-it-work" name="how-does-it-work">How does it work?</a></h3>
<p>Data items sent to this component's &quot;inbox&quot; inbox are buffered. Once the buffer
is full, the component starts to emit items at the specified rate to its
&quot;outbox&quot; outbox.</p>
<p>If there is a shortage of data in the buffer, then the specified rate of output
will, obviously, not be sustained. Items will be output when they are available.</p>
<p>The specified rate serves as a ceiling limit - items will never be emitted
faster than that rate, though they may be emitted slower.</p>
<p>Make sure you choose a sufficient buffer size to handle any expected
jitter/temporary shortages of data.</p>
<p>If a producerFinished or shutdownMicroprocess message is received on the
components' &quot;control&quot; inbox, it is sent on out of the &quot;signal&quot; outbox. The
component will then immediately terminate.</p>
</div>
</div>
<div class="section">
<h2 id="171"><a id="rate-control" name="rate-control">Rate Control</a></h2>
<p>These components control the rate of a system by requesting data at a given
rate. The 'variable' version allows this rate to the changed whilst running.</p>
<div class="section">
<h3 id="172"><a id="id1" name="id1">Example Usage</a></h3>
<p>Reading from a file at a fixed rate:</p>
<pre class="literal-block">
Graphline( ctrl   = ByteRate_RequestControl(rate=1000, chunksize=32),
           reader = PromptedFileReader(filename=&quot;myfile&quot;, readmode=&quot;bytes&quot;),
           linkages = {
                (&quot;ctrl&quot;, &quot;outbox&quot;) : (&quot;reader&quot;,&quot;inbox&quot;),
                (&quot;reader&quot;, &quot;outbox&quot;) : (&quot;self&quot;, &quot;outbox&quot;),

                (&quot;self&quot;, &quot;control&quot;) : (&quot;reader&quot;, &quot;control&quot;),
                (&quot;reader&quot;, &quot;signal&quot;) : (&quot;ctrl&quot;, &quot;control&quot;),
                (&quot;ctrl, &quot;signal&quot;) : (&quot;self&quot;, &quot;signal&quot;),
              }
</pre>
<p>Note that the &quot;signal&quot;-&quot;control&quot; path goes in the opposite direction so that
when the file is finished reading, the ByteRate_RequestControl component
receives a shutdown message.</p>
<p>Reading from a file at a varying rate (send new rates to the &quot;inbox&quot; inbox):</p>
<pre class="literal-block">
Graphline( ctrl   = VariableByteRate_RequestControl(rate=1000, chunksize=32),
           reader = PromptedFileReader(filename=&quot;myfile&quot;, readmode=&quot;bytes&quot;),
           linkages = {
                  (&quot;self&quot;, &quot;inbox&quot;) : (&quot;ctrl&quot;, &quot;inbox&quot;),
                  (&quot;ctrl&quot;, &quot;outbox&quot;) : (&quot;reader&quot;,&quot;inbox&quot;),
                  (&quot;reader&quot;, &quot;outbox&quot;) : (&quot;self&quot;, &quot;outbox&quot;),

                  (&quot;self&quot;, &quot;control&quot;) : (&quot;reader&quot;, &quot;control&quot;),
                  (&quot;reader&quot;, &quot;signal&quot;) : (&quot;ctrl&quot;, &quot;control&quot;),
                  (&quot;ctrl, &quot;signal&quot;) : (&quot;self&quot;, &quot;signal&quot;),
              }
         ).activate()
</pre>
<p>Note that the &quot;signal&quot;-&quot;control&quot; path goes in the opposite direction so that
when the file is finished reading, the VariableByteRate_RequestControl component
receives a shutdown message.</p>
</div>
<div class="section">
<h3 id="173"><a id="id2" name="id2">How does it work?</a></h3>
<p>These components emit from their &quot;outbox&quot; outboxes, requests for data at the
specified rate. Each request is an integer specifying the number of items.</p>
<p>Rates are in no particular units (eg. bitrate, framerate) - you can use it for
whatever purpose you wish. Just ensure your values fit the units you are working
in.</p>
<p>At initialisation, you specify not only the rate, but also the chunk size or
chunk rate. For example, a rate of 12 and chunksize of 4 will result in 3
requests per second, each for 4 items. Conversely, specifying a rate of 12 and
a chunkrate of 2 will result in 2 requests per second, each for 6 items.</p>
<p>The rate and chunk size or chunk rate you specify does not have to be integer or
divide into integers. For example, you can specify a rate of 10 and a chunksize
of 3. Requests will then be emitted every 0.3 seconds, each for 3 items.</p>
<p>When requests are emitted, they will always be for an integer number of items.
Rounding errors are averaged out over time, and should not accumulate. Rounding
will occur if chunksize, either specified, or calculated from chunkrate, is
non-integer.</p>
<p>At initialisation, you can also specify that chunk 'aggregation' is permitted.
If permitted, then the component can choose to exceed the specified chunksize.
For example if, for some reason, the component gets behind, it might aggregate
two requests together - the next request will be for twice as many items.</p>
<p>Another example would be if you, for example, specify a rate of 100 and
chunkrate of 3. The 3 requests emitted every second will then be for 33, 33 and
34 items.</p>
<p>The VariableByteRate_RequestControl component allows the rate to be changed
on-the-fly. Send a new rate to the component's &quot;inbox&quot; inbox and it will be
adopted immediately. You cannot change the chunkrate or chunksize.</p>
<p>The new rate is adopted at the instant it is received. There will be no glitches
in the apparent rate of requests due to your changing the rate.</p>
<p>If a producerFinished or shutdownMicroprocess message is received on the
components' &quot;control&quot; inbox, it is sent on out of the &quot;signal&quot; outbox. The
component will then immediately terminate.</p>
</div>
</div>
<div class="section">
<h2 id="174"><a id="flow-limiting-by-request" name="flow-limiting-by-request">Flow limiting by request</a></h2>
<p>This component buffers incoming data and emits it one item at a time, whenever
a &quot;NEXT&quot; request is received.</p>
<div class="section">
<h3 id="175"><a id="id3" name="id3">Example Usage</a></h3>
<p>An app that reads data items from a file, then does something with then one at a
time when the user clicks a visual button in pygame:</p>
<pre class="literal-block">
Graphline( source   = RateControlledFileReader(..., readmode=&quot;lines&quot;),
           limiter  = OnDemandLimit(),
           trigger  = Button(caption=&quot;Click for next&quot;,msg=&quot;NEXT&quot;),
           dest     = consumer(...),
           linkages = {
                   (&quot;source&quot;, &quot;outbox&quot;) : (&quot;limiter&quot;, &quot;inbox&quot;),
                   (&quot;limiter&quot;, &quot;outbox&quot;) : (&quot;dest&quot;, &quot;inbox&quot;),
                   (&quot;trigger&quot;, &quot;outbox&quot;) : (&quot;limiter&quot;, &quot;slidecontrol&quot;)
               }
         ).activate()
</pre>
</div>
<div class="section">
<h3 id="176"><a id="id4" name="id4">How does it work?</a></h3>
<p>Data items sent to the component's &quot;inbox&quot; inbox are buffered in a queue.
Whenever a &quot;NEXT&quot; message is received on the component's &quot;slidecontrol&quot; inbox,
an item is taken out of the queue and sent out of the &quot;outbox&quot; outbox.</p>
<p>Items come out in the same order they go in.</p>
<p>If a &quot;NEXT&quot; message is received but there are no items waiting in the queue, the
&quot;NEXT&quot; message is discarded and nothing is emitted.</p>
<p>If a producerFinished message is received on the components' &quot;control&quot; inbox, it
is sent on out of the &quot;signal&quot; outbox. The component will then immediately
terminate.</p>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="reference" href="Kamaelia.html">Kamaelia</a>.<a class="reference" href="Kamaelia.Util.html">Util</a>.<a class="reference" href="Kamaelia.Util.RateFilter.html">RateFilter</a>.<a class="reference" href="Kamaelia.Util.RateFilter.ByteRate_RequestControl.html">ByteRate_RequestControl</a></h1>
<div class="section">
<h2 id="symbol-ByteRate_RequestControl">class ByteRate_RequestControl(<a class="reference" href="Axon.Component.component.html">Axon.Component.component</a>)</h2>
<p>ByteRate_RequestControl([rate][,chunksize][,chunkrate][,allowchunkaggregation]) -&gt; new ByteRate_RequestControl component.</p>
<p>Controls rate of a data source by, at a controlled rate, emitting
integers saying how much data to emit.</p>
<p>Keyword arguments:</p>
<ul class="simple">
<li>rate                   -- qty of data items per second (default=100000)</li>
<li>chunksize              -- None or qty of items per 'chunk' (default=None)</li>
<li>chunkrate              -- None or number of chunks per second (default=10)</li>
<li>allowchunkaggregation  -- if True, chunksize will be enlarged if 'catching up' is necessary (default=False)</li>
</ul>
<p>Specify either chunksize or chunkrate, but not both.</p>
<div class="section">
<h3><a id="symbol-ByteRate_RequestControl.Inboxes" name="symbol-ByteRate_RequestControl.Inboxes">Inboxes</a></h3>
<ul class="simple">
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : NOT USED</li>
</ul>
</div>
<div class="section">
<h3><a id="symbol-ByteRate_RequestControl.Outboxes" name="symbol-ByteRate_RequestControl.Outboxes">Outboxes</a></h3>
<ul class="simple">
<li><strong>outbox</strong> : requests for 'n' items</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="container">
</div>
<div class="section">
<h4><a id="symbol-ByteRate_RequestControl.__init__" name="symbol-ByteRate_RequestControl.__init__">__init__(self[, rate][, chunksize][, chunkrate][, allowchunkaggregation])</a></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
</div>
<div class="section">
<h4><a id="symbol-ByteRate_RequestControl.getChunksToSend" name="symbol-ByteRate_RequestControl.getChunksToSend">getChunksToSend(self)</a></h4>
<p>Generator. Returns the size of chunks to be requested (if any) to
'catch up' since last time this method was called.</p>
</div>
<div class="section">
<h4><a id="symbol-ByteRate_RequestControl.main" name="symbol-ByteRate_RequestControl.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
<div class="section">
<h4><a id="symbol-ByteRate_RequestControl.resetTiming" name="symbol-ByteRate_RequestControl.resetTiming">resetTiming(self)</a></h4>
<p>Resets the timing variable used to determine when the next time to send
a request is.</p>
</div>
<div class="section">
<h4><a id="symbol-ByteRate_RequestControl.shutdown" name="symbol-ByteRate_RequestControl.shutdown">shutdown(self)</a></h4>
<p>Returns True if shutdown message received.</p>
</div>
</div>
<div class="section">
</div>
</div>
<h1><a class="reference" href="Kamaelia.html">Kamaelia</a>.<a class="reference" href="Kamaelia.Util.html">Util</a>.<a class="reference" href="Kamaelia.Util.RateFilter.html">RateFilter</a>.<a class="reference" href="Kamaelia.Util.RateFilter.MessageRateLimit.html">MessageRateLimit</a></h1>
<div class="section">
<h2 id="symbol-MessageRateLimit">class MessageRateLimit(<a class="reference" href="Axon.Component.component.html">Axon.Component.component</a>)</h2>
<p>MessageRateLimit(messages_per_second[, buffer]) -&gt; new MessageRateLimit component.</p>
<p>Buffers messages and outputs them at a rate limited by the specified rate
once the buffer is full.</p>
<p>Keyword arguments:</p>
<ul class="simple">
<li>messages_per_second  -- maximum output rate</li>
<li>buffer               -- size of buffer (0 or greater) (default=60)</li>
</ul>
<div class="section">
<h3><a id="symbol-MessageRateLimit.Inboxes" name="symbol-MessageRateLimit.Inboxes">Inboxes</a></h3>
<ul class="simple">
<li><strong>control</strong> : NOT USED</li>
<li><strong>inbox</strong> : Incoming items/messages</li>
</ul>
</div>
<div class="section">
<h3><a id="symbol-MessageRateLimit.Outboxes" name="symbol-MessageRateLimit.Outboxes">Outboxes</a></h3>
<ul class="simple">
<li><strong>outbox</strong> : Items/messages limited to specified maximum output rate</li>
<li><strong>signal</strong> : NOT USED</li>
</ul>
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="container">
</div>
<div class="section">
<h4><a id="symbol-MessageRateLimit.__init__" name="symbol-MessageRateLimit.__init__">__init__(self, messages_per_second[, buffer])</a></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
</div>
<div class="section">
<h4><a id="symbol-MessageRateLimit.main" name="symbol-MessageRateLimit.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
</div>
<div class="section">
</div>
</div>
<h1><a class="reference" href="Kamaelia.html">Kamaelia</a>.<a class="reference" href="Kamaelia.Util.html">Util</a>.<a class="reference" href="Kamaelia.Util.RateFilter.html">RateFilter</a>.<a class="reference" href="Kamaelia.Util.RateFilter.OnDemandLimit.html">OnDemandLimit</a></h1>
<div class="section">
<h2 id="symbol-OnDemandLimit">class OnDemandLimit(<a class="reference" href="Axon.Component.component.html">Axon.Component.component</a>)</h2>
<p>OnDemandLimit() -&gt; new OnDemandLimit component.</p>
<p>A component that receives data items, but only emits them on demand, one at
a time, when &quot;NEXT&quot; messages are received on the &quot;slidecontrol&quot; inbox.</p>
<div class="section">
<h3><a id="symbol-OnDemandLimit.Inboxes" name="symbol-OnDemandLimit.Inboxes">Inboxes</a></h3>
<ul class="simple">
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : Data items to be passed on, on demand.</li>
<li><strong>slidecontrol</strong> : 'NEXT' requests to emit a data item.</li>
</ul>
</div>
<div class="section">
<h3><a id="symbol-OnDemandLimit.Outboxes" name="symbol-OnDemandLimit.Outboxes">Outboxes</a></h3>
<ul class="simple">
<li><strong>outbox</strong> : Data items, when requested.</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="container">
</div>
<div class="section">
<h4><a id="symbol-OnDemandLimit.main" name="symbol-OnDemandLimit.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
</div>
<div class="section">
</div>
</div>
<h1><a class="reference" href="Kamaelia.html">Kamaelia</a>.<a class="reference" href="Kamaelia.Util.html">Util</a>.<a class="reference" href="Kamaelia.Util.RateFilter.html">RateFilter</a>.<a class="reference" href="Kamaelia.Util.RateFilter.VariableByteRate_RequestControl.html">VariableByteRate_RequestControl</a></h1>
<div class="section">
<h2 id="symbol-VariableByteRate_RequestControl">class VariableByteRate_RequestControl(<a class="reference" href="Axon.Component.component.html">Axon.Component.component</a>)</h2>
<p>ByteRate_RequestControl([rate][,chunksize][,chunkrate][,allowchunkaggregation]) -&gt; new ByteRate_RequestControl component.</p>
<p>Controls rate of a data source by, at a controlled rate, emitting
integers saying how much data to emit. Rate can be changed at runtime.</p>
<p>Keyword arguments:
- rate                   -- qty of data items per second (default=100000)
- chunksize              -- None or qty of items per 'chunk' (default=None)
- chunkrate              -- None or number of chunks per second (default=10)
- allowchunkaggregation  -- if True, chunksize will be enlarged if 'catching up' is necessary (default=False)</p>
<p>Specify either chunksize or chunkrate, but not both.</p>
<div class="section">
<h3><a id="symbol-VariableByteRate_RequestControl.Inboxes" name="symbol-VariableByteRate_RequestControl.Inboxes">Inboxes</a></h3>
<ul class="simple">
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : New rate</li>
</ul>
</div>
<div class="section">
<h3><a id="symbol-VariableByteRate_RequestControl.Outboxes" name="symbol-VariableByteRate_RequestControl.Outboxes">Outboxes</a></h3>
<ul class="simple">
<li><strong>outbox</strong> : requests for 'n' items</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="container">
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.__init__" name="symbol-VariableByteRate_RequestControl.__init__">__init__(self[, rate][, chunksize][, chunkrate][, allowchunkaggregation])</a></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.changeRate" name="symbol-VariableByteRate_RequestControl.changeRate">changeRate(self, newRate, now)</a></h4>
<p>Change the rate.</p>
<p>Guaranteed to not cause a glitch in the rate of output.</p>
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.getChunksToSend" name="symbol-VariableByteRate_RequestControl.getChunksToSend">getChunksToSend(self, now)</a></h4>
<p>Generator. Returns the size of chunks to be requested (if any) to
'catch up' since last time this method was called.</p>
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.main" name="symbol-VariableByteRate_RequestControl.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.resetTiming" name="symbol-VariableByteRate_RequestControl.resetTiming">resetTiming(self, now)</a></h4>
<p>Resets the timing variable used to determine when the next time to send
a request is.</p>
</div>
<div class="section">
<h4><a id="symbol-VariableByteRate_RequestControl.shutdown" name="symbol-VariableByteRate_RequestControl.shutdown">shutdown(self)</a></h4>
<p>Returns True if shutdown message received.</p>
</div>
</div>
<div class="section">
</div>
</div>
</div>
</div>





<div class="section">
<h1>Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer?
Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback
<a class="reference" href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701">here</a>
in reply to the documentation thread in the Kamaelia blog.</p>
</div>


<p><i>-- Automatic documentation generator, 19 Oct 2008 at 14:29:09 UTC/GMT</i>
</body></html>


</div>
<div style="float: left; width: 5em; text-align: center"><img src='/Kamaelia.gif'></div>
<div class="bodytext">
This is a page from the Kamaelia website. You can find the original here:
<ul><li><a href="http://www.kamaelia.org/Components/pydoc/Kamaelia.Util.RateFilter.html">
http://www.kamaelia.org/Components/pydoc/Kamaelia.Util.RateFilter
</a></ul>

</div>
</body>
</html>
