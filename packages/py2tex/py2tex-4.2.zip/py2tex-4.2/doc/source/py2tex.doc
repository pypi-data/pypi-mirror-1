%^^A py2tex.doc -*-LaTeX-*- macros to makeup Python programs

\def\fileversion{v3.4}
\def\filedate{2006/03/29}
\def\docdate{2006/03/29}

% \section{Py2tex.sty}
%
% The \|py2tex| documentstyle option can be used to typeset files
% generated by the \|py2tex| script.  Directions on the usage of the
% script and the documentstyle option can be found in \|py2tex.py|.
%
% The implementation and customization of the documentstyle are
% documented in \|py2tex.doc|.
%
% This file can be used both as a style file for \LaTeX\ documents,
% and as a package for \LaTeX2$\epsilon$ documents.
%    \begin{macrocode}
\@ifundefined{ProvidesPackage}{}%
  {\ProvidesPackage{py2tex}}
%    \end{macrocode}

% \subsection{Customization}
%
% If you would like to change the definition of one or more macros in
% this section, you are advised to make a new style file along the
% following lines, rather than change this file.
% 
% {\vskip\parskip\parskip=0mm\obeylines\tt
% \% mypy.sty
% \char`\\input py2tex.sty
% {\rm $\langle$new definitions$\rangle$}
% \% EOF
% }
%
% \noindent
% Such a derived style file can be used as a document style option
% instead of~\|py2tex|.
%
% In the rest of this section the customizable macros and their
% default definitions are documented.

% The \|\PythonFile| macro is meant to typeset a heading.  It is
% called with the name of the source file as the first parameter and a
% time stamp as the second parameter.  It uses the \|\PythonSection|
% command to generate the header. By default it uses the \|\section|
% command, but the \|\PythonSection| macro can be \|\let| equal to an
% arbitrary sectioning command (or any other command that takes two
% parameters with syntax~\|[#1]{#2}|).
%    \begin{macrocode}
\let\PythonSection=\section
\def\PythonFile#1#2{\PythonSection[\upcasechar#1]%
  {\upcasechar#1\thinspace--\thinspace#2}\bigskip}
\def\upcasechar#1{\uppercase{#1}}
%    \end{macrocode}

% The \|\PythonEmptyLines| macro is called to typeset empty lines in
% the source.  The number of empty lines is given as a parameter, but
% is ignored by default.  The default behavior is to typeset just one
% blank line.
%    \begin{macrocode}
\def\PythonEmptyLines#1{\PythonPageBreak
  \vskip\baselineskip }
\def\PythonNumber#1{\llap{\rm\small #1\ }}
%    \end{macrocode}

% The \|\PythonCalcIndent| macro is called once, just before the
% \|\input| macro, to calculate the indentation level.  By default it
% measures the width of a box with the keyword $\PythonKeyword{def}$
% and some whitespace in it.
%    \begin{macrocode}
\def\PythonCalcIndent{%
  \setbox0=\hbox{$\K{def}\ $}\PythonDent=\wd0
  \advance\PythonDent by .8 pt }
%    \end{macrocode}

% The following macros are used to typeset various Python constructs.
% Note that they are all designed to be used in math mode.  By
% default, variables are typeset upright and functions slanted.  Use
% the macro \|PythonSlantedVariables| to have it just the other way
% round.  (I personally prefer the default setting, except when I use
% many one-letter variables which are typeset in math italics.)
%    \begin{macrocode}
\ifx\selectfont\undefined
  \let\PythonFont=\relax
  \let\PythonSlFont=\sl
  \let\PythonBfFont=\bf
\else
  \message{NFSS font settings}
  \let\PythonFont=\sffamily
  \def\PythonSlFont{\PythonFont\slshape}
  \def\PythonBfFont{\PythonFont\bfseries}
\fi
\def\PythonSlantedFunctions{%
  \def\PythonFunction##1{\mbox{\PythonSlFont ##1\/}}%
  \def\PythonVariable##1{\mbox{\PythonFont ##1}}}
\def\PythonSlantedVariables{%
  \def\PythonFunction##1{\mbox{\PythonFont ##1}}%
  \def\PythonVariable##1{\mbox{\PythonSlFont ##1\/}}}
\PythonSlantedFunctions
\def\PythonKeyword#1{\mbox{\PythonBfFont #1}}%
\def\PythonOperator#1{\mathrel{\PythonKeyword{#1}}}
\def\PythonSymbol#1{#1}
\def\PythonHexadecimal#1{\mbox{\tt 0x#1}}
\def\PythonOctal#1{\mbox{\it 0#1\/}}
\def\PythonExponentFloat#1#2#3{#1{\cdot}10^{#2}{\mathrm\relax #3}}
\def\PythonPlainNumber#1#2{#1{\mathrm\relax#2}}
\def\PythonBreakPoint{\penalty 100\relax }
%    \end{macrocode}

% At the end of this file there is a section that specifies how the
% operators and relations should be typeset.  These definitions are at
% the end because they use the macro \|\PythonDefIntern|.  This macro
% can also be used to override these definitions.  Likewise the macro
% \|\PythonDef| can be used to determine how certain variables and/or
% functions should be typeset.  For examples of the use of these
% macros, take a look at the source code of the following fragment.
% \PythonSource*{definitions.pt}

% \subsection{Implementation}
%
% In this section the implementation of the style is documented.
%
% First a dimension register is allocated to hold the standard
% indentation.  Furthermore an \|\if| construct is initialized that is
% used to distinguish between the normal and the starred form of
% \|\PythonSource|.
%    \begin{macrocode}
\newdimen\PythonDent \PythonDent=2em
\newif\ifOuterPython
%    \end{macrocode}

% The \|\PythonSource| macro checks for the star, then it sets the
% \|OuterPython| flag accordingly, and calls \|\@PythonSource|.
%    \begin{macrocode}
\def\PythonSource{%
  \@ifstar
    {\OuterPythonfalse\@PythonSource}%
    {\OuterPythontrue\@PythonSource}}
%    \end{macrocode}

% The \|\@PythonSource| macro does the real work.
%    \begin{macrocode}
\def\@PythonSource#1{\begingroup
  \PythonMode
%    \end{macrocode}
% Then a lot of short versions of Python specific macros are \|\let|
% equal to  their long forms.
%    \begin{macrocode}
  \let\B=  \PythonBlockComment
  \let\BP= \PythonBreakPoint
  \let\DS= \PythonDocString
  \let\E=  \PythonEmptyLines
  \let\ESC=\par
  \let\EXP=\PythonExponentFloat
  \let\F=  \Python@function
  \let\HEX=\PythonHexadecimal
  \let\I=  \PythonIndent
  \let\K=  \Python@keyword
  \let\M=  \PythonMetaVariable
  \let\NUM=\PythonPlainNumber
  \let\O=  \Python@operator
  \let\OCT=\PythonOctal
  \let\PB= \PythonPageBreak
  \let\S=  \PythonString
  \let\V=  \Python@variable
  \let\Y=  \Python@symbol
%    \end{macrocode}
% Normally the file name and time are put into a heading and lines are
% numbered, but this is turned off in the starred version of the
% \|\PythonSource| macro.
%    \begin{macrocode}
  \ifOuterPython
    \let\File=\PythonFile
    \let\PythonNr=\PythonNumber
  \else
    \let\File\@gobbletwo
    \let\PythonNr\@gobble
  \fi
%    \end{macrocode}
% Finally calculate the indentation level.
%    \begin{macrocode}
  \PythonCalcIndent
%    \end{macrocode}
% Now \|\input| the file.  The \|\par| ensures that hanging
% indentation is not lost for the last line of code.
%    \begin{macrocode}
  \input #1
  \par\endgroup}
%    \end{macrocode}

% The \|\PythonMode| macro sets some \TeX\ parameters in order to
% typeset Python code, rather than running text.  This macro is
% complementary to the \|\TextMode| macro defined below.
%    \begin{macrocode}
\def\PythonMode{
  \par
  \parskip=0mm plus 1 pt
  \parindent=0mm
  \rightskip=0mm plus .5\hsize
  \interlinepenalty=300 }
%    \end{macrocode}

% The \|\PythonIndent| macro is used to start a new line of Python
% code.  It starts a new paragraph with the proper indentation and one
% and a half standard indentation more hanging indentation.
% Furthermore it calls \|\PythonNr| to typeset the line number.
%    \begin{macrocode}
\def\PythonIndent#1#2{\endgraf\penalty 500
  \hangindent=#2\PythonDent
  \advance\hangindent by 1.5\PythonDent
  \hangafter=1
  \leavevmode\strut\PythonNr{#1}%
  \hskip #2\PythonDent\relax }
%    \end{macrocode}

% The \|\PythonOuterBlock| and \|\PythonOuterBlockEnd| macros delimit
% an unindented block comment.  An outer block does not imply grouping
% and is delimited by \|\OuterMarker|s.  The starred form of
% \|\PythonOuterBlock| leaves out the opening marker.
%    \begin{macrocode}
\def\PythonOuterBlock{\TextMode
  \@ifstar{}{\@start@outer@block}}
\def\@start@outer@block{%
  \par\OuterMarker\nobreak\vskip -\parskip}
\def\PythonOuterBlockEnd{%
  \par\nobreak\OuterMarker\PythonMode}
%    \end{macrocode}

% The \|\PythonBlockComment| macro starts a block comment.  It defines
% \|\subtract| to yield the amount of indentation to subtract from the
% width of the box containing the comment and calls
% \|\PythonInnerBlock| to do the real work.
%    \begin{macrocode}
\def\PythonBlockComment#1#2{\PythonPageBreak
  \PythonIndent{#1}{#2}%
  \def\subtract{-#2\PythonDent}\PythonInnerBlock}
%    \end{macrocode}

% The \|\PythonInnerBlock| macro starts a \|\hbox| containing the
% lines that mark a block comment and a \|\vtop| that contains the
% actual comment (So the line number will be aligned with the first
% line of the comment).  It uses \|\subtract| defined by
% \|\PythonBlocComment| to reduce the width of the \|\vtop|.  It also
% subtracts the width of the marker from the width of the \|\vtop|.
%    \begin{macrocode}
\def\PythonInnerBlock#{\hbox\bgroup\strut \Marker
  \vtop\bgroup
    \TextMode
    \let\ESC=\PythonEscapeBlockComment
    \advance\hsize by \subtract
    \setbox0=\hbox{\Marker}\advance\hsize by -\wd0
    \textwidth=\hsize
    \linewidth=\hsize
%    \end{macrocode}
% The next command causes the \|\hbox| to be wrapped up immediately
% when the \|\vtop| is completed.
%    \begin{macrocode}
    \aftergroup\egroup
%    \end{macrocode}
% Gobble the opening brace before reading the comment.
%    \begin{macrocode}
    \let\next=}
%    \end{macrocode}

% The \|\PythonDocBlock| macro starts a block that contains a doc string.
%    \begin{macrocode}
\def\PythonDocBlock{\TextMode
  \@ifstar{}{\@start@doc@block}}
\def\@start@doc@block{%
  \par\DocOuterMarker\nobreak\vskip -\parskip}
%    \end{macrocode}

% The \|\PythonDocBlockEnd| macro ends a block that contains a doc string.
%    \begin{macrocode}
\def\PythonDocBlockEnd{%
  \par\nobreak\DocOuterMarker\PythonMode}

%    \end{macrocode}

% The \|\PythonDocString| macro formats a doc string in a way similar to
% the \|\PythonInnerBlock| macro, except that it uses a different marker.
%    \begin{macrocode}
\def\PythonDocString#1#2{\PythonPageBreak
  \PythonIndent{#1}{#2}%
  \def\subtract{-#2\PythonDent}\PythonDocStringHelper}

\def\PythonDocStringHelper#{\hbox\bgroup\strut \DocStringMarker
  \vtop\bgroup
    \TextMode
    \advance
    \hsize by \subtract
    \setbox0=\hbox{\DocStringMarker}\advance\hsize by -\wd0
    \textwidth=\hsize
    \linewidth=\hsize
    \aftergroup\egroup
    \let\next=}
%    \end{macrocode}

% The \|\TextMode| macro sets some \TeX\ parameters to typeset running
% text rather than Python code.
%    \begin{macrocode}
\def\TextMode{\par
  \rightskip=0mm%
  \parskip=\baselineskip
  \advance\parskip by 0mm plus 1pt
  \interlinepenalty=0}
%    \end{macrocode}

% The \|\PythonEscapeBlockComment| macro can be used in block comments
% by the name \|\ESC| to escape the \|\vtop| containing the comment
% and typeset material in outer vertical mode.  First the \|\vtop|
% started by \|\PythonBlockComment| is closed.  This also closes the
% \|\hbox| around it, leaving us in outer vertical mode.  Then two
% levels of grouping are opened.  One to contain parameter settings
% local to the escaped comment and one in order to end the last
% paragraph in the comment\dash with an \|\aftergroup|
% construction\dash before closing the outer level of grouping.
%    \begin{macrocode}
\def\PythonEscapeBlockComment{\par
    \vskip.5\baselineskip\vskip.5\MarkerSep
  \egroup\par\nobreak
  \bgroup
    \vskip-.5\baselineskip\vskip-.5\MarkerSep
    \EscapeMarker\nobreak
    \TextMode
    \bgroup
      \vskip -\parskip
      \aftergroup\EndEscape}
\def\EndEscape{\par\nobreak\EscapeMarker\egroup}
%    \end{macrocode}

% The \|\MarkerSep| dimension variable determines the amount of
% whitespace separating the lines typeset with the \|\Marker| and
% \|\OuterMarker| macros.
%    \begin{macrocode}
\newdimen\MarkerSep \MarkerSep=2pt
%    \end{macrocode}

% The \|\Marker| macro is used to typeset the lines that mark a block
% comment.
%    \begin{macrocode}
\def\Marker{\vrule\hskip\MarkerSep\vrule\ }
%    \end{macrocode}

% The \|\DocStringMarker| macro is used to typeset the lines that mark
% a doc string.
%    \begin{macrocode}
\def\DocStringMarker{\vrule width\MarkerSep\ }
%    \end{macrocode}

% The \|\OuterMarker| macro is used to typeset the lines that mark
% unindented comment blocks and escaped sections of block comments.
%    \begin{macrocode}
\def\OuterMarker{\par\nointerlineskip
  \vbox to \baselineskip{\vss
    \hrule width\textwidth \vskip\MarkerSep
    \hrule width\textwidth \vss}%
  \nointerlineskip}
\let\EscapeMarker=\OuterMarker
%    \end{macrocode}

% The \|\DocOuterMarker| macro is used to typeset the lines that mark
% unindented doc string blocks.
%    \begin{macrocode}
\def\DocOuterMarker{\par\nointerlineskip
  \vbox to \baselineskip{\vss
    \hrule height\MarkerSep width\textwidth \vss}%
  \nointerlineskip}
%    \end{macrocode}

% The \|\PythonPageBreak| macro is called at several points to allow a
% page to be short rather than break the code at an ugly point.
% (Breaking before block comments and empty lines is considered good
% and so is breaking before a line that has less indentation than the
% next, except when it is preceded by a block comment.)
%    \begin{macrocode}
\def\PythonPageBreak{\par
  \vskip 0mm plus  4\baselineskip \penalty -200
  \vskip 0mm plus -4\baselineskip \relax }
%    \end{macrocode}

% The \|\PythonString| macro starts a group in which the left quote
% character is active and prints as an undirected quote.
%    \begin{macrocode}
\input{ts1enc.def}
\DeclareTextSymbolDefault{\textquotesingle}{TS1}
{\catcode`\'=\active
  \gdef\PythonString#{\bgroup\tt
    \catcode`\'=\active\def'{\textquotesingle}%
    \let\next= }}
%    \end{macrocode}

% The \|\PythonDef| defines how a function or variable sould be
% typeset.  Usage: \|\PythonDef{name}{definition}|.  In the definition
% \|#1|~refers to the type of identifier (either \|V| or \|F|),
% \|#2|~is the default macro for this type (either \|\PythonFunction|
% or \|\PythonVariable|) and \|#3|~refers to the name of the identifier.
%
% \Eg, \|\PythonDef{row_alpha}{\langle\alpha\rangle}| has the effect
% that \|#row_alpha#| will be typeset as~${\langle\alpha\rangle}$.
%    \begin{macrocode}
\def\prefix@user{ExcUser@}
\def\prefix@intern{ExcIntern@}
\def\Python@def#1{\endgroup\expandafter\def
    \csname \@prefix #1\endcsname ##1##2##3}
\def\PythonDef{\let\@prefix=\prefix@user
  \@prepare\Python@def}
\def\PythonDefIntern{\let\@prefix=\prefix@intern
  \@prepare\Python@def}
\def\Python@let#1{\endgroup
  \expandafter\let\csname \@prefix #1\endcsname }
\def\PythonLet{\let\@prefix=\prefix@user
  \@prepare\Python@let}
\def\PythonLetIntern{\let\@prefix=\prefix@intern
  \@prepare\Python@let}
\def\PythonDefault#1{\PythonLet{#1}\relax}
\def\PythonDefaultIntern#1{\PythonLetIntern{#1}\relax}
%    \end{macrocode}

% The \|\Python@function| macro calls \|\ExcUser@|\#1 or,
% if that doesn't exist, \|PythonFunction|.  The \|\Python@variable|
% macro does the same, but calls the macro \|\PythonVariable| by
% default.
%
% The \|\Python@keyword|, \|\Python@operator| and~\|\Python@symbol|
% call either \|\ExcIntern@|\#1 or \|\PythonKeyword|,
% \|\PythonOperator| or~\|\PythonSymbol| respectively.
%    \begin{macrocode}
\def\Python@function{\Python@identifier
  UF\PythonFunction}
\def\Python@variable{\Python@identifier
  UV\PythonVariable}
\def\Python@symbol{\@prepare\Python@identifier
  IY\PythonSymbol}
\def\Python@keyword{\Python@identifier
  IK\PythonKeyword}
\def\Python@operator{\Python@identifier
  IO\PythonOperator}
\chardef\other=12
\def\@prepare{\begingroup
  \def\do##1{\catcode`##1=\other}\dospecials
  \catcode`\{=1 \catcode`\}=2 }
{\catcode`\_=\other \gdef\@underscore{_}}
\def\global@let@tempa#1{\global\let\@tempa#1}
\def\Python@identifier#1#2#3#4{%
  \if #2Y\relax \endgroup \fi
  \begingroup\let\_=\@underscore \relax
    \if #1U\relax \let\@prefix=\prefix@user
    \else \let\@prefix=\prefix@intern \fi
    \@ifundefined{\@prefix #4}{%
        \global\let\@tempa=\@gobble
      }{\expandafter\global@let@tempa
          \csname \@prefix #4\endcsname
      }\endgroup\let\@tempb=\@tempa
      \@tempb{#2}#3{#4}}
%    \end{macrocode}

% \subsection{More customization}
%
% Here are at last the promised definitions that state how the various
% Python constructs should be typeset.
%    \begin{macrocode}
\PythonDefIntern{[]}{[\,]}
\PythonDefIntern{&}{\mathbin\&}
\PythonDefIntern{|}{\mathbin\vert}
\PythonDefIntern{^}{\mathbin{{}^\wedge}}
\PythonDefIntern{~}{\mathop{{}^\sim}}
\PythonDefIntern{%}{\mathbin{\%}}
\PythonDefIntern{:}{\colon}
%    \end{macrocode}

% There are two predefined ways to handle assignment and equality.
% The default one is to type set the assignment operator as a left
% arrow~($\leftarrow$) and the equality relation as an equals
% sign~($=$).  The alternative is to typeset these tokens as
% themselves, \ie, $=$~and~$\mathrel{==}$ respectively.
%    \begin{macrocode}
\def\PythonToAssign{%
  \PythonDefIntern{=}{\leftarrow}%
  \PythonDefIntern{==}{=}}
\def\PythonIsAssign{%
  \PythonDefaultIntern{=}%
  \PythonDefIntern{==}{\mathrel{==}}}
%    \end{macrocode}

% By default, the relations and operators are typeset in their
% corresponding mathematical notation.  The alternative is to have
% them typeset as they occur in the source.  Note that \|\PythonMath|
% implies \|\PythonToAssign| and that \|\PythonNoMath| implies
% \|\PythonIsAssign|.
%    \begin{macrocode}
\def\PythonMath{%
  \PythonToAssign
  \PythonDefIntern{and}{\land}%
  \PythonDefIntern{in}{\in}%
  \PythonDefIntern{is}{\equiv}%
  \PythonDefIntern{is not}{\not\equiv}%
  \PythonDefIntern{not}{\neg}%
  \PythonDefIntern{not in}{\not\in}%
  \PythonDefIntern{or}{\lor}%
  \PythonDefIntern{<=}{\le}%
  \PythonDefIntern{>=}{\ge}%
  \PythonDefIntern{!=}{\ne}%
  \PythonDefIntern{<>}{\ne}%
  \PythonDefIntern{<<}{\ll}%
  \PythonDefIntern{>>}{\gg}}
\def\PythonNoMath{%
  \PythonIsAssign
  \PythonDefaultIntern{and}%
  \PythonDefaultIntern{in}%
  \PythonDefaultIntern{is}%
  \PythonDefaultIntern{is not}%
  \PythonDefIntern{not}{{##2{##3}}\mathbin{}}%
  \PythonDefaultIntern{not in}%
  \PythonDefaultIntern{or}%
  \PythonDefIntern{<=}{\mathrel{<=}}%
  \PythonDefIntern{>=}{\mathrel{>=}}%
  \PythonDefIntern{!=}{\mathrel{!\!=}}%
  \PythonDefIntern{<>}{\mathrel{<>}}%
  \PythonDefIntern{<<}{\mathrel{<\!<}}%
  \PythonDefIntern{>>}{\mathrel{>\!>}}}
\PythonMath
%    \end{macrocode}

% The \|\PythonSubscript| and \|\PythonSubscriptV| macros can be used
% to typeset the suffix of an identifier with an underscore, as a
% subscript.  For example \|\PythonLet{part_i}\PythonSubscript| will
% cause~\|part_i| to be typeset as~$\PythonVariable{part}_i$.  The
% \|V|-version of the macro is intented to be used with identifiers
% where the base consists of only one letter.  For example, the command
% \|\PythonLet{a_1}\PythonSubscriptV| will cause~\|a_1| to be typeset
% as~$a_1$.
%    \begin{macrocode}
\def\Ident@Base#1\_#2.{#1}
\def\Ident@Sub#1\_#2.{#2}
\def\PythonSubscript#1#2#3{%
  #2{\Ident@Base#3.}_{\Ident@Sub#3.}}
\def\PythonSubscriptV#1#2#3{%
  \Ident@Base#3._{\Ident@Sub#3.}}
%    \end{macrocode}
