<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>Parsing XML and HTML with lxml</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="parsing-xml-and-html-with-lxml">
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu foreign" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu foreign" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu foreign" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions (FAQ)</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#installation">Installation</a></li><li class="menu item"><a href="FAQ.html#contributing">Contributing</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu foreign" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#general-notes">General notes</a></li><li class="menu item"><a href="performance.html#how-to-read-the-timings">How to read the timings</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#a-longer-example">A longer example</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu foreign" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#providing-newer-library-versions-on-mac-os-x">Providing newer library versions on Mac-OS X</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu foreign" id="tutorial"><li class="menu title"><a href="tutorial.html">The lxml.etree Tutorial</a><ul class="submenu"><li class="menu item"><a href="tutorial.html#the-element-class">The Element class</a></li><li class="menu item"><a href="tutorial.html#elements-are-lists">Elements are lists</a></li><li class="menu item"><a href="tutorial.html#elements-carry-attributes">Elements carry attributes</a></li><li class="menu item"><a href="tutorial.html#elements-contain-text">Elements contain text</a></li><li class="menu item"><a href="tutorial.html#tree-iteration">Tree iteration</a></li></ul></li></ul><ul class="menu foreign" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml.etree</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#error-logging">Error logging</a></li><li class="menu item"><a href="api.html#serialisation">Serialisation</a></li><li class="menu item"><a href="api.html#xinclude-and-elementinclude">XInclude and ElementInclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu current" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML and HTML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu foreign" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu foreign" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu foreign" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#the-lxml-objectify-api">The lxml.objectify API</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-lxml-etree?">What is different from lxml.etree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu foreign" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#resolvers">Resolvers</a></li><li class="menu item"><a href="resolvers.html#document-loading-in-context">Document loading in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu foreign" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu foreign" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu foreign" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu foreign" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div><h1 class="title">Parsing XML and HTML with lxml</h1>
<p>lxml provides a very simple and powerful API for parsing XML and HTML.  It
supports one-step parsing as well as step-by-step parsing using an
event-driven API (currently only for XML).</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#parsers" id="id1" name="id1">Parsers</a><ul>
<li><a class="reference" href="#parser-options" id="id2" name="id2">Parser options</a></li>
<li><a class="reference" href="#parsing-html" id="id3" name="id3">Parsing HTML</a></li>
<li><a class="reference" href="#doctype-information" id="id4" name="id4">Doctype information</a></li>
</ul>
</li>
<li><a class="reference" href="#iterparse-and-iterwalk" id="id5" name="id5">iterparse and iterwalk</a><ul>
<li><a class="reference" href="#selective-tag-events" id="id6" name="id6">Selective tag events</a></li>
<li><a class="reference" href="#modifying-the-tree" id="id7" name="id7">Modifying the tree</a></li>
<li><a class="reference" href="#iterwalk" id="id8" name="id8">iterwalk</a></li>
</ul>
</li>
<li><a class="reference" href="#python-unicode-strings" id="id9" name="id9">Python unicode strings</a><ul>
<li><a class="reference" href="#serialising-to-unicode-strings" id="id10" name="id10">Serialising to Unicode strings</a></li>
</ul>
</li>
</ul>
</div>
<p>The usual setup procedure:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; from StringIO import StringIO
</pre>
<div class="section">
<h1><a id="parsers" name="parsers">Parsers</a></h1>
<p>Parsers are represented by parser objects.  There is support for parsing both
XML and (broken) HTML.  Note that XHTML is best parsed as XML, parsing it with
the HTML parser can lead to unexpected results.  Here is a simple example for
parsing XML from an in-memory string:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml = '&lt;a xmlns="test"&gt;&lt;b xmlns="test"/&gt;&lt;/a&gt;'

&gt;&gt;&gt; root = etree.fromstring(xml)
&gt;&gt;&gt; print etree.tostring(root)
&lt;a xmlns="test"&gt;&lt;b xmlns="test"/&gt;&lt;/a&gt;
</pre>
<p>To read from a file or file-like object, you can use the <tt class="docutils literal"><span class="pre">parse()</span></tt> function,
which returns an <tt class="docutils literal"><span class="pre">ElementTree</span></tt> object:</p>
<pre class="literal-block">
&gt;&gt;&gt; tree = etree.parse(StringIO(xml))
&gt;&gt;&gt; print etree.tostring(tree.getroot())
&lt;a xmlns="test"&gt;&lt;b xmlns="test"/&gt;&lt;/a&gt;
</pre>
<p>Note how the <tt class="docutils literal"><span class="pre">parse()</span></tt> function reads from a file-like object here.  If
parsing is done from a real file, it is more common (and also somewhat more
efficient) to pass a filename:</p>
<pre class="literal-block">
&gt;&gt;&gt; tree = etree.parse("doc/test.xml")
</pre>
<p>lxml can parse from a local file, an HTTP URL or an FTP URL.  It also
auto-detects and reads gzip-compressed XML files (.gz).</p>
<p>If you want to parse from memory and still provide a base URL for the document
(e.g. to support relative paths in an XInclude), you can pass the <tt class="docutils literal"><span class="pre">base_url</span></tt>
keyword argument:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = etree.fromstring(xml, base_url="http://where.it/is/from.xml")
</pre>
<div class="section">
<h2><a id="parser-options" name="parser-options">Parser options</a></h2>
<p>The parsers accept a number of setup options as keyword arguments.  The above
example is easily extended to clean up namespaces during parsing:</p>
<pre class="literal-block">
&gt;&gt;&gt; parser = etree.XMLParser(ns_clean=True)
&gt;&gt;&gt; tree   = etree.parse(StringIO(xml), parser)
&gt;&gt;&gt; print etree.tostring(tree.getroot())
&lt;a xmlns="test"&gt;&lt;b/&gt;&lt;/a&gt;
</pre>
<p>The keyword arguments in the constructor are mainly based on the libxml2
parser configuration.  A DTD will also be loaded if validation or attribute
default values are requested.</p>
<p>Available boolean keyword arguments:</p>
<ul class="simple">
<li>attribute_defaults - read the DTD (if referenced by the document) and add
the default attributes from it</li>
<li>dtd_validation - validate while parsing (if a DTD was referenced)</li>
<li>load_dtd - load and parse the DTD while parsing (no validation is performed)</li>
<li>no_network - prevent network access when looking up external documents</li>
<li>ns_clean - try to clean up redundant namespace declarations</li>
<li>recover - try hard to parse through broken XML</li>
<li>remove_blank_text - discard blank text nodes between tags</li>
<li>remove_comments - discard comments</li>
<li>compact - use compact storage for short text content (on by default)</li>
</ul>
</div>
<div class="section">
<h2><a id="parsing-html" name="parsing-html">Parsing HTML</a></h2>
<p>HTML parsing is similarly simple.  The parsers have a <tt class="docutils literal"><span class="pre">recover</span></tt> keyword
argument that the HTMLParser sets by default.  It lets libxml2 try its best to
return something usable without raising an exception.  You should use libxml2
version 2.6.21 or newer to take advantage of this feature:</p>
<pre class="literal-block">
&gt;&gt;&gt; broken_html = "&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;body&gt;&lt;h1&gt;page title&lt;/h3&gt;"

&gt;&gt;&gt; parser = etree.HTMLParser()
&gt;&gt;&gt; tree   = etree.parse(StringIO(broken_html), parser)

&gt;&gt;&gt; print etree.tostring(tree.getroot(), pretty_print=True)
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;page title&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Lxml has an HTML function, similar to the XML shortcut known from
ElementTree:</p>
<pre class="literal-block">
&gt;&gt;&gt; html = etree.HTML(broken_html)
&gt;&gt;&gt; print etree.tostring(html, pretty_print=True)
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;page title&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>The support for parsing broken HTML depends entirely on libxml2's recovery
algorithm.  It is <em>not</em> the fault of lxml if you find documents that are so
heavily broken that the parser cannot handle them.  There is also no guarantee
that the resulting tree will contain all data from the original document.  The
parser may have to drop seriously broken parts when struggling to keep
parsing.  Especially misplaced meta tags can suffer from this, which may lead
to encoding problems.</p>
</div>
<div class="section">
<h2><a id="doctype-information" name="doctype-information">Doctype information</a></h2>
<p>The use of the libxml2 parsers makes some additional information available at
the API level.  Currently, ElementTree objects can access the DOCTYPE
information provided by a parsed document, as well as the XML version and the
original encoding:</p>
<pre class="literal-block">
&gt;&gt;&gt; pub_id  = "-//W3C//DTD XHTML 1.0 Transitional//EN"
&gt;&gt;&gt; sys_url = "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
&gt;&gt;&gt; doctype_string = '&lt;!DOCTYPE html PUBLIC "%s" "%s"&gt;' % (pub_id, sys_url)
&gt;&gt;&gt; xml_header = '&lt;?xml version="1.0" encoding="ascii"?&gt;'
&gt;&gt;&gt; xhtml = xml_header + doctype_string + '&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'

&gt;&gt;&gt; tree = etree.parse(StringIO(xhtml))
&gt;&gt;&gt; docinfo = tree.docinfo
&gt;&gt;&gt; print docinfo.public_id
-//W3C//DTD XHTML 1.0 Transitional//EN
&gt;&gt;&gt; print docinfo.system_url
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd
&gt;&gt;&gt; docinfo.doctype == doctype_string
True

&gt;&gt;&gt; print docinfo.xml_version
1.0
&gt;&gt;&gt; print docinfo.encoding
ascii
</pre>
</div>
</div>
<div class="section">
<h1><a id="iterparse-and-iterwalk" name="iterparse-and-iterwalk">iterparse and iterwalk</a></h1>
<p>As known from ElementTree, the <tt class="docutils literal"><span class="pre">iterparse()</span></tt> utility function returns an
iterator that generates parser events for an XML file (or file-like object),
while building the tree.  The values are tuples <tt class="docutils literal"><span class="pre">(event-type,</span> <span class="pre">object)</span></tt>.  The
event types are 'start', 'end', 'start-ns' and 'end-ns'.</p>
<p>The 'start' and 'end' events represent opening and closing elements and are
accompanied by the respective element.  By default, only 'end' events are
generated:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml = '''\
... &lt;root&gt;
...   &lt;element key='value'&gt;text&lt;/element&gt;
...   &lt;element&gt;text&lt;/element&gt;tail
...   &lt;empty-element xmlns="testns" /&gt;
... &lt;/root&gt;
... '''

&gt;&gt;&gt; context = etree.iterparse(StringIO(xml))
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
end element
end element
end {testns}empty-element
end root
</pre>
<p>The resulting tree is available through the <tt class="docutils literal"><span class="pre">root</span></tt> property of the iterator:</p>
<pre class="literal-block">
&gt;&gt;&gt; context.root.tag
'root'
</pre>
<p>The other event types can be activated with the <tt class="docutils literal"><span class="pre">events</span></tt> keyword argument:</p>
<pre class="literal-block">
&gt;&gt;&gt; events = ("start", "end")
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), events=events)
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start root
start element
end element
start element
end element
start {testns}empty-element
end {testns}empty-element
end root
</pre>
<div class="section">
<h2><a id="selective-tag-events" name="selective-tag-events">Selective tag events</a></h2>
<p>As an extension over ElementTree, lxml.etree accepts a <tt class="docutils literal"><span class="pre">tag</span></tt> keyword
argument just like <tt class="docutils literal"><span class="pre">element.getiterator(tag)</span></tt>.  This restricts events to a
specific tag or namespace:</p>
<pre class="literal-block">
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), tag="element")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
end element
end element

&gt;&gt;&gt; events = ("start", "end")
&gt;&gt;&gt; context = etree.iterparse(
...             StringIO(xml), events=events, tag="{testns}*")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start {testns}empty-element
end {testns}empty-element
</pre>
</div>
<div class="section">
<h2><a id="modifying-the-tree" name="modifying-the-tree">Modifying the tree</a></h2>
<p>You can modify the element and its descendants when handling the 'end' event.
To save memory, for example, you can remove subtrees that are no longer
needed:</p>
<pre class="literal-block">
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml))
&gt;&gt;&gt; for action, elem in context:
...     print len(elem),
...     elem.clear()
0 0 0 3
&gt;&gt;&gt; context.root.getchildren()
[]
</pre>
<p><strong>WARNING</strong>: During the 'start' event, the descendants and following siblings
are not yet available and should not be accessed.  During the 'end' event, the
element and its descendants can be freely modified, but its following siblings
should not be accessed.  During either of the two events, you <strong>must not</strong>
modify or move the ancestors (parents) of the current element.  You should
also avoid moving or discarding the element itself.  The golden rule is: do
not touch anything that will have to be touched again by the parser later on.</p>
<p>If you have elements with a long list of children in your XML file and want to
save more memory during parsing, you can clean up the preceding siblings of
the current element:</p>
<pre class="literal-block">
&gt;&gt;&gt; for event, element in etree.iterparse(StringIO(xml)):
...     # ... do something with the element
...     element.clear()                 # clean up children
...     while element.getprevious() is not None:
...         del element.getparent()[0]  # clean up preceding siblings
</pre>
<p>The <tt class="docutils literal"><span class="pre">while</span></tt> loop deletes multiple siblings in a row.  This is only necessary
if you skipped over some of them using the <tt class="docutils literal"><span class="pre">tag</span></tt> keyword argument.
Otherwise, a simple <tt class="docutils literal"><span class="pre">if</span></tt> should do.  The more selective your tag is,
however, the more thought you will have to put into finding the right way to
clean up the elements that were skipped.  Therefore, it is sometimes easier to
traverse all elements and do the tag selection by hand in the event handler
code.</p>
<p>The 'start-ns' and 'end-ns' events notify about namespace declarations and
generate tuples <tt class="docutils literal"><span class="pre">(prefix,</span> <span class="pre">URI)</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; events = ("start-ns", "end-ns")
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), events=events)
&gt;&gt;&gt; for action, obj in context:
...     print action, obj
start-ns ('', 'testns')
end-ns None
</pre>
<p>It is common practice to use a list as namespace stack and pop the last entry
on the 'end-ns' event.</p>
</div>
<div class="section">
<h2><a id="iterwalk" name="iterwalk">iterwalk</a></h2>
<p>A second extension over ElementTree is the <tt class="docutils literal"><span class="pre">iterwalk()</span></tt> function.  It
behaves exactly like <tt class="docutils literal"><span class="pre">iterparse()</span></tt>, but works on Elements and ElementTrees:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = etree.XML(xml)
&gt;&gt;&gt; context = etree.iterwalk(
...             root, events=("start", "end"), tag="element")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start element
end element
start element
end element

&gt;&gt;&gt; f = StringIO(xml)
&gt;&gt;&gt; context = etree.iterparse(
...             f, events=("start", "end"), tag="element")

&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start element
end element
start element
end element
</pre>
</div>
</div>
<div class="section">
<h1><a id="python-unicode-strings" name="python-unicode-strings">Python unicode strings</a></h1>
<p>lxml.etree has broader support for Python unicode strings than the ElementTree
library.  First of all, where ElementTree would raise an exception, the
parsers in lxml.etree can handle unicode strings straight away.  This is most
helpful for XML snippets embedded in source code using the <tt class="docutils literal"><span class="pre">XML()</span></tt>
function:</p>
<pre class="literal-block">
&gt;&gt;&gt; uxml = u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'
&gt;&gt;&gt; uxml
u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'
&gt;&gt;&gt; root = etree.XML(uxml)
</pre>
<p>This requires, however, that unicode strings do not specify a conflicting
encoding themselves and thus lie about their real encoding:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.XML(u'&lt;?xml version="1.0" encoding="ASCII"?&gt;\n' + uxml)
Traceback (most recent call last):
  ...
ValueError: Unicode strings with encoding declaration are not supported.
</pre>
<p>Similarly, you will get errors when you try the same with HTML data in a
unicode string that specifies a charset in a meta tag of the header.  You
should generally avoid converting XML/HTML data to unicode before passing it
into the parsers.  It is both slower and error prone.</p>
<div class="section">
<h2><a id="serialising-to-unicode-strings" name="serialising-to-unicode-strings">Serialising to Unicode strings</a></h2>
<p>To serialize the result, you would normally use the <tt class="docutils literal"><span class="pre">tostring</span></tt> module
function, which serializes to plain ASCII by default or a number of other
encodings if asked for:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.tostring(root)
'&lt;test&gt; &amp;#63697; + &amp;#63698; &lt;/test&gt;'

&gt;&gt;&gt; etree.tostring(root, 'UTF-8', xml_declaration=False)
'&lt;test&gt; \xef\xa3\x91 + \xef\xa3\x92 &lt;/test&gt;'
</pre>
<p>As an extension, lxml.etree has a new <tt class="docutils literal"><span class="pre">tounicode()</span></tt> function that you can
call on XML tree objects to retrieve a Python unicode representation:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.tounicode(root)
u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'

&gt;&gt;&gt; el = etree.Element("test")
&gt;&gt;&gt; etree.tounicode(el)
u'&lt;test/&gt;'

&gt;&gt;&gt; subel = etree.SubElement(el, "subtest")
&gt;&gt;&gt; etree.tounicode(el)
u'&lt;test&gt;&lt;subtest/&gt;&lt;/test&gt;'

&gt;&gt;&gt; et = etree.ElementTree(el)
&gt;&gt;&gt; etree.tounicode(et)
u'&lt;test&gt;&lt;subtest/&gt;&lt;/test&gt;'
</pre>
<p>The result of <tt class="docutils literal"><span class="pre">tounicode()</span></tt> can be treated like any other Python unicode
string and then passed back into the parsers.  However, if you want to save
the result to a file or pass it over the network, you should use <tt class="docutils literal"><span class="pre">write()</span></tt>
or <tt class="docutils literal"><span class="pre">tostring()</span></tt> with an encoding argument (typically UTF-8) to serialize the
XML.  The main reason is that unicode strings returned by <tt class="docutils literal"><span class="pre">tounicode()</span></tt>
never have an XML declaration and therefore do not specify their encoding.
These strings are most likely not parsable by other XML libraries.</p>
<p>In contrast, the <tt class="docutils literal"><span class="pre">tostring()</span></tt> function automatically adds a declaration as
needed that reflects the encoding of the returned string.  This makes it
possible for other parsers to correctly parse the XML byte stream.  Note that
using <tt class="docutils literal"><span class="pre">tostring()</span></tt> with UTF-8 is also considerably faster in most cases.</p>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-07-26.

</div>
</body>
</html>