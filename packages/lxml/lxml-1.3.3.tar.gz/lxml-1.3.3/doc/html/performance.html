<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>Benchmarks and Speed</title>
<meta name="author" content="Stefan Behnel" />
<meta content="Performance evaluation of lxml and ElementTree" name="description" />
<meta content="lxml performance, lxml.etree, lxml.objectify, benchmarks, ElementTree" name="keywords" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="benchmarks-and-speed">
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu foreign" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu foreign" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu foreign" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions (FAQ)</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#installation">Installation</a></li><li class="menu item"><a href="FAQ.html#contributing">Contributing</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu current" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#general-notes">General notes</a></li><li class="menu item"><a href="performance.html#how-to-read-the-timings">How to read the timings</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#a-longer-example">A longer example</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu foreign" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#providing-newer-library-versions-on-mac-os-x">Providing newer library versions on Mac-OS X</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu foreign" id="tutorial"><li class="menu title"><a href="tutorial.html">The lxml.etree Tutorial</a><ul class="submenu"><li class="menu item"><a href="tutorial.html#the-element-class">The Element class</a></li><li class="menu item"><a href="tutorial.html#elements-are-lists">Elements are lists</a></li><li class="menu item"><a href="tutorial.html#elements-carry-attributes">Elements carry attributes</a></li><li class="menu item"><a href="tutorial.html#elements-contain-text">Elements contain text</a></li><li class="menu item"><a href="tutorial.html#tree-iteration">Tree iteration</a></li></ul></li></ul><ul class="menu foreign" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml.etree</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#error-logging">Error logging</a></li><li class="menu item"><a href="api.html#serialisation">Serialisation</a></li><li class="menu item"><a href="api.html#xinclude-and-elementinclude">XInclude and ElementInclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu foreign" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML and HTML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu foreign" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu foreign" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu foreign" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#the-lxml-objectify-api">The lxml.objectify API</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-lxml-etree?">What is different from lxml.etree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu foreign" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#resolvers">Resolvers</a></li><li class="menu item"><a href="resolvers.html#document-loading-in-context">Document loading in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu foreign" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu foreign" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu foreign" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu foreign" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div><h1 class="title">Benchmarks and Speed</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Stefan Behnel</td></tr>
</tbody>
</table>
<p>As an XML library, lxml.etree is very fast.  It is also slow.  As with all
software, it depends on what you do with it.  Rest assured that lxml is fast
enough for most applications, so lxml is probably somewhere between 'fast
enough' and 'the best choice' for yours.</p>
<p>This text describes where lxml.etree (abbreviated to 'lxe') excels, gives
hints on some performance traps and compares the overall performance to the
original <a class="reference" href="http://effbot.org/zone/element-index.htm">ElementTree</a> (ET) and <a class="reference" href="http://effbot.org/zone/celementtree.htm">cElementTree</a> (cET) libraries by Fredrik Lundh.
The cElementTree library is a fast C-implementation of the original
ElementTree.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#general-notes" id="id1" name="id1">General notes</a></li>
<li><a class="reference" href="#how-to-read-the-timings" id="id2" name="id2">How to read the timings</a></li>
<li><a class="reference" href="#parsing-and-serialising" id="id3" name="id3">Parsing and Serialising</a></li>
<li><a class="reference" href="#the-elementtree-api" id="id4" name="id4">The ElementTree API</a><ul>
<li><a class="reference" href="#child-access" id="id5" name="id5">Child access</a></li>
<li><a class="reference" href="#element-creation" id="id6" name="id6">Element creation</a></li>
<li><a class="reference" href="#merging-different-sources" id="id7" name="id7">Merging different sources</a></li>
<li><a class="reference" href="#deepcopy" id="id8" name="id8">deepcopy</a></li>
<li><a class="reference" href="#tree-traversal" id="id9" name="id9">Tree traversal</a></li>
</ul>
</li>
<li><a class="reference" href="#xpath" id="id10" name="id10">XPath</a></li>
<li><a class="reference" href="#a-longer-example" id="id11" name="id11">A longer example</a></li>
<li><a class="reference" href="#lxml-objectify" id="id12" name="id12">lxml.objectify</a><ul>
<li><a class="reference" href="#objectpath" id="id13" name="id13">ObjectPath</a></li>
<li><a class="reference" href="#caching-elements" id="id14" name="id14">Caching Elements</a></li>
<li><a class="reference" href="#further-optimisations" id="id15" name="id15">Further optimisations</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a id="general-notes" name="general-notes">General notes</a></h1>
<p>First thing to say: there <em>is</em> an overhead involved in having a DOM-like C
library mimic the ElementTree API.  As opposed to ElementTree, lxml has to
generate Python representations of tree nodes on the fly when asked for them,
and the internal tree structure of libxml2 results in a higher maintenance
overhead than the simpler top-down structure of ElementTree.  What this means
is: the more of your code runs in Python, the less you can benefit from the
speed of lxml and libxml2.  Note, however, that this is true for most
performance critical Python applications.  No one would implement fourier
transformations in pure Python when you can use NumPy.</p>
<p>The up side then is that lxml provides powerful tools like tree iterators,
XPath and XSLT, that can handle complex operations at the speed of C.  Their
pythonic API in lxml makes them so flexible that most applications can easily
benefit from them.</p>
</div>
<div class="section">
<h1><a id="how-to-read-the-timings" name="how-to-read-the-timings">How to read the timings</a></h1>
<p>The statements made here are backed by the (micro-)benchmark scripts
<a class="reference" href="http://codespeak.net/svn/lxml/branch/lxml-1.3/benchmark/bench_etree.py">bench_etree.py</a>, <a class="reference" href="http://codespeak.net/svn/lxml/branch/lxml-1.3/benchmark/bench_xpath.py">bench_xpath.py</a> and <a class="reference" href="http://codespeak.net/svn/lxml/branch/lxml-1.3/benchmark/bench_objectify.py">bench_objectify.py</a> that come with
the lxml source distribution.  They are distributed under the same BSD license
as lxml itself, and the lxml project would like to promote them as a general
benchmarking suite for all ElementTree implementations.  New benchmarks are
very easy to add as tiny test methods, so if you write a performance test for
a specific part of the API yourself, please consider sending it to the lxml
mailing list.</p>
<p>The timings cited below compare lxml 1.3 (with libxml2 2.6.27) to the
ElementTree and cElementTree versions shipped with CPython 2.5 (based on
ElementTree 1.2.6).  They were run single-threaded on a 1.8GHz Intel Core Duo
machine under Ubuntu Linux 7.04 (Feisty).</p>
<p>The scripts run a number of simple tests on the different libraries, using
different XML tree configurations: different tree sizes (T1-4), with or
without attributes (-/A), with or without ASCII string or unicode text
(-/S/U), and either against a tree or its serialised XML form (T/X).  In the
result extracts cited below, T1 refers to a 3-level tree with many children at
the third level, T2 is swapped around to have many children below the root
element, T3 is a deep tree with few children at each level and T4 is a small
tree, slightly broader than deep.  If repetition is involved, this usually
means running the benchmark in a loop over all children of the tree root,
otherwise, the operation is run on the root node (C/R).</p>
<p>As an example, the character code <tt class="docutils literal"><span class="pre">(SATR</span> <span class="pre">T1)</span></tt> states that the benchmark was
running for tree T1, with plain string text (S) and attributes (A).  It was
run against the root element (R) in the tree structure of the data (T).</p>
<p>Note that very small operations are repeated in integer loops to make them
measurable.  It is therefore not always possible to compare the absolute
timings of, say, a single access benchmark (which usually loops) and a 'get
all in one step' benchmark, which already takes enough time to be measurable
and is therefore measured as is.  An example is the index access to a single
child, which cannot be compared to the timings for <tt class="docutils literal"><span class="pre">getchildren()</span></tt>.  Take a
look at the concrete benchmarks in the scripts to understand how the numbers
compare.</p>
</div>
<div class="section">
<h1><a id="parsing-and-serialising" name="parsing-and-serialising">Parsing and Serialising</a></h1>
<p>These are areas where lxml excels.  The reason is that both parts are executed
entirely at the C level, without major interaction with Python code.  The
results are rather impressive.  Compared to cElementTree, lxml is about 20 to
40 times faster on serialisation:</p>
<pre class="literal-block">
lxe: tostring_utf16  (SATR T1)   21.9206 msec/pass
cET: tostring_utf16  (SATR T1)  461.9428 msec/pass
ET : tostring_utf16  (SATR T1)  486.8946 msec/pass

lxe: tostring_utf16  (UATR T1)   22.7508 msec/pass
cET: tostring_utf16  (UATR T1)  526.3446 msec/pass
ET : tostring_utf16  (UATR T1)  496.0767 msec/pass

lxe: tostring_utf16  (S-TR T2)   23.8452 msec/pass
cET: tostring_utf16  (S-TR T2)  537.9200 msec/pass
ET : tostring_utf16  (S-TR T2)  504.4273 msec/pass

lxe: tostring_utf8   (S-TR T2)   18.2550 msec/pass
cET: tostring_utf8   (S-TR T2)  528.3908 msec/pass
ET : tostring_utf8   (S-TR T2)  549.7071 msec/pass

lxe: tostring_utf8   (U-TR T3)    2.5497 msec/pass
cET: tostring_utf8   (U-TR T3)   49.8495 msec/pass
ET : tostring_utf8   (U-TR T3)   62.6927 msec/pass
</pre>
<p>For parsing, the difference between the libraries is smaller.  The (c)ET
libraries use the expat parser, which is known to be extremely fast:</p>
<pre class="literal-block">
lxe: parse_stringIO  (SAXR T1)  150.2380 msec/pass
cET: parse_stringIO  (SAXR T1)   25.9311 msec/pass
ET : parse_stringIO  (SAXR T1)  222.9431 msec/pass

lxe: parse_stringIO  (S-XR T3)    5.9490 msec/pass
cET: parse_stringIO  (S-XR T3)    5.4519 msec/pass
ET : parse_stringIO  (S-XR T3)   76.4120 msec/pass

lxe: parse_stringIO  (UAXR T3)   29.3601 msec/pass
cET: parse_stringIO  (UAXR T3)   28.9941 msec/pass
ET : parse_stringIO  (UAXR T3)  163.5361 msec/pass
</pre>
<p>The expat parser allows cET to be up to 80% faster than lxml on plain parser
performance.  Similar timings can be observed for the <tt class="docutils literal"><span class="pre">iterparse()</span></tt>
function.  However, if you take a complete input-output cycle, the numbers
will look similar to these:</p>
<pre class="literal-block">
lxe: write_utf8_parse_stringIO  (S-TR T1)  166.3210 msec/pass
cET: write_utf8_parse_stringIO  (S-TR T1)  581.2099 msec/pass
ET : write_utf8_parse_stringIO  (S-TR T1)  803.5331 msec/pass

lxe: write_utf8_parse_stringIO  (UATR T2)  184.4249 msec/pass
cET: write_utf8_parse_stringIO  (UATR T2)  671.5119 msec/pass
ET : write_utf8_parse_stringIO  (UATR T2)  924.3481 msec/pass

lxe: write_utf8_parse_stringIO  (S-TR T3)    9.1329 msec/pass
cET: write_utf8_parse_stringIO  (S-TR T3)   77.9850 msec/pass
ET : write_utf8_parse_stringIO  (S-TR T3)  157.0492 msec/pass

lxe: write_utf8_parse_stringIO  (SATR T4)    1.3900 msec/pass
cET: write_utf8_parse_stringIO  (SATR T4)   12.6081 msec/pass
ET : write_utf8_parse_stringIO  (SATR T4)   16.2580 msec/pass
</pre>
<p>For applications that require a high parser throughput and do little
serialization, cET is the best choice.  Also for iterparse applications that
extract small amounts of data from large XML data sets.  If it comes to
round-trip performance, however, lxml tends to be 3-4 times faster in
total. So, whenever the input documents are not considerably bigger than the
output, lxml is the clear winner.</p>
</div>
<div class="section">
<h1><a id="the-elementtree-api" name="the-elementtree-api">The ElementTree API</a></h1>
<p>Since all three libraries implement the same API, their performance is easy to
compare in this area.  A major disadvantage for lxml's performance is the
different tree model that underlies libxml2.  It allows lxml to provide parent
pointers for elements, but also increases the overhead of tree building and
restructuring.  This can be seen from the tree setup times of the benchmark
(given in seconds):</p>
<pre class="literal-block">
lxe:       --     S-     U-     -A     SA     UA
     T1: 0.1181 0.1080 0.1074 0.1088 0.1087 0.1099
     T2: 0.1103 0.1109 0.1164 0.1241 0.1203 0.1231
     T3: 0.0297 0.0309 0.0297 0.0716 0.0704 0.0703
     T4: 0.0005 0.0004 0.0004 0.0014 0.0014 0.0014
cET:       --     S-     U-     -A     SA     UA
     T1: 0.0290 0.0271 0.0275 0.0297 0.0273 0.0274
     T2: 0.0280 0.0280 0.0281 0.0285 0.0283 0.0286
     T3: 0.0071 0.0072 0.0071 0.0113 0.0096 0.0096
     T4: 0.0001 0.0001 0.0001 0.0001 0.0001 0.0001
ET :       --     S-     U-     -A     SA     UA
     T1: 0.1362 0.1985 0.2300 0.1344 0.2672 0.1335
     T2: 0.3107 0.1386 0.3581 0.3886 0.1388 0.4277
     T3: 0.0334 0.0332 0.0320 0.0367 0.3769 0.0375
     T4: 0.0006 0.0005 0.0008 0.0007 0.0007 0.0006
</pre>
<p>While lxml is still faster than ET in most cases (30-60%), cET can be up to
three times faster than lxml here.  One of the reasons is that lxml must
additionally discard the created Python elements after their use, when they
are no longer referenced.  ET and cET represent the tree itself through these
objects, which reduces the overhead in creating them.</p>
<div class="section">
<h2><a id="child-access" name="child-access">Child access</a></h2>
<p>The same reason makes operations like <tt class="docutils literal"><span class="pre">getchildren()</span></tt> more costly in lxml.
Where ET and cET can quickly create a shallow copy of their list of children,
lxml has to create a Python object for each child and collect them in a list:</p>
<pre class="literal-block">
lxe: root_getchildren          (--TR T2)    0.1960 msec/pass
cET: root_getchildren          (--TR T2)    0.0150 msec/pass
ET : root_getchildren          (--TR T2)    0.0091 msec/pass
</pre>
<p>When accessing single children, however, e.g. by index, this handicap is
negligible:</p>
<pre class="literal-block">
lxe: first_child               (--TR T2)    0.2289 msec/pass
cET: first_child               (--TR T2)    0.2048 msec/pass
ET : first_child               (--TR T2)    0.9291 msec/pass

lxe: last_child                (--TR T1)    0.2310 msec/pass
cET: last_child                (--TR T1)    0.2148 msec/pass
ET : last_child                (--TR T1)    0.9191 msec/pass
</pre>
<p>... unless you add the time to find a child index in a bigger list, as ET and
cET use Python lists here, which are based on arrays.  The data structure used
by libxml2 is a linked tree, and thus, a linked list of children:</p>
<pre class="literal-block">
lxe: middle_child              (--TR T1)    0.2759 msec/pass
cET: middle_child              (--TR T1)    0.2069 msec/pass
ET : middle_child              (--TR T1)    0.9291 msec/pass

lxe: middle_child              (--TR T2)    1.7111 msec/pass
cET: middle_child              (--TR T2)    0.2089 msec/pass
ET : middle_child              (--TR T2)    0.9360 msec/pass
</pre>
</div>
<div class="section">
<h2><a id="element-creation" name="element-creation">Element creation</a></h2>
<p>As opposed to ET, libxml2 has a notion of documents that each element must be
in.  This results in a major performance difference for creating independent
Elements that end up in independently created documents:</p>
<pre class="literal-block">
lxe: create_elements           (--TC T2)    3.7301 msec/pass
cET: create_elements           (--TC T2)    0.1960 msec/pass
ET : create_elements           (--TC T2)    1.4279 msec/pass
</pre>
<p>Therefore, it is always preferable to create Elements for the document they
are supposed to end up in, either as SubElements of an Element or using the
explicit <tt class="docutils literal"><span class="pre">Element.makeelement()</span></tt> call:</p>
<pre class="literal-block">
lxe: makeelement               (--TC T2)    2.3680 msec/pass
cET: makeelement               (--TC T2)    0.3128 msec/pass
ET : makeelement               (--TC T2)    1.6940 msec/pass

lxe: create_subelements        (--TC T2)    2.2051 msec/pass
cET: create_subelements        (--TC T2)    0.2370 msec/pass
ET : create_subelements        (--TC T2)    3.2189 msec/pass
</pre>
<p>So, if the main performance bottleneck of an application is creating large XML
trees in memory through calls to Element and SubElement, cET is the best
choice.  Note, however, that the serialisation performance may even out this
advantage, especially for smaller trees and trees with many attributes.</p>
</div>
<div class="section">
<h2><a id="merging-different-sources" name="merging-different-sources">Merging different sources</a></h2>
<p>A critical action for lxml is moving elements between document contexts.  It
requires lxml to do recursive adaptations throughout the moved tree structure.</p>
<p>The following benchmark appends all root children of the second tree to the
root of the first tree:</p>
<pre class="literal-block">
lxe: append_from_document      (--TR T1,T2)    4.3468 msec/pass
cET: append_from_document      (--TR T1,T2)    0.2608 msec/pass
ET : append_from_document      (--TR T1,T2)    1.2310 msec/pass

lxe: append_from_document      (--TR T3,T4)    0.0679 msec/pass
cET: append_from_document      (--TR T3,T4)    0.0148 msec/pass
ET : append_from_document      (--TR T3,T4)    0.0880 msec/pass
</pre>
<p>Although these are fairly small numbers compared to parsing, this easily shows
the different performance classes for lxml and (c)ET.  Where the latter do not
have to care about parent pointers and tree structures, lxml has to deep
traverse the appended tree.  The performance difference therefore increases
with the size of the tree that is moved.</p>
<p>This difference is not always as visible, but applies to most parts of the
API, like inserting newly created elements:</p>
<pre class="literal-block">
lxe: insert_from_document      (--TR T1,T2)    6.3150 msec/pass
cET: insert_from_document      (--TR T1,T2)    0.4039 msec/pass
ET : insert_from_document      (--TR T1,T2)    1.4770 msec/pass
</pre>
<p>Or replacing the child slice by a new element:</p>
<pre class="literal-block">
lxe: replace_children_element  (--TC T1)    0.2608 msec/pass
cET: replace_children_element  (--TC T1)    0.0238 msec/pass
ET : replace_children_element  (--TC T1)    0.1628 msec/pass
</pre>
<p>You should keep this difference in mind when you merge very large trees.</p>
</div>
<div class="section">
<h2><a id="deepcopy" name="deepcopy">deepcopy</a></h2>
<p>Deep copying a tree is fast in lxml:</p>
<pre class="literal-block">
lxe: deepcopy_all              (--TR T1)   11.0400 msec/pass
cET: deepcopy_all              (--TR T1)  119.6141 msec/pass
ET : deepcopy_all              (--TR T1)  451.2160 msec/pass

lxe: deepcopy_all              (-ATR T2)   13.5410 msec/pass
cET: deepcopy_all              (-ATR T2)  135.2482 msec/pass
ET : deepcopy_all              (-ATR T2)  476.1350 msec/pass

lxe: deepcopy_all              (S-TR T3)    4.2889 msec/pass
cET: deepcopy_all              (S-TR T3)   36.0429 msec/pass
ET : deepcopy_all              (S-TR T3)  113.4322 msec/pass
</pre>
<p>So, for example, if you have a database-like scenario where you parse in a
large tree and then search and copy independent subtrees from it for further
processing, lxml is by far the best choice here.</p>
</div>
<div class="section">
<h2><a id="tree-traversal" name="tree-traversal">Tree traversal</a></h2>
<p>Another area where lxml is very fast is iteration for tree traversal.  If your
algorithms can benefit from step-by-step traversal of the XML tree and
especially if few elements are of interest or the target element tag name is
known, lxml is a good choice:</p>
<pre class="literal-block">
lxe: getiterator_all      (--TR T2)    6.4790 msec/pass
cET: getiterator_all      (--TR T2)   28.2831 msec/pass
ET : getiterator_all      (--TR T2)   26.0720 msec/pass

lxe: getiterator_islice   (--TR T2)    0.0892 msec/pass
cET: getiterator_islice   (--TR T2)    0.2460 msec/pass
ET : getiterator_islice   (--TR T2)   26.6550 msec/pass

lxe: getiterator_tag      (--TR T2)    0.3850 msec/pass
cET: getiterator_tag      (--TR T2)    9.3720 msec/pass
ET : getiterator_tag      (--TR T2)   22.8221 msec/pass

lxe: getiterator_tag_all  (--TR T2)    0.7222 msec/pass
cET: getiterator_tag_all  (--TR T2)   27.2939 msec/pass
ET : getiterator_tag_all  (--TR T2)   22.8271 msec/pass
</pre>
<p>This translates directly into similar timings for <tt class="docutils literal"><span class="pre">Element.findall()</span></tt>:</p>
<pre class="literal-block">
lxe: findall              (--TR T2)    6.8321 msec/pass
cET: findall              (--TR T2)   28.8639 msec/pass
ET : findall              (--TR T2)   27.1060 msec/pass

lxe: findall              (--TR T3)    1.3590 msec/pass
cET: findall              (--TR T3)    8.9881 msec/pass
ET : findall              (--TR T3)    6.4890 msec/pass

lxe: findall_tag          (--TR T2)    0.9229 msec/pass
cET: findall_tag          (--TR T2)   27.2651 msec/pass
ET : findall_tag          (--TR T2)   22.7208 msec/pass

lxe: findall_tag          (--TR T3)    0.1700 msec/pass
cET: findall_tag          (--TR T3)    6.4540 msec/pass
ET : findall_tag          (--TR T3)    5.4770 msec/pass
</pre>
<p>Note that all three libraries currently use the same Python implementation for
<tt class="docutils literal"><span class="pre">findall()</span></tt>, except for their native tree iterator.</p>
</div>
</div>
<div class="section">
<h1><a id="xpath" name="xpath">XPath</a></h1>
<p>The following timings are based on the benchmark script <a class="reference" href="http://codespeak.net/svn/lxml/branch/lxml-1.3/benchmark/bench_xpath.py">bench_xpath.py</a>.</p>
<p>This part of lxml does not have an equivalent in ElementTree.  However, lxml
provides more than one way of accessing it and you should take care which part
of the lxml API you use.  The most straight forward way is to call the
<tt class="docutils literal"><span class="pre">xpath()</span></tt> method on an Element or ElementTree:</p>
<pre class="literal-block">
lxe: xpath_method         (--TC T1)    1.0180 msec/pass
lxe: xpath_method         (--TC T2)   20.3521 msec/pass
lxe: xpath_method         (--TC T3)    0.1259 msec/pass
lxe: xpath_method         (--TC T4)    1.0169 msec/pass
</pre>
<p>This is well suited for testing and when the XPath expressions are as diverse
as the trees they are called on.  However, if you have a single XPath
expression that you want to apply to a larger number of different elements,
the <tt class="docutils literal"><span class="pre">XPath</span></tt> class is the most efficient way to do it:</p>
<pre class="literal-block">
lxe: xpath_class          (--TC T1)    0.1891 msec/pass
lxe: xpath_class          (--TC T2)    3.0179 msec/pass
lxe: xpath_class          (--TC T3)    0.0570 msec/pass
lxe: xpath_class          (--TC T4)    0.1910 msec/pass
</pre>
<p>Note that this still allows you to use variables in the expression, so you can
parse it once and then adapt it through variables at call time.  In other
cases, where you have a fixed Element or ElementTree and want to run different
expressions on it, you should consider the <tt class="docutils literal"><span class="pre">XPathEvaluator</span></tt>:</p>
<pre class="literal-block">
lxe: xpath_element        (--TR T1)    0.4089 msec/pass
lxe: xpath_element        (--TR T2)    5.9960 msec/pass
lxe: xpath_element        (--TR T3)    0.1230 msec/pass
lxe: xpath_element        (--TR T4)    0.3440 msec/pass
</pre>
<p>While it looks slightly slower, creating an XPath object for each of the
expressions generates a much higher overhead here:</p>
<pre class="literal-block">
lxe: xpath_class_repeat   (--TC T1)    1.0259 msec/pass
lxe: xpath_class_repeat   (--TC T2)   20.4861 msec/pass
lxe: xpath_class_repeat   (--TC T3)    0.1280 msec/pass
lxe: xpath_class_repeat   (--TC T4)    1.0269 msec/pass
</pre>
</div>
<div class="section">
<h1><a id="a-longer-example" name="a-longer-example">A longer example</a></h1>
<p>A while ago, Uche Ogbuji posted a <a class="reference" href="http://www.onlamp.com/pub/wlg/6291">benchmark proposal</a> that would read in a
3MB XML version of the <a class="reference" href="http://www.ibiblio.org/bosak/xml/eg/religion.2.00.xml.zip">Old Testament</a> of the Bible and look for the word
<em>begat</em> in all verses.  Apparently, it is contained in 120 out of almost 24000
verses.  This is easy to implement in ElementTree using <tt class="docutils literal"><span class="pre">findall()</span></tt>.
However, the fastest way to do this is obviously <tt class="docutils literal"><span class="pre">iterparse()</span></tt>, as most of
the data is not of any interest.</p>
<p>Now, Uche's original proposal was more or less the following:</p>
<pre class="literal-block">
def bench_ET():
    tree = ElementTree.parse("ot.xml")
    result = []
    for v in tree.findall("//v"):
        text = v.text
        if 'begat' in text:
            result.append(text)
    return len(result)
</pre>
<p>which takes about one second on my machine today.  The faster <tt class="docutils literal"><span class="pre">iterparse()</span></tt>
variant looks like this:</p>
<pre class="literal-block">
def bench_ET_iterparse():
    result = []
    for event, v in ElementTree.iterparse("ot.xml"):
        if v.tag == 'v':
            text = v.text
            if 'begat' in text:
                result.append(text)
        v.clear()
    return len(result)
</pre>
<p>The improvement is about 10%.  At the time I first tried (early 2006), lxml
didn't have <tt class="docutils literal"><span class="pre">iterparse()</span></tt> support, but the <tt class="docutils literal"><span class="pre">findall()</span></tt> variant was already
faster than ElementTree.  This changes immediately when you switch to
cElementTree.  The latter only needs 0.17 seconds to do the trick today and
only some impressive 0.10 seconds when running the iterparse version.  And
even back then, it was quite a bit faster than what lxml could achieve.</p>
<p>Since then, lxml has matured a lot and has gotten much faster.  The iterparse
variant now runs in 0.14 seconds, and if you remove the <tt class="docutils literal"><span class="pre">v.clear()</span></tt>, it is
even a little faster (which isn't the case for cElementTree).</p>
<p>One of the many great tools in lxml is XPath, a swiss army knife for finding
things in XML documents.  It is possible to move the whole thing to a pure
XPath implementation, which looks like this:</p>
<pre class="literal-block">
def bench_lxml_xpath_all():
    tree = etree.parse("ot.xml")
    result = tree.xpath("//v[contains(., 'begat')]/text()")
    return len(result)
</pre>
<p>This runs in about 0.13 seconds and is about the shortest possible
implementation (in lines of Python code) that I could come up with.  Now, this
is already a rather complex XPath expression compared to the simple "//v"
ElementPath expression we started with.  Since this is also valid XPath, let's
try this instead:</p>
<pre class="literal-block">
def bench_lxml_xpath():
    tree = etree.parse("ot.xml")
    result = []
    for v in tree.xpath("//v"):
        text = v.text
        if 'begat' in text:
            result.append(text)
    return len(result)
</pre>
<p>This gets us down to 0.12 seconds, thus showing that a generic XPath
evaluation engine cannot always compete with a simpler, tailored solution.
However, since this is not much different from the original findall variant,
we can remove the complexity of the XPath call completely and just go with
what we had in the beginning.  Under lxml, this runs in the same 0.12 seconds.</p>
<p>But there is one thing left to try.  We can replace the simple ElementPath
expression with a native tree iterator:</p>
<pre class="literal-block">
def bench_lxml_getiterator():
    tree = etree.parse("ot.xml")
    result = []
    for v in tree.getiterator("v"):
        text = v.text
        if 'begat' in text:
            result.append(text)
    return len(result)
</pre>
<p>This implements the same thing, just without the overhead of parsing and
evaluating a path expression.  And this makes it another bit faster, down to
0.11 seconds.  For comparison, cElementTree runs this version in 0.17 seconds.</p>
<p>So, what have we learned?</p>
<ul class="simple">
<li>Python code is not slow.  The pure XPath solution was not even as fast as
the first shot Python implementation.  In general, a few more lines in
Python make things more readable, which is much more important than the last
5% of performance.</li>
<li>It's important to know the available options - and it's worth starting with
the most simple one.  In this case, a programmer would then probably have
started with <tt class="docutils literal"><span class="pre">getiterator("v")</span></tt> or <tt class="docutils literal"><span class="pre">iterparse()</span></tt>.  Either of them would
already have been the most efficient, depending on which library is used.</li>
<li>It's important to know your tool.  lxml and cElementTree are both very fast
libraries, but they do not have the same performance characteristics.  The
fastest solution in one library can be comparatively slow in the other.  If
you optimise, optimise for the specific target platform.</li>
<li>It's not always worth optimising.  After all that hassle we got from 0.12
seconds for the initial implementation to 0.11 seconds.  Switching over to
cElementTree and writing an <tt class="docutils literal"><span class="pre">iterparse()</span></tt> based version would have given
us 0.10 seconds - not a big difference for 3MB of XML.</li>
<li>Take care what operation is really dominating in your use case.  If we split
up the operations, we can see that lxml is slightly slower than cElementTree
on <tt class="docutils literal"><span class="pre">parse()</span></tt> (both about 0.06 seconds), but more visibly slower on
<tt class="docutils literal"><span class="pre">iterparse()</span></tt>: 0.07 versus 0.10 seconds.  However, tree iteration in lxml
is increadibly fast, so it can be better to parse the whole tree and then
iterate over it rather than using <tt class="docutils literal"><span class="pre">iterparse()</span></tt> to do both in one step.
Or, you can just wait for the lxml authors to optimise iterparse in one of
the next releases...</li>
</ul>
</div>
<div class="section">
<h1><a id="lxml-objectify" name="lxml-objectify">lxml.objectify</a></h1>
<p>The following timings are based on the benchmark script <a class="reference" href="http://codespeak.net/svn/lxml/branch/lxml-1.3/benchmark/bench_objectify.py">bench_objectify.py</a>.</p>
<p>Objectify is a data-binding API for XML based on lxml.etree, that was added in
version 1.1.  It uses standard Python attribute access to traverse the XML
tree.  It also features ObjectPath, a fast path language based on the same
meme.</p>
<p>Just like lxml.etree, lxml.objectify creates Python representations of
elements on the fly.  To save memory, the normal Python garbage collection
mechanisms will discard them when their last reference is gone.  In cases
where deeply nested elements are frequently accessed through the objectify
API, the create-discard cycles can become a bottleneck, as elements have to be
instantiated over and over again.</p>
<div class="section">
<h2><a id="objectpath" name="objectpath">ObjectPath</a></h2>
<p>ObjectPath can be used to speed up the access to elements that are deep in the
tree.  It avoids step-by-step Python element instantiations along the path,
which can substantially improve the access time:</p>
<pre class="literal-block">
lxe: attribute                  (--TR T1)   10.6189 msec/pass
lxe: attribute                  (--TR T2)   53.7431 msec/pass
lxe: attribute                  (--TR T4)   10.3359 msec/pass

lxe: objectpath                 (--TR T1)    5.8351 msec/pass
lxe: objectpath                 (--TR T2)   48.1579 msec/pass
lxe: objectpath                 (--TR T4)    5.6930 msec/pass

lxe: attributes_deep            (--TR T1)   58.7430 msec/pass
lxe: attributes_deep            (--TR T2)   63.0901 msec/pass
lxe: attributes_deep            (--TR T4)   17.4620 msec/pass

lxe: objectpath_deep            (--TR T1)   52.1719 msec/pass
lxe: objectpath_deep            (--TR T2)   52.9201 msec/pass
lxe: objectpath_deep            (--TR T4)    7.5650 msec/pass
</pre>
<p>Note, however, that parsing ObjectPath expressions is not for free either, so
this is most effective for frequently accessing the same element.</p>
</div>
<div class="section">
<h2><a id="caching-elements" name="caching-elements">Caching Elements</a></h2>
<p>A way to improve the normal attribute access time is static instantiation of
the Python objects, thus trading memory for speed.  Just create a cache
dictionary and run:</p>
<pre class="literal-block">
cache[root] = list(root.getiterator())
</pre>
<p>after parsing and:</p>
<pre class="literal-block">
del cache[root]
</pre>
<p>when you are done with the tree.  This will keep the Python element
representations of all elements alive and thus avoid the overhead of repeated
Python object creation.  You can also consider using filters or generator
expressions to be more selective.  By choosing the right trees (or even
subtrees and elements) to cache, you can trade memory usage against access
speed:</p>
<pre class="literal-block">
lxe: attribute_cached           (--TR T1)    7.9739 msec/pass
lxe: attribute_cached           (--TR T2)   50.9331 msec/pass
lxe: attribute_cached           (--TR T4)    7.8540 msec/pass

lxe: attributes_deep_cached     (--TR T1)   51.1391 msec/pass
lxe: attributes_deep_cached     (--TR T2)   55.7129 msec/pass
lxe: attributes_deep_cached     (--TR T4)   10.7968 msec/pass

lxe: objectpath_deep_cached     (--TR T1)   47.6151 msec/pass
lxe: objectpath_deep_cached     (--TR T2)   48.0802 msec/pass
lxe: objectpath_deep_cached     (--TR T4)    4.0281 msec/pass
</pre>
<p>Things to note: you cannot currently use <tt class="docutils literal"><span class="pre">weakref.WeakKeyDictionary</span></tt> objects
for this as lxml's element objects do not support weak references (which are
costly in terms of memory).  Also note that new element objects that you add
to these trees will not turn up in the cache automatically and will therefore
still be garbage collected when all their Python references are gone, so this
is most effective for largely immutable trees.  You should consider using a
set instead of a list in this case and add new elements by hand.</p>
</div>
<div class="section">
<h2><a id="further-optimisations" name="further-optimisations">Further optimisations</a></h2>
<p>Here are some more things to try if optimisation is required:</p>
<ul class="simple">
<li>A lot of time is usually spent in tree traversal to find the addressed
elements in the tree.  If you often work in subtrees, do what you would also
do with deep Python objects: assign the parent of the subtree to a variable
or pass it into functions instead of starting at the root.  This allows
accessing its descendents more directly.</li>
<li>Try assigning data values directly to attributes instead of passing them
through DataElement.</li>
<li>If you use custom data types that are costly to parse, try running
<tt class="docutils literal"><span class="pre">objectify.annotate()</span></tt> over read-only trees to speed up the attribute type
inference on read access.</li>
</ul>
<p>Note that none of these measures is guaranteed to speed up your application.
As usual, you should prefer readable code over premature optimisations and
profile your expected use cases before bothering to apply optimisations at
random.</p>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2007-07-26.

</div>
</body>
</html>