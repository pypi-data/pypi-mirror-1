<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>lxml.objectify</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="lxml-objectify">
<h1 class="title">lxml.objectify</h1>
<p>lxml supports an alternative API similar to the <a class="reference" href="http://uche.ogbuji.net/tech/4suite/amara/">Amara</a> bindery or
<a class="reference" href="http://gnosis.cx/download/">gnosis.xml.objectify</a> through a custom Element implementation.  The main idea
is to hide the usage of XML behind normal Python objects, sometimes referred
to as data-binding.  It allows you to use XML as if you were dealing with a
normal Python object hierarchy.</p>
<p>Accessing the children of an XML element deploys object attribute access.  If
there are multiple children with the same name, slicing and indexing can be
used.  Python data types are extracted from XML content automatically and made
available to the normal Python operators.</p>
<p>This API is very different from the ElementTree API.  If it is used, it should
not be mixed with other element implementations, to avoid non-obvious
behaviour.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#setting-up-lxml-objectify" id="id2" name="id2">Setting up lxml.objectify</a></li>
<li><a class="reference" href="#creating-objectify-trees" id="id3" name="id3">Creating objectify trees</a></li>
<li><a class="reference" href="#element-access-through-object-attributes" id="id4" name="id4">Element access through object attributes</a></li>
<li><a class="reference" href="#namespace-handling" id="id5" name="id5">Namespace handling</a></li>
<li><a class="reference" href="#objectpath" id="id6" name="id6">ObjectPath</a></li>
<li><a class="reference" href="#python-data-types" id="id7" name="id7">Python data types</a></li>
<li><a class="reference" href="#defining-additional-data-classes" id="id8" name="id8">Defining additional data classes</a></li>
<li><a class="reference" href="#recursive-string-representation-of-elements" id="id9" name="id9">Recursive string representation of elements</a></li>
<li><a class="reference" href="#what-is-different-from-elementtree" id="id10" name="id10">What is different from ElementTree?</a></li>
<li><a class="reference" href="#id1" id="id11" name="id11">Resetting the API</a></li>
</ul>
</div>
<!-- 1   Setting up lxml.objectify
2   Creating objectify trees
3   Element access through object attributes
4   Namespace handling
5   ObjectPath
6   Python data types
7   Defining additional data classes
8   Recursive string representation of elements
9   What is different from ElementTree?
10  Resetting the API -->
<div class="section">
<h1><a class="toc-backref" href="#id2" id="setting-up-lxml-objectify" name="setting-up-lxml-objectify">Setting up lxml.objectify</a></h1>
<p>To make use of <tt class="docutils literal"><span class="pre">objectify</span></tt>, you need both the <tt class="docutils literal"><span class="pre">lxml.etree</span></tt> module and
<tt class="docutils literal"><span class="pre">lxml.objectify</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; from lxml import objectify
</pre>
<p>The normal way to use <tt class="docutils literal"><span class="pre">objectify</span></tt> is to register it with a dedicated parser.
This requires setting up <tt class="docutils literal"><span class="pre">lxml.etree</span></tt> to use <a class="reference" href="element_classes.html#parser-based-lookup">parser specific element
classes</a> first:</p>
<pre class="literal-block">
&gt;&gt;&gt; lookup = etree.ParserBasedElementClassLookup()
&gt;&gt;&gt; etree.setElementClassLookup(lookup)
</pre>
<p>The next step is to create a parser that builds objectify documents.  The
objectify API is meant for data-centric XML (as opposed to document XML with
mixed content).  Therefore, we configure the parser to let it remove
whitespace-only text from the parsed document if it is not enclosed by an XML
element.  Note that this alters the document infoset, so if you consider the
removed spaces as data in your specific use case, you should go with a normal
parser and just set the element class lookup.  Most applications, however,
will work fine with the following setup:</p>
<pre class="literal-block">
&gt;&gt;&gt; parser = etree.XMLParser(remove_blank_text=True)

&gt;&gt;&gt; lookup = objectify.ObjectifyElementClassLookup()
&gt;&gt;&gt; parser.setElementClassLookup(lookup)
</pre>
<p>If you want additional support for <a class="reference" href="element_classes.html#namespace-class-lookup">namespace specific classes</a>, you can
register the objectify lookup as a fallback of the namespace lookup.  Note,
however, that you have to take care in this case, that the namespace classes
inherit from <tt class="docutils literal"><span class="pre">objectify.ObjectifiedElement</span></tt>, not only from the normal
<tt class="docutils literal"><span class="pre">lxml.etree.ElementBase</span></tt>, so that they support the <tt class="docutils literal"><span class="pre">objectify</span></tt> API.  The
above setup code then becomes:</p>
<pre class="literal-block">
&gt;&gt;&gt; lookup = etree.ElementNamespaceClassLookup(
...                   objectify.ObjectifyElementClassLookup() )
&gt;&gt;&gt; parser.setElementClassLookup(lookup)
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="creating-objectify-trees" name="creating-objectify-trees">Creating objectify trees</a></h1>
<p>To create an <tt class="docutils literal"><span class="pre">objectify</span></tt> tree, you can either parse a document with the
parser you created:</p>
<pre class="literal-block">
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; xml = StringIO('&lt;test/&gt;')
&gt;&gt;&gt; tree = etree.parse(xml, parser)
&gt;&gt;&gt; print isinstance(tree.getroot(), objectify.ObjectifiedElement)
True
</pre>
<p>or you can call the <tt class="docutils literal"><span class="pre">makeelement()</span></tt> method of the parser to create a new
root element from scratch:</p>
<pre class="literal-block">
&gt;&gt;&gt; obj_el = parser.makeelement(&quot;test&quot;)
&gt;&gt;&gt; print isinstance(obj_el, objectify.ObjectifiedElement)
True
</pre>
<p>New subelements will automatically inherit the setup.  However, all
independent elements that you create through the normal etree API will not be
associated with the parser and therefore not support the <tt class="docutils literal"><span class="pre">objectify</span></tt> API:</p>
<pre class="literal-block">
&gt;&gt;&gt; subel = etree.SubElement(obj_el, &quot;sub&quot;)
&gt;&gt;&gt; print isinstance(subel, objectify.ObjectifiedElement)
True

&gt;&gt;&gt; independent_el = etree.Element(&quot;new&quot;)
&gt;&gt;&gt; print isinstance(independent_el, objectify.ObjectifiedElement)
False
</pre>
<p>The <tt class="docutils literal"><span class="pre">makeelement()</span></tt> method of the parser has the same signature as the
normal <tt class="docutils literal"><span class="pre">Element()</span></tt> factory known from lxml.etree and can therefore easily
replace the respective calls.</p>
<p>For convenience, <tt class="docutils literal"><span class="pre">objectify</span></tt> also replicates the standard factory
<tt class="docutils literal"><span class="pre">Element()</span></tt> and the <tt class="docutils literal"><span class="pre">fromstring()</span></tt> function from <tt class="docutils literal"><span class="pre">lxml.etree</span></tt> using a
parser that is local to the <tt class="docutils literal"><span class="pre">objectify</span></tt> module.  So, after setting up the
parser based element lookup above, you can keep using the same API as in
<tt class="docutils literal"><span class="pre">lxml.etree</span></tt>, except that you have to import these functions from a
different module:</p>
<pre class="literal-block">
&gt;&gt;&gt; obj_el = objectify.Element(&quot;new&quot;)
&gt;&gt;&gt; print isinstance(obj_el, objectify.ObjectifiedElement)
True

&gt;&gt;&gt; obj_el = objectify.fromstring(&quot;&lt;test/&gt;&quot;)
&gt;&gt;&gt; print isinstance(obj_el, objectify.ObjectifiedElement)
True
</pre>
<p>You can change this parser with <tt class="docutils literal"><span class="pre">objectify.setDefaultParser(parser)</span></tt>, which
also allows to add the above support for namespace specific element classes.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="element-access-through-object-attributes" name="element-access-through-object-attributes">Element access through object attributes</a></h1>
<p>The main idea behind the <tt class="docutils literal"><span class="pre">objectify</span></tt> API is to hide XML element access
behind the usual object attribute access pattern.  Asking an element for an
attribute will return the sequence of children with corresponding tag names:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.Element(&quot;root&quot;)
&gt;&gt;&gt; b = etree.SubElement(root, &quot;b&quot;)
&gt;&gt;&gt; print root.b[0].tag
b
&gt;&gt;&gt; root.index(root.b[0])
0
&gt;&gt;&gt; b = etree.SubElement(root, &quot;b&quot;)
&gt;&gt;&gt; print root.b[0].tag
b
&gt;&gt;&gt; print root.b[1].tag
b
&gt;&gt;&gt; root.index(root.b[1])
1
</pre>
<p>For convenience, you can omit the index '0' to access the first child:</p>
<pre class="literal-block">
&gt;&gt;&gt; print root.b.tag
b
&gt;&gt;&gt; root.index(root.b)
0
&gt;&gt;&gt; del root.b
</pre>
<p>Iteration and slicing also obey the requested tag:</p>
<pre class="literal-block">
&gt;&gt;&gt; x1 = etree.SubElement(root, &quot;x&quot;)
&gt;&gt;&gt; x2 = etree.SubElement(root, &quot;x&quot;)
&gt;&gt;&gt; x3 = etree.SubElement(root, &quot;x&quot;)

&gt;&gt;&gt; [ el.tag for el in root.x ]
['x', 'x', 'x']

&gt;&gt;&gt; [ el.tag for el in root.x[1:3] ]
['x', 'x']

&gt;&gt;&gt; [ el.tag for el in root.x[-1:] ]
['x']

&gt;&gt;&gt; del root.x[1:2]
&gt;&gt;&gt; [ el.tag for el in root.x ]
['x', 'x']
</pre>
<p>If you want to iterate over all children or need to provide a specific
namespace for the tag, use the <tt class="docutils literal"><span class="pre">iterchildren()</span></tt> method.  Like the other
methods for iteration, it supports an optional tag keyword argument:</p>
<pre class="literal-block">
&gt;&gt;&gt; [ el.tag for el in root.iterchildren() ]
['b', 'x', 'x']

&gt;&gt;&gt; [ el.tag for el in root.iterchildren(tag='b') ]
['b']

&gt;&gt;&gt; [ el.tag for el in root.b ]
['b']
</pre>
<p>XML attributes are accessed as in the normal ElementTree API:</p>
<pre class="literal-block">
&gt;&gt;&gt; c = etree.SubElement(root, &quot;c&quot;, myattr=&quot;someval&quot;)
&gt;&gt;&gt; print root.c.get(&quot;myattr&quot;)
someval

&gt;&gt;&gt; root.c.set(&quot;c&quot;, &quot;oh-oh&quot;)
&gt;&gt;&gt; print root.c.get(&quot;c&quot;)
oh-oh
</pre>
<p>In addition to the normal ElementTree API for appending elements to trees,
subtrees can also be added by assigning them to object attributes.  In this
case, the subtree is automatically deep copied and the tag name of its root is
updated to match the attribute name:</p>
<pre class="literal-block">
&gt;&gt;&gt; el = objectify.Element(&quot;yet_another_child&quot;)
&gt;&gt;&gt; root.new_child = el
&gt;&gt;&gt; print root.new_child.tag
new_child
&gt;&gt;&gt; print el.tag
yet_another_child

&gt;&gt;&gt; root.y = [ objectify.Element(&quot;y&quot;), objectify.Element(&quot;y&quot;) ]
&gt;&gt;&gt; [ el.tag for el in root.y ]
['y', 'y']
</pre>
<p>The latter is a short form for operations on the full slice:</p>
<pre class="literal-block">
&gt;&gt;&gt; root.y[:] = [ objectify.Element(&quot;y&quot;) ]
&gt;&gt;&gt; [ el.tag for el in root.y ]
['y']
</pre>
<p>You can also replace children that way:</p>
<pre class="literal-block">
&gt;&gt;&gt; child1 = etree.SubElement(root, &quot;child&quot;)
&gt;&gt;&gt; child2 = etree.SubElement(root, &quot;child&quot;)
&gt;&gt;&gt; child3 = etree.SubElement(root, &quot;child&quot;)

&gt;&gt;&gt; el = objectify.Element(&quot;new_child&quot;)
&gt;&gt;&gt; subel = etree.SubElement(el, &quot;sub&quot;)

&gt;&gt;&gt; root.child = el
&gt;&gt;&gt; print root.child.sub.tag
sub

&gt;&gt;&gt; root.child[2] = el
&gt;&gt;&gt; print root.child[2].sub.tag
sub
</pre>
<p>Note that special care must be taken when changing the tag name of an element:</p>
<pre class="literal-block">
&gt;&gt;&gt; print root.b.tag
b
&gt;&gt;&gt; root.b.tag = &quot;notB&quot;
&gt;&gt;&gt; root.b
Traceback (most recent call last):
  ...
AttributeError: no such child: b
&gt;&gt;&gt; print root.notB.tag
notB
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="namespace-handling" name="namespace-handling">Namespace handling</a></h1>
<p>Namespaces are handled mostly behind the scenes.  If you access a child of an
Element without specifying a namespace, the lookup will use the namespace of
the parent:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.Element(&quot;{ns}root&quot;)
&gt;&gt;&gt; b = etree.SubElement(root, &quot;{ns}b&quot;)
&gt;&gt;&gt; c = etree.SubElement(root, &quot;{other}c&quot;)

&gt;&gt;&gt; print root.b.tag
{ns}b
&gt;&gt;&gt; print root.c
Traceback (most recent call last):
    ...
AttributeError: no such child: {ns}c
</pre>
<p>You can access elements with different namespaces via <tt class="docutils literal"><span class="pre">getattr()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; print getattr(root, &quot;{other}c&quot;).tag
{other}c
</pre>
<p>For convenience, there is also a quick way through item access:</p>
<pre class="literal-block">
&gt;&gt;&gt; print root[&quot;{other}c&quot;].tag
{other}c
</pre>
<p>The same approach must be used to access children with tag names that are not
valid Python identifiers:</p>
<pre class="literal-block">
&gt;&gt;&gt; el = etree.SubElement(root, &quot;{ns}tag-name&quot;)
&gt;&gt;&gt; print root[&quot;tag-name&quot;].tag
{ns}tag-name

&gt;&gt;&gt; new_el = objectify.Element(&quot;{ns}new-element&quot;)
&gt;&gt;&gt; el = etree.SubElement(new_el, &quot;{ns}child&quot;)
&gt;&gt;&gt; el = etree.SubElement(new_el, &quot;{ns}child&quot;)
&gt;&gt;&gt; el = etree.SubElement(new_el, &quot;{ns}child&quot;)

&gt;&gt;&gt; root[&quot;tag-name&quot;] = [ new_el, new_el ]
&gt;&gt;&gt; print len(root[&quot;tag-name&quot;])
2
&gt;&gt;&gt; print root[&quot;tag-name&quot;].tag
{ns}tag-name

&gt;&gt;&gt; print len(root[&quot;tag-name&quot;].child)
3
&gt;&gt;&gt; print root[&quot;tag-name&quot;].child.tag
{ns}child
&gt;&gt;&gt; print root[&quot;tag-name&quot;][1].child.tag
{ns}child
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="objectpath" name="objectpath">ObjectPath</a></h1>
<p>For both convenience and speed, objectify supports its own path language,
represented by the <tt class="docutils literal"><span class="pre">ObjectPath</span></tt> class:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.Element(&quot;{ns}root&quot;)
&gt;&gt;&gt; b1 = etree.SubElement(root, &quot;{ns}b&quot;)
&gt;&gt;&gt; c  = etree.SubElement(b1,   &quot;{ns}c&quot;)
&gt;&gt;&gt; b2 = etree.SubElement(root, &quot;{ns}b&quot;)
&gt;&gt;&gt; d  = etree.SubElement(root, &quot;{other}d&quot;)

&gt;&gt;&gt; path = objectify.ObjectPath(&quot;root.b.c&quot;)
&gt;&gt;&gt; print path
root.b.c
&gt;&gt;&gt; path.hasattr(root)
True
&gt;&gt;&gt; print path.find(root).tag
{ns}c

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;root.b.c&quot;)
&gt;&gt;&gt; print find(root).tag
{ns}c

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;root.{other}d&quot;)
&gt;&gt;&gt; print find(root).tag
{other}d

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;root.{not}there&quot;)
&gt;&gt;&gt; print find(root).tag
Traceback (most recent call last):
  ...
AttributeError: no such child: {not}there

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;{not}there&quot;)
&gt;&gt;&gt; print find(root).tag
Traceback (most recent call last):
  ...
ValueError: root element does not match: need {not}there, got {ns}root

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;root.b[1]&quot;)
&gt;&gt;&gt; print find(root).tag
{ns}b

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;root.{ns}b[1]&quot;)
&gt;&gt;&gt; print find(root).tag
{ns}b
</pre>
<p>Apart from strings, ObjectPath also accepts lists of path segments:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; find = objectify.ObjectPath(['root', 'b', 'c'])
&gt;&gt;&gt; print find(root).tag
{ns}c
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; find = objectify.ObjectPath(['root', '{ns}b[1]'])
&gt;&gt;&gt; print find(root).tag
{ns}b
</pre>
</blockquote>
<p>You can also use relative paths starting with a '.' that ignore the actual
root element and only inherit its namespace:</p>
<pre class="literal-block">
&gt;&gt;&gt; find = objectify.ObjectPath(&quot;.b[1]&quot;)
&gt;&gt;&gt; print find(root).tag
{ns}b

&gt;&gt;&gt; find = objectify.ObjectPath(['', 'b[1]'])
&gt;&gt;&gt; print find(root).tag
{ns}b

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;.unknown[1]&quot;)
&gt;&gt;&gt; print find(root).tag
Traceback (most recent call last):
  ...
AttributeError: no such child: {ns}unknown

&gt;&gt;&gt; find = objectify.ObjectPath(&quot;.{other}unknown[1]&quot;)
&gt;&gt;&gt; print find(root).tag
Traceback (most recent call last):
  ...
AttributeError: no such child: {other}unknown
</pre>
<p>ObjectPath objects can be used to manipulate trees:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.Element(&quot;{ns}root&quot;)

&gt;&gt;&gt; path = objectify.ObjectPath(&quot;.some.child.{other}unknown&quot;)
&gt;&gt;&gt; path.hasattr(root)
False
&gt;&gt;&gt; path.find(root)
Traceback (most recent call last):
  ...
AttributeError: no such child: {ns}some

&gt;&gt;&gt; path.setattr(root, &quot;my value&quot;) # creates children as necessary
&gt;&gt;&gt; path.hasattr(root)
True
&gt;&gt;&gt; print path.find(root).text
my value
&gt;&gt;&gt; print root.some.child[&quot;{other}unknown&quot;].text
my value

&gt;&gt;&gt; print len( path.find(root) )
1
&gt;&gt;&gt; path.addattr(root, &quot;my new value&quot;)
&gt;&gt;&gt; print len( path.find(root) )
2
&gt;&gt;&gt; [ el.text for el in path.find(root) ]
['my value', 'my new value']
</pre>
<p>As with attribute assignment, <tt class="docutils literal"><span class="pre">setattr()</span></tt> accepts lists:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; path.setattr(root, [&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;])
&gt;&gt;&gt; [ el.text for el in path.find(root) ]
['v1', 'v2', 'v3']
</pre>
</blockquote>
<p>Note, however, that indexing is only supported in this context if the children
exist.  Indexing of non existing children will not extend or create a list of
such children but raise an exception:</p>
<pre class="literal-block">
&gt;&gt;&gt; path = objectify.ObjectPath(&quot;.{non}existing[1]&quot;)
&gt;&gt;&gt; path.setattr(root, &quot;my value&quot;)
Traceback (most recent call last):
  ...
TypeError: creating indexed path attributes is not supported
</pre>
<p>It is worth noting that ObjectPath does not depend on the <tt class="docutils literal"><span class="pre">objectify</span></tt> module
or the ObjectifiedElement implementation.  It can also be used in combination
with Elements from the normal lxml.etree API.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="python-data-types" name="python-data-types">Python data types</a></h1>
<p>The objectify module knows about Python data types and tries its best to let
element content behave like them.  For example, they support the normal math
operators:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(
...             &quot;&lt;root&gt;&lt;a&gt;5&lt;/a&gt;&lt;b&gt;11&lt;/b&gt;&lt;c&gt;true&lt;/c&gt;&lt;d&gt;hoi&lt;/d&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; root.a + root.b
16
&gt;&gt;&gt; root.a += root.b
&gt;&gt;&gt; print root.a
16

&gt;&gt;&gt; root.a = 2
&gt;&gt;&gt; print root.a + 2
4
&gt;&gt;&gt; print 1 + root.a
3

&gt;&gt;&gt; print root.c
True
&gt;&gt;&gt; root.c = False
&gt;&gt;&gt; if not root.c:
...     print &quot;false!&quot;
false!

&gt;&gt;&gt; print root.d + &quot; test !&quot;
hoi test !
&gt;&gt;&gt; root.d = &quot;%s - %s&quot;
&gt;&gt;&gt; print root.d % (1234, 12345)
1234 - 12345
</pre>
<p>To see the data types that are currently used, you can call the module level
<tt class="docutils literal"><span class="pre">dump()</span></tt> function that returns a recursive string representation for
elements:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(&quot;&quot;&quot;
... &lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
...   &lt;a attr1=&quot;foo&quot; attr2=&quot;bar&quot;&gt;1&lt;/a&gt;
...   &lt;a&gt;1.2&lt;/a&gt;
...   &lt;b&gt;1&lt;/b&gt;
...   &lt;b&gt;true&lt;/b&gt;
...   &lt;c&gt;what?&lt;/c&gt;
...   &lt;d xsi:nil=&quot;true&quot;/&gt;
... &lt;/root&gt;
... &quot;&quot;&quot;)

&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 1 [IntElement]
      * attr1 = 'foo'
      * attr2 = 'bar'
    a = 1.2 [FloatElement]
    b = 1 [IntElement]
    b = True [BoolElement]
    c = 'what?' [StringElement]
    d = None [NoneElement]
      * xsi:nil = 'true'
</pre>
<p>You can freely switch between different types for the same child:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(&quot;&lt;root&gt;&lt;a&gt;5&lt;/a&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 5 [IntElement]

&gt;&gt;&gt; root.a = 'nice string!'
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 'nice string!' [StringElement]

&gt;&gt;&gt; root.a = True
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = True [BoolElement]

&gt;&gt;&gt; root.a = [1, 2, 3]
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 1 [IntElement]
    a = 2 [IntElement]
    a = 3 [IntElement]

&gt;&gt;&gt; root.a = (1, 2, 3)
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 1 [IntElement]
    a = 2 [IntElement]
    a = 3 [IntElement]
</pre>
<p>However, data elements continue to provide the objectify API.  This means that
sequence operations such as <tt class="docutils literal"><span class="pre">len()</span></tt>, slicing and indexing (e.g. of strings)
cannot behave as the Python types.  Like all other tree elements, they show
the normal slicing behaviour of objectify elements:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(&quot;&lt;root&gt;&lt;a&gt;test&lt;/a&gt;&lt;b&gt;toast&lt;/b&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; print root.a + ' me' # behaves like a string, right?
test me
&gt;&gt;&gt; len(root.a) # but there's only one 'a' element!
1
&gt;&gt;&gt; [ a.tag for a in root.a ]
['a']
&gt;&gt;&gt; print root.a[0].tag
a

&gt;&gt;&gt; print root.a
test
&gt;&gt;&gt; [ str(a) for a in root.a[:1] ]
['test']
</pre>
<p>If you need to run sequence operations on data types, you must ask the API for
the <em>real</em> Python value.  The string value is always available throught the
normal ElementTree <tt class="docutils literal"><span class="pre">.text</span></tt> attribute.  Additionally, all data classes
provide a <tt class="docutils literal"><span class="pre">.pyval</span></tt> attribute that returns the value as plain Python type:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(&quot;&lt;root&gt;&lt;a&gt;test&lt;/a&gt;&lt;b&gt;5&lt;/b&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; root.a.text
'test'
&gt;&gt;&gt; root.a.pyval
'test'

&gt;&gt;&gt; root.b.text
'5'
&gt;&gt;&gt; root.b.pyval
5
</pre>
<p>Note, however, that both attributes are read-only in objectify.  If you want
to change values, just assign them directly to the attribute:</p>
<pre class="literal-block">
&gt;&gt;&gt; root.a.text  = &quot;25&quot;
Traceback (most recent call last):
  ...
TypeError: attribute 'text' of 'StringElement' objects is not writable

&gt;&gt;&gt; root.a.pyval = 25
Traceback (most recent call last):
  ...
TypeError: attribute 'pyval' of 'StringElement' objects is not writable

&gt;&gt;&gt; root.a = 25
&gt;&gt;&gt; print root.a
25
</pre>
<p>Objectify determines data types by trial and error, unless it finds an
attribute named <tt class="docutils literal"><span class="pre">lxml.objectify.PYTYPE_ATTRIBUTE</span></tt>, which must contain any of
the following string values: int, long, float, str, unicode, none:</p>
<pre class="literal-block">
&gt;&gt;&gt; print objectify.PYTYPE_ATTRIBUTE
{http://codespeak.net/lxml/objectify/pytype}pytype
&gt;&gt;&gt; ns, name = objectify.PYTYPE_ATTRIBUTE[1:].split('}')

&gt;&gt;&gt; root = objectify.fromstring(&quot;&quot;&quot;\
... &lt;root xmlns:py='%s'&gt;
...   &lt;a py:pytype='str'&gt;5&lt;/a&gt;
...   &lt;b py:pytype='int'&gt;5&lt;/b&gt;
...   &lt;c py:pytype='none' /&gt;
... &lt;/root&gt;
... &quot;&quot;&quot; % ns)

&gt;&gt;&gt; print root.a + 10
510
&gt;&gt;&gt; print root.b + 10
15
&gt;&gt;&gt; print root.c
None
</pre>
<p>Note that you can change the name and namespace used for this attribute
through the <tt class="docutils literal"><span class="pre">setPytypeAttributeTag(tag)</span></tt> module function, in case your
application ever needs to.  There is also a utility function <tt class="docutils literal"><span class="pre">annotate()</span></tt>
that recursively generates this attribute for the elements of a tree:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring(&quot;&lt;root&gt;&lt;a&gt;test&lt;/a&gt;&lt;b&gt;5&lt;/b&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 'test' [StringElement]
    b = 5 [IntElement]

&gt;&gt;&gt; objectify.annotate(root)

&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    a = 'test' [StringElement]
      * py:pytype = 'str'
    b = 5 [IntElement]
      * py:pytype = 'int'
</pre>
<p>A second way of specifying data type information uses XML Schema types as
element annotations.  Objectify knows those that can be mapped to normal
Python types:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring('''\
...    &lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
...      &lt;d xsi:type=&quot;double&quot;&gt;5&lt;/d&gt;
...      &lt;l xsi:type=&quot;long&quot;  &gt;5&lt;/l&gt;
...      &lt;s xsi:type=&quot;string&quot;&gt;5&lt;/s&gt;
...    &lt;/root&gt;
...    ''')
&gt;&gt;&gt; print objectify.dump(root)
root = None [ObjectifiedElement]
    d = 5.0 [FloatElement]
      * xsi:type = 'double'
    l = 5L [LongElement]
      * xsi:type = 'long'
    s = '5' [StringElement]
      * xsi:type = 'string'
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id8" id="defining-additional-data-classes" name="defining-additional-data-classes">Defining additional data classes</a></h1>
<p>Data classes can either inherit from <tt class="docutils literal"><span class="pre">ObjectifiedDataElement</span></tt> directly or
from one of the specialised classes like <tt class="docutils literal"><span class="pre">NumberElement</span></tt> or <tt class="docutils literal"><span class="pre">BoolElement</span></tt>.
The numeric types require an initial call to the NumberElement method
<tt class="docutils literal"><span class="pre">self._setValueParser(function)</span></tt> to set their type conversion funtion
(string -&gt; numeric Python type).  This call should be placed into the element
<tt class="docutils literal"><span class="pre">_init()</span></tt> method.</p>
<p>The registration of data classes uses the <tt class="docutils literal"><span class="pre">PyType</span></tt> class:</p>
<pre class="literal-block">
&gt;&gt;&gt; class ChristmasDate(objectify.ObjectifiedDataElement):
...     def callSanta(self):
...         print &quot;Ho ho ho!&quot;

&gt;&gt;&gt; def checkChristmasDate(date_string):
...     if not date_string.startswith('24.12.'):
...         raise ValueError # or TypeError

&gt;&gt;&gt; xmas_type = objectify.PyType('date', checkChristmasDate, ChristmasDate)
</pre>
<p>If you want, you can also register this type under an XML Schema type name:</p>
<pre class="literal-block">
&gt;&gt;&gt; xmas_type.xmlSchemaTypes = (&quot;date&quot;,)
</pre>
<p>XML Schema types will be considered if the element has an <tt class="docutils literal"><span class="pre">xsi:type</span></tt>
attribute that specifies its data type.  The line above binds the XSD type
<tt class="docutils literal"><span class="pre">date</span></tt> to the newly defined Python type.  Note that this must be done before
the next step, which is to register the type.  Then you can use it:</p>
<pre class="literal-block">
&gt;&gt;&gt; xmas_type.register()

&gt;&gt;&gt; root = objectify.fromstring(
...             &quot;&lt;root&gt;&lt;a&gt;24.12.2000&lt;/a&gt;&lt;b&gt;12.24.2000&lt;/b&gt;&lt;/root&gt;&quot;)
&gt;&gt;&gt; root.a.callSanta()
Ho ho ho!
&gt;&gt;&gt; root.b.callSanta()
Traceback (most recent call last):
  ...
AttributeError: no such child: callSanta
</pre>
<p>If you need to specify dependencies between the type check functions, you can
pass a sequence of type names through the <tt class="docutils literal"><span class="pre">before</span></tt> and <tt class="docutils literal"><span class="pre">after</span></tt> keyword
arguments of the <tt class="docutils literal"><span class="pre">register()</span></tt> method.  The PyType will then try to register
itself before or after the respective types, as long as they are currently
registered.  Note that this only impacts the currently registered types at the
time of registration.  Types that are registered later on will not care about
the dependencies of already registered types.</p>
<p>If you provide XML Schema type information, this will override the type check
function defined above:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = objectify.fromstring('''\
...    &lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
...      &lt;a xsi:type=&quot;date&quot;&gt;12.24.2000&lt;/a&gt;
...    &lt;/root&gt;
...    ''')
&gt;&gt;&gt; print root.a
12.24.2000
&gt;&gt;&gt; root.a.callSanta()
Ho ho ho!
</pre>
<p>To unregister a type, call its <tt class="docutils literal"><span class="pre">unregister()</span></tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; root.a.callSanta()
Ho ho ho!
&gt;&gt;&gt; xmas_type.unregister()
&gt;&gt;&gt; root.a.callSanta()
Traceback (most recent call last):
  ...
AttributeError: no such child: callSanta
</pre>
<p>Please read the section on <a class="reference" href="#resetting-the-api">Resetting the API</a> below to learn about possible
problems.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="recursive-string-representation-of-elements" name="recursive-string-representation-of-elements">Recursive string representation of elements</a></h1>
<p>Normally, elements use the standard string representation for str() that is
provided by lxml.etree.  You can enable a pretty-print representation for
objectify elements like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; objectify.enableRecursiveStr()

&gt;&gt;&gt; root = objectify.fromstring(&quot;&quot;&quot;
... &lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
...   &lt;a attr1=&quot;foo&quot; attr2=&quot;bar&quot;&gt;1&lt;/a&gt;
...   &lt;a&gt;1.2&lt;/a&gt;
...   &lt;b&gt;1&lt;/b&gt;
...   &lt;b&gt;true&lt;/b&gt;
...   &lt;c&gt;what?&lt;/c&gt;
...   &lt;d xsi:nil=&quot;true&quot;/&gt;
... &lt;/root&gt;
... &quot;&quot;&quot;)

&gt;&gt;&gt; print str(root)
root = None [ObjectifiedElement]
    a = 1 [IntElement]
      * attr1 = 'foo'
      * attr2 = 'bar'
    a = 1.2 [FloatElement]
    b = 1 [IntElement]
    b = True [BoolElement]
    c = 'what?' [StringElement]
    d = None [NoneElement]
      * xsi:nil = 'true'
</pre>
<p>This behaviour can be switched off in the same way:</p>
<pre class="literal-block">
&gt;&gt;&gt; objectify.enableRecursiveStr(False)
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id10" id="what-is-different-from-elementtree" name="what-is-different-from-elementtree">What is different from ElementTree?</a></h1>
<p>Such a different Element API obviously implies some side effects to the normal
behaviour of the rest of the API.</p>
<ul class="simple">
<li>Iteration over elements does not yield the children, but the siblings.  You
can access all children with the <tt class="docutils literal"><span class="pre">iterchildren()</span></tt> method on elements or
retrieve a list by calling the <tt class="docutils literal"><span class="pre">getchildren()</span></tt> method.</li>
<li>The find, findall and findtext methods use a different implementation as
they rely on the original iteration scheme.  This has the disadvantage that
they may not be 100% backwards compatible, and the additional advantage that
they now support any XPath expression.</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="id1" name="id1">Resetting the API</a></h1>
<p>As the objectify setup is local to a parser, it does not interfere with the
rest of lxml.  However, if you stop using the parser you registered
<tt class="docutils literal"><span class="pre">objectify</span></tt> for, and you can make sure no other module is still using the
parser delegation, you can set the global class lookup mechanism back to the
default one, to disable the per-parser lookup.  This is easily achieved by
calling the setup function without arguments:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.setElementClassLookup()
</pre>
<p>Be aware, though, that this does not immediately apply to elements to which
there already is a Python reference.  Their Python class will only be changed
after all references are gone and the Python object is garbage collected.  The
same applies to registered data classes for elements.</p>
</div>
</div>
</body>
</html>
