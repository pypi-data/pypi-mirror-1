<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Extension functions for XPath and XSLT</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="extension-functions-for-xpath-and-xslt">
<h1 class="title">Extension functions for XPath and XSLT</h1>
<p>This document describes how to use Python extension functions in XPath and
XSLT.  They allow you to do things like this:</p>
<pre class="literal-block">
&lt;xsl:value-of select=&quot;f:myPythonFunction(.//sometag)&quot; /&gt;
</pre>
<p>Here is how such a function looks like.  As the first argument, it always
receives a dummy object.  It is currently None, but do not rely on this as it
may become meaningful in later versions of lxml.  The other arguments are
provided by the respective call in the XPath expression, one in the following
examples.  Any number of arguments is allowed:</p>
<pre class="literal-block">
&gt;&gt;&gt; def hello(dummy, a):
...    return &quot;Hello %s&quot; % a
&gt;&gt;&gt; def ola(dummy, a):
...    return &quot;Ola %s&quot; % a
&gt;&gt;&gt; def loadsofargs(dummy, *args):
...    return &quot;Got %d arguments.&quot; % len(args)
</pre>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#the-functionnamespace" id="id1" name="id1">The FunctionNamespace</a></li>
<li><a class="reference" href="#global-prefix-assignment" id="id2" name="id2">Global prefix assignment</a></li>
<li><a class="reference" href="#evaluators-and-xslt" id="id3" name="id3">Evaluators and XSLT</a></li>
<li><a class="reference" href="#evaluator-local-extensions" id="id4" name="id4">Evaluator-local extensions</a></li>
<li><a class="reference" href="#what-to-return-from-a-function" id="id5" name="id5">What to return from a function</a></li>
</ul>
</div>
<!-- 1  The FunctionNamespace
2  Global prefix assignment
3  Evaluators and XSLT
4  Evaluator-local extensions
5  What to return from a function -->
<div class="section">
<h1><a class="toc-backref" href="#id1" id="the-functionnamespace" name="the-functionnamespace">The FunctionNamespace</a></h1>
<p>In order to use a function in XPath/XSLT, it needs to have a (namespaced) name
by which it can be called during evaluation.  This is done using the
FunctionNamespace class.  For simplicity, we choose the empty namespace
(None):</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; ns = etree.FunctionNamespace(None)
&gt;&gt;&gt; ns['hello'] = hello
&gt;&gt;&gt; ns['countargs'] = loadsofargs
</pre>
<p>This registers the function <cite>hello</cite> with the name <cite>hello</cite> in the default
namespace (None), and the function <cite>loadsofargs</cite> with the name <cite>countargs</cite>.
Now we're going to create a document that we can run XPath expressions
against:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; f = StringIO('&lt;a&gt;&lt;b&gt;Haegar&lt;/b&gt;&lt;/a&gt;')
&gt;&gt;&gt; doc = etree.parse(f)
&gt;&gt;&gt; root = doc.getroot()
</pre>
<p>Done. Now we can have XPath expressions call our new function:</p>
<pre class="literal-block">
&gt;&gt;&gt; print root.xpath(&quot;hello('world')&quot;)
Hello world
&gt;&gt;&gt; print root.xpath('hello(local-name(*))')
Hello b
&gt;&gt;&gt; print root.xpath('hello(string(b))')
Hello Haegar
&gt;&gt;&gt; print root.xpath('countargs(., b, ./*)')
Got 3 arguments.
</pre>
<p>Note how we call both a Python function (<cite>hello</cite>) and an XPath built-in
function (<cite>string</cite>) in exactly the same way.  Normally, however, you would
want to separate the two in different namespaces.  The FunctionNamespace class
allows you to do this:</p>
<pre class="literal-block">
&gt;&gt;&gt; ns = etree.FunctionNamespace('http://mydomain.org/myfunctions')
&gt;&gt;&gt; ns['hello'] = hello
&gt;&gt;&gt; prefixmap = {'f' : 'http://mydomain.org/myfunctions'}
&gt;&gt;&gt; print root.xpath('f:hello(local-name(*))', prefixmap)
Hello b
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="global-prefix-assignment" name="global-prefix-assignment">Global prefix assignment</a></h1>
<p>In the last example, you had to specify a prefix for the function namespace.
If you always use the same prefix for a function namespace, you can also
register it with the namespace:</p>
<pre class="literal-block">
&gt;&gt;&gt; ns = etree.FunctionNamespace('http://mydomain.org/myother/functions')
&gt;&gt;&gt; ns.prefix = 'es'
&gt;&gt;&gt; ns['hello'] = ola
&gt;&gt;&gt; print root.xpath('es:hello(local-name(*))')
Ola b
</pre>
<p>This is a global assignment, so take care not to assign the same prefix to
more than one namespace.  The resulting behaviour in that case is completely
undefined.  It is always a good idea to consistently use the same meaningful
prefix for each namespace throughout your application.</p>
<p>The prefix assignment only works with functions and FunctionNamespace objects,
not with the general Namespace object that registers element classes.  The
reasoning is that elements in lxml do not care about prefixes anyway, so it
would rather complicate things than be of any help.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="evaluators-and-xslt" name="evaluators-and-xslt">Evaluators and XSLT</a></h1>
<p>Extension functions work for all ways of evaluating XPath expressions and for
XSL transformations:</p>
<pre class="literal-block">
&gt;&gt;&gt; e = etree.XPathEvaluator(doc)
&gt;&gt;&gt; print e.evaluate('es:hello(local-name(/a))')
Ola a

&gt;&gt;&gt; namespaces = {'f' : 'http://mydomain.org/myfunctions'}
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, namespaces=namespaces)
&gt;&gt;&gt; print e.evaluate('f:hello(local-name(/a))')
Hello a

&gt;&gt;&gt; xslt = etree.XSLT(etree.ElementTree(etree.XML('''
...   &lt;stylesheet version=&quot;1.0&quot;
...          xmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot;
...          xmlns:es=&quot;http://mydomain.org/myother/functions&quot;&gt;
...     &lt;output method=&quot;text&quot; encoding=&quot;ASCII&quot;/&gt;
...     &lt;template match=&quot;/&quot;&gt;
...       &lt;value-of select=&quot;es:hello(string(//b))&quot;/&gt;
...     &lt;/template&gt;
...   &lt;/stylesheet&gt;
... ''')))
&gt;&gt;&gt; print xslt(doc)
Ola Haegar
</pre>
<p>It is also possible to register namespaces with a single evaluator.  While the
following example involves no functions, the idea should still be clear:</p>
<pre class="literal-block">
&gt;&gt;&gt; f = StringIO('&lt;a xmlns=&quot;http://mydomain.org/myfunctions&quot; /&gt;')
&gt;&gt;&gt; ns_doc = etree.parse(f)
&gt;&gt;&gt; e = etree.XPathEvaluator(ns_doc)
&gt;&gt;&gt; e.evaluate('/a')
[]
</pre>
<p>This returns nothing, as we did not ask for the right namespace.  When we
register the namespace with the evaluator, we can access it via a prefix:</p>
<pre class="literal-block">
&gt;&gt;&gt; e.registerNamespace('foo', 'http://mydomain.org/myfunctions')
&gt;&gt;&gt; e.evaluate('/foo:a')[0].tag
'{http://mydomain.org/myfunctions}a'
</pre>
<p>Note that this prefix mapping is only known to this evaluator, as opposed to
the global mapping of the FunctionNamespace objects:</p>
<pre class="literal-block">
&gt;&gt;&gt; e2 = etree.XPathEvaluator(ns_doc)
&gt;&gt;&gt; e2.evaluate('/foo:a')
Traceback (most recent call last):
...
XPathSyntaxError: error in xpath expression
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="evaluator-local-extensions" name="evaluator-local-extensions">Evaluator-local extensions</a></h1>
<p>Apart from the global registration of extension functions, there is also a way
of making extensions known to a single Evaluator or XSLT.  All evaluators and
the XSLT object accept a keyword argument <tt class="docutils literal"><span class="pre">extensions</span></tt> in their constructor.
The value is a dictionary mapping (namespace, name) tuples to functions:</p>
<pre class="literal-block">
&gt;&gt;&gt; extensions = {('local-ns', 'local-hello') : hello}
&gt;&gt;&gt; namespaces = {'l' : 'local-ns'}

&gt;&gt;&gt; e = etree.XPathEvaluator(doc, namespaces=namespaces, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('l:local-hello(string(b))')
Hello Haegar
</pre>
<p>For larger numbers of extension functions, you can define classes or modules
and use the <tt class="docutils literal"><span class="pre">Extension</span></tt> helper:</p>
<pre class="literal-block">
&gt;&gt;&gt; class MyExt:
...     def function1(self, _, arg):
...         return '1'+arg
...     def function2(self, _, arg):
...         return '2'+arg
...     def function3(self, _, arg):
...         return '3'+arg

&gt;&gt;&gt; ext_module = MyExt()
&gt;&gt;&gt; functions = ('function1', 'function2')
&gt;&gt;&gt; extensions = etree.Extension( ext_module, functions, 'local-ns' )

&gt;&gt;&gt; e = etree.XPathEvaluator(doc, namespaces=namespaces, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('l:function1(string(b))')
1Haegar
</pre>
<p>The second argument to <tt class="docutils literal"><span class="pre">Extension</span></tt> can either be be a sequence of names to
select from the module, a dictionary that explicitly maps function names to
their XPath alter-ego or <tt class="docutils literal"><span class="pre">None</span></tt> (explicitly passed) to take all available
functions under their original name (if their name does not start with '_').</p>
<p>The third argument takes a namespace URI or <tt class="docutils literal"><span class="pre">None</span></tt> (also if left out) for
the default namespace.  The following examples will therefore all do the same
thing:</p>
<pre class="literal-block">
&gt;&gt;&gt; functions = ('function1', 'function2', 'function3')
&gt;&gt;&gt; extensions = etree.Extension( ext_module, functions )
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('function1(function2(function3(string(b))))')
123Haegar

&gt;&gt;&gt; extensions = etree.Extension( ext_module, functions, None )
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('function1(function2(function3(string(b))))')
123Haegar

&gt;&gt;&gt; extensions = etree.Extension( ext_module, None )
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('function1(function2(function3(string(b))))')
123Haegar

&gt;&gt;&gt; functions = {
...     'function1' : 'function1',
...     'function2' : 'function2',
...     'function3' : 'function3'
...     }
&gt;&gt;&gt; extensions = etree.Extension( ext_module, functions )
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, extensions=extensions)
&gt;&gt;&gt; print e.evaluate('function1(function2(function3(string(b))))')
123Haegar
</pre>
<p>For convenience, you can also pass a sequence of extensions:</p>
<pre class="literal-block">
&gt;&gt;&gt; extensions1 = etree.Extension( ext_module, None )
&gt;&gt;&gt; extensions2 = etree.Extension( ext_module, None, 'local-ns' )
&gt;&gt;&gt; e = etree.XPathEvaluator(doc, extensions=[extensions1, extensions2],
...                          namespaces=namespaces)
&gt;&gt;&gt; print e.evaluate('function1(l:function2(function3(string(b))))')
123Haegar
</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id5" id="what-to-return-from-a-function" name="what-to-return-from-a-function">What to return from a function</a></h1>
<p>Extension functions can return any data type for which there is an XPath
equivalent.  This includes numbers, boolean values, elements and lists of
elements.  Note that integers will also be returned as floats:</p>
<pre class="literal-block">
&gt;&gt;&gt; def returnsFloat(_):
...    return 1.7
&gt;&gt;&gt; def returnsInteger(_):
...    return 1
&gt;&gt;&gt; def returnsBool(_):
...    return True
&gt;&gt;&gt; def returnFirstNode(_, nodes):
...    return nodes[0]

&gt;&gt;&gt; ns = etree.FunctionNamespace(None)
&gt;&gt;&gt; ns['float'] = returnsFloat
&gt;&gt;&gt; ns['int']   = returnsInteger
&gt;&gt;&gt; ns['bool']  = returnsBool
&gt;&gt;&gt; ns['first'] = returnFirstNode

&gt;&gt;&gt; e = etree.XPathEvaluator(doc)
&gt;&gt;&gt; e.evaluate(&quot;float()&quot;)
1.7
&gt;&gt;&gt; e.evaluate(&quot;int()&quot;)
1.0
&gt;&gt;&gt; int( e.evaluate(&quot;int()&quot;) )
1
&gt;&gt;&gt; e.evaluate(&quot;bool()&quot;)
True
&gt;&gt;&gt; e.evaluate(&quot;count(first(//b))&quot;)
1.0
</pre>
<p>As the last example shows, you can pass the results of functions back into
the XPath expression.  Elements and sequences of elements are treated as
XPath node-sets:</p>
<pre class="literal-block">
&gt;&gt;&gt; def returnsNodeSet(_):
...     results1 = etree.Element('results1')
...     etree.SubElement(results1, 'result').text = &quot;Alpha&quot;
...     etree.SubElement(results1, 'result').text = &quot;Beta&quot;
...
...     results2 = etree.Element('results2')
...     etree.SubElement(results2, 'result').text = &quot;Gamma&quot;
...     etree.SubElement(results2, 'result').text = &quot;Delta&quot;
...
...     results3 = etree.SubElement(results2, 'subresult')
...     return [results1, results2, results3]

&gt;&gt;&gt; ns['new-node-set'] = returnsNodeSet

&gt;&gt;&gt; e = etree.XPathEvaluator(doc, None)

&gt;&gt;&gt; r = e.evaluate(&quot;new-node-set()/result&quot;)
&gt;&gt;&gt; print [ t.text for t in r ]
['Alpha', 'Beta', 'Gamma', 'Delta']

&gt;&gt;&gt; r = e.evaluate(&quot;new-node-set()&quot;)
&gt;&gt;&gt; print [ t.tag for t in r ]
['results1', 'results2', 'subresult']
&gt;&gt;&gt; print [ len(t) for t in r ]
[2, 3, 0]
&gt;&gt;&gt; r[0][0].text
'Alpha'

&gt;&gt;&gt; print etree.tostring(r[0])
&lt;results1&gt;&lt;result&gt;Alpha&lt;/result&gt;&lt;result&gt;Beta&lt;/result&gt;&lt;/results1&gt;

&gt;&gt;&gt; print etree.tostring(r[1])
&lt;results2&gt;&lt;result&gt;Gamma&lt;/result&gt;&lt;result&gt;Delta&lt;/result&gt;&lt;subresult/&gt;&lt;/results2&gt;

&gt;&gt;&gt; print etree.tostring(r[2])
&lt;subresult/&gt;
</pre>
<p>The current implementation deep-copies newly created elements in node-sets.
Only the elements and their children are passed on, no outlying parents or
tail texts will be available in the result.  This also means that in the above
example, the <cite>subresult</cite> elements in <cite>results2</cite> and <cite>results3</cite> are no longer
identical within the node-set, they belong to independent trees:</p>
<pre class="literal-block">
&gt;&gt;&gt; print r[1][-1].tag, r[2].tag
subresult subresult
&gt;&gt;&gt; print r[1][-1] == r[2]
False
&gt;&gt;&gt; print r[1][-1].getparent().tag
results2
&gt;&gt;&gt; print r[2].getparent()
None
</pre>
<p>This is an implementation detail that you should be aware of, but you should
avoid relying on it in your code.  Note that elements taken from the source
document (the most common case) do not suffer from this restriction.  They
will always be passed unchanged.</p>
</div>
</div>
</body>
</html>
