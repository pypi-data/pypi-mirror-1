<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Parsing XML with lxml</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="parsing-xml-with-lxml">
<h1 class="title">Parsing XML with lxml</h1>
<p>lxml provides a very simple and powerful API for parsing XML.  It supports
one-step parsing as well as step-by-step parsing using an event-driven API.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#parsers" id="id1" name="id1">Parsers</a></li>
<li><a class="reference" href="#iterparse-and-iterwalk" id="id2" name="id2">iterparse and iterwalk</a></li>
<li><a class="reference" href="#python-unicode-strings" id="id3" name="id3">Python unicode strings</a></li>
</ul>
</div>
<p>The usual setup procedure:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; from StringIO import StringIO
</pre>
<div class="section">
<h1><a id="parsers" name="parsers">Parsers</a></h1>
<p>Parsers are represented by parser objects.  There is support for parsing both
XML and (broken) HTML (note that XHTML is best parsed as XML).  Both are based
on libxml2 and therefore only support options that are backed by the library.
Parsers take a number of keyword arguments.  The following is an example for
namespace cleanup during parsing, first with the default parser, then with a
parametrized one:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml = '&lt;a xmlns="test"&gt;&lt;b xmlns="test"/&gt;&lt;/a&gt;'

&gt;&gt;&gt; et     = etree.parse(StringIO(xml))
&gt;&gt;&gt; print etree.tostring(et.getroot())
&lt;a xmlns="test"&gt;&lt;b xmlns="test"/&gt;&lt;/a&gt;

&gt;&gt;&gt; parser = etree.XMLParser(ns_clean=True)
&gt;&gt;&gt; et     = etree.parse(StringIO(xml), parser)
&gt;&gt;&gt; print etree.tostring(et.getroot())
&lt;a xmlns="test"&gt;&lt;b/&gt;&lt;/a&gt;
</pre>
<p>HTML parsing is similarly simple.  The parsers have a <tt class="docutils literal"><span class="pre">recover</span></tt> keyword
argument that the HTMLParser sets by default.  It lets libxml2 try its best to
return something usable without raising an exception.  You should use libxml2
version 2.6.21 or newer to take advantage of this feature:</p>
<pre class="literal-block">
&gt;&gt;&gt; broken_html = "&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;body&gt;&lt;h1&gt;page title&lt;/h3&gt;"

&gt;&gt;&gt; parser = etree.HTMLParser()
&gt;&gt;&gt; et     = etree.parse(StringIO(broken_html), parser)

&gt;&gt;&gt; print etree.tostring(et.getroot())
&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;page title&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</pre>
<p>Lxml has an HTML function, similar to the XML shortcut known from
ElementTree:</p>
<pre class="literal-block">
&gt;&gt;&gt; html = etree.HTML(broken_html)
&gt;&gt;&gt; print etree.tostring(html)
&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;page title&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</pre>
<p>The support for parsing broken HTML depends entirely on libxml2's recovery
algorithm.  It is <em>not</em> the fault of lxml if you find documents that are so
heavily broken that the parser cannot handle them.  There is also no guarantee
that the resulting tree will contain all data from the original document.  The
parser may have to drop seriously broken parts when struggling to keep
parsing.  Especially misplaced meta tags can suffer from this, which may lead
to encoding problems.</p>
<p>The use of the libxml2 parsers makes some additional information available at
the API level.  Currently, ElementTree objects can access the DOCTYPE
information provided by a parsed document, as well as the XML version and the
original encoding:</p>
<pre class="literal-block">
&gt;&gt;&gt; pub_id  = "-//W3C//DTD XHTML 1.0 Transitional//EN"
&gt;&gt;&gt; sys_url = "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
&gt;&gt;&gt; doctype_string = '&lt;!DOCTYPE html PUBLIC "%s" "%s"&gt;' % (pub_id, sys_url)
&gt;&gt;&gt; xml_header = '&lt;?xml version="1.0" encoding="ascii"?&gt;'
&gt;&gt;&gt; xhtml = xml_header + doctype_string + '&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'

&gt;&gt;&gt; tree = etree.parse(StringIO(xhtml))
&gt;&gt;&gt; docinfo = tree.docinfo
&gt;&gt;&gt; print docinfo.public_id
-//W3C//DTD XHTML 1.0 Transitional//EN
&gt;&gt;&gt; print docinfo.system_url
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd
&gt;&gt;&gt; docinfo.doctype == doctype_string
True

&gt;&gt;&gt; print docinfo.xml_version
1.0
&gt;&gt;&gt; print docinfo.encoding
ascii
</pre>
</div>
<div class="section">
<h1><a id="iterparse-and-iterwalk" name="iterparse-and-iterwalk">iterparse and iterwalk</a></h1>
<p>As known from ElementTree, the <tt class="docutils literal"><span class="pre">iterparse()</span></tt> utility function returns an
iterator that generates parser events for an XML file (or file-like object),
while building the tree.  The values are tuples <tt class="docutils literal"><span class="pre">(event-type,</span> <span class="pre">object)</span></tt>.  The
event types are 'start', 'end', 'start-ns' and 'end-ns'.</p>
<p>The 'start' and 'end' events represent opening and closing elements and are
accompanied by the respective element.  By default, only 'end' events are
generated:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml = '''\
... &lt;root&gt;
...   &lt;element key='value'&gt;text&lt;/element&gt;
...   &lt;element&gt;text&lt;/element&gt;tail
...   &lt;empty-element xmlns="testns" /&gt;
... &lt;/root&gt;
... '''

&gt;&gt;&gt; context = etree.iterparse(StringIO(xml))
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
end element
end element
end {testns}empty-element
end root
</pre>
<p>The resulting tree is available through the <tt class="docutils literal"><span class="pre">root</span></tt> property of the iterator:</p>
<pre class="literal-block">
&gt;&gt;&gt; context.root.tag
'root'
</pre>
<p>The other types can be activated with the <tt class="docutils literal"><span class="pre">events</span></tt> keyword argument:</p>
<pre class="literal-block">
&gt;&gt;&gt; events = ("start", "end")
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), events=events)
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start root
start element
end element
start element
end element
start {testns}empty-element
end {testns}empty-element
end root
</pre>
<p>You can modify the element and its descendants when handling the 'end' event.
To save memory, for example, you can remove subtrees that are no longer
needed:</p>
<pre class="literal-block">
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml))
&gt;&gt;&gt; for action, elem in context:
...     print len(elem),
...     elem.clear()
0 0 0 3
&gt;&gt;&gt; context.root.getchildren()
[]
</pre>
<p><strong>WARNING</strong>: During the 'start' event, the descendants and following siblings
are not yet available and should not be accessed.  During the 'end' event, the
element and its descendants can be freely modified, but its following siblings
should not be accessed.  During either of the two events, you <strong>must not</strong>
modify or move the ancestors (parents) of the current element.  You should
also avoid moving or discarding the element itself.  The golden rule is: do
not touch anything that will have to be touched again by the parser later on.</p>
<p>If you have elements with a long list of children in your XML file and want to
save more memory during parsing, you can clean up the preceding siblings of
the current element:</p>
<pre class="literal-block">
&gt;&gt;&gt; for event, element in etree.iterparse(StringIO(xml)):
...     # ... do something with the element
...     element.clear()                # clean up children
...     if element.getprevious():      # clean up preceding siblings
...         del element.getparent()[0]
</pre>
<p>You can use <tt class="docutils literal"><span class="pre">while</span></tt> instead of <tt class="docutils literal"><span class="pre">if</span></tt> if you skipped siblings using the
<tt class="docutils literal"><span class="pre">tag</span></tt> keyword argument.  The more selective your tag is, however, the more
thought you will have to put into finding the right way to clean up the
elements that were skipped.  Therefore, it is sometimes easier to traverse all
elements and do the tag selection by hand in the event handler code.</p>
<p>The 'start-ns' and 'end-ns' events notify about namespace declarations and
generate tuples <tt class="docutils literal"><span class="pre">(prefix,</span> <span class="pre">URI)</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; events = ("start-ns", "end-ns")
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), events=events)
&gt;&gt;&gt; for action, obj in context:
...     print action, obj
start-ns ('', 'testns')
end-ns None
</pre>
<p>It is common practice to use a list as namespace stack and pop the last entry
on the 'end-ns' event.</p>
<p>lxml.etree supports two extensions compared to ElementTree.  It accepts a
<tt class="docutils literal"><span class="pre">tag</span></tt> keyword argument just like <tt class="docutils literal"><span class="pre">element.getiterator(tag)</span></tt>.  This
restricts events to a specific tag or namespace.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), tag="element")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
end element
end element
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; events = ("start", "end")
&gt;&gt;&gt; context = etree.iterparse(StringIO(xml), events=events, tag="{testns}*")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start {testns}empty-element
end {testns}empty-element
</pre>
</blockquote>
<p>The second extension is the <tt class="docutils literal"><span class="pre">iterwalk()</span></tt> function.  It behaves exactly like
<tt class="docutils literal"><span class="pre">iterparse()</span></tt>, but works on Elements and ElementTrees:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = context.root
&gt;&gt;&gt; context = etree.iterwalk(root, events=events, tag="element")
&gt;&gt;&gt; for action, elem in context:
...     print action, elem.tag
start element
end element
start element
end element
</pre>
</div>
<div class="section">
<h1><a id="python-unicode-strings" name="python-unicode-strings">Python unicode strings</a></h1>
<p>lxml.etree has broader support for Python unicode strings than the ElementTree
library.  First of all, where ElementTree would raise an exception, the
parsers in lxml.etree can handle unicode strings straight away.  This is most
helpful for XML snippets embedded in source code using the <tt class="docutils literal"><span class="pre">XML()</span></tt>
function:</p>
<pre class="literal-block">
&gt;&gt;&gt; uxml = u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'
&gt;&gt;&gt; uxml
u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'
&gt;&gt;&gt; root = etree.XML(uxml)
</pre>
<p>This requires, however, that unicode strings do not specify a conflicting
encoding themselves and thus lie about their real encoding:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.XML(u'&lt;?xml version="1.0" encoding="ASCII"?&gt;\n' + uxml)
Traceback (most recent call last):
  ...
ValueError: Unicode strings with encoding declaration are not supported.
</pre>
<p>Similarly, you will get errors when you try the same with HTML data in a
unicode string that specifies a charset in a meta tag of the header.  You
should generally avoid converting XML/HTML data to unicode before passing it
into the parsers.  It is both slower and error prone.</p>
<p>To serialize the result, you would normally use the <tt class="docutils literal"><span class="pre">tostring</span></tt> module
function, which serializes to plain ASCII by default or a number of other
encodings if asked for:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.tostring(root)
'&lt;test&gt; &amp;#63697; + &amp;#63698; &lt;/test&gt;'

&gt;&gt;&gt; etree.tostring(root, 'UTF-8', xml_declaration=False)
'&lt;test&gt; \xef\xa3\x91 + \xef\xa3\x92 &lt;/test&gt;'
</pre>
<p>As an extension, lxml.etree has a new <tt class="docutils literal"><span class="pre">tounicode()</span></tt> function that you can
call on XML tree objects to retrieve a Python unicode representation:</p>
<pre class="literal-block">
&gt;&gt;&gt; etree.tounicode(root)
u'&lt;test&gt; \uf8d1 + \uf8d2 &lt;/test&gt;'

&gt;&gt;&gt; el = etree.Element("test")
&gt;&gt;&gt; etree.tounicode(el)
u'&lt;test/&gt;'

&gt;&gt;&gt; subel = etree.SubElement(el, "subtest")
&gt;&gt;&gt; etree.tounicode(el)
u'&lt;test&gt;&lt;subtest/&gt;&lt;/test&gt;'

&gt;&gt;&gt; et = etree.ElementTree(el)
&gt;&gt;&gt; etree.tounicode(et)
u'&lt;test&gt;&lt;subtest/&gt;&lt;/test&gt;'
</pre>
<p>The result of <tt class="docutils literal"><span class="pre">tounicode()</span></tt> can be treated like any other Python unicode
string and then passed back into the parsers.  However, if you want to save
the result to a file or pass it over the network, you should use <tt class="docutils literal"><span class="pre">write()</span></tt>
or <tt class="docutils literal"><span class="pre">tostring()</span></tt> with an encoding argument (typically UTF-8) to serialize the
XML.  The main reason is that unicode strings returned by <tt class="docutils literal"><span class="pre">tounicode()</span></tt>
never have an XML declaration and therefore do not specify their encoding.
These strings are most likely not parsable by other XML libraries.</p>
<p>In contrast, the <tt class="docutils literal"><span class="pre">tostring()</span></tt> function automatically adds a declaration as
needed that reflects the encoding of the returned string.  This makes it
possible for other parsers to correctly parse the XML byte stream.  Note that
using <tt class="docutils literal"><span class="pre">tostring()</span></tt> with UTF-8 is also considerably faster in most cases.</p>
</div>
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#bad-things-first">Bad things first</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#tree-traversal">Tree traversal</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#xinclude">xinclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML with lxml</a><ul class="submenu current"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#creating-objectify-trees">Creating objectify trees</a></li><li class="menu item"><a href="objectify.html#element-access-through-object-attributes">Element access through object attributes</a></li><li class="menu item"><a href="objectify.html#namespace-handling">Namespace handling</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#defining-additional-data-classes">Defining additional data classes</a></li><li class="menu item"><a href="objectify.html#recursive-string-representation-of-elements">Recursive string representation of elements</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-elementtree?">What is different from ElementTree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#document-loaders-in-context">Document loaders in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div></div>
</body>
</html>