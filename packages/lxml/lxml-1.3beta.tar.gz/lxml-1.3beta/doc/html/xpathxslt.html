<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>XPath and XSLT with lxml</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="xpath-and-xslt-with-lxml">
<h1 class="title">XPath and XSLT with lxml</h1>
<p>lxml supports both XPath and XSLT through libxml2 and libxslt in a standards
compliant way.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#xpath" id="id1" name="id1">XPath</a></li>
<li><a class="reference" href="#xslt" id="id2" name="id2">XSLT</a></li>
</ul>
</div>
<p>The usual setup procedure:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree
&gt;&gt;&gt; from StringIO import StringIO
</pre>
<div class="section">
<h1><a id="xpath" name="xpath">XPath</a></h1>
<p>lxml.etree supports the simple path syntax of the <tt class="docutils literal"><span class="pre">findall()</span></tt> etc.  methods
on ElementTree and Element, as known from the original ElementTree library.
As an extension, these classes also provide an <tt class="docutils literal"><span class="pre">xpath()</span></tt> method that
supports expressions in the complete XPath syntax.</p>
<p>There are also specialized XPath evaluator classes that are more efficient for
frequent evaluation: <tt class="docutils literal"><span class="pre">XPath</span></tt> and <tt class="docutils literal"><span class="pre">XPathEvaluator</span></tt>.  See the <a class="reference" href="performance.html#xpath">performance
comparison</a> to learn when to use which.  Their semantics when used on
Elements and ElementTrees are the same as for the <tt class="docutils literal"><span class="pre">xpath()</span></tt> method described
here.</p>
<p>For ElementTree, the xpath method performs a global XPath query against the
document (if absolute) or against the root node (if relative):</p>
<pre class="literal-block">
&gt;&gt;&gt; f = StringIO('&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;')
&gt;&gt;&gt; tree = etree.parse(f)

&gt;&gt;&gt; r = tree.xpath('/foo/bar')
&gt;&gt;&gt; len(r)
1
&gt;&gt;&gt; r[0].tag
'bar'

&gt;&gt;&gt; r = tree.xpath('bar')
&gt;&gt;&gt; r[0].tag
'bar'
</pre>
<p>When <tt class="docutils literal"><span class="pre">xpath()</span></tt> is used on an element, the XPath expression is evaluated
against the element (if relative) or against the root tree (if absolute):</p>
<pre class="literal-block">
&gt;&gt;&gt; root = tree.getroot()
&gt;&gt;&gt; r = root.xpath('bar')
&gt;&gt;&gt; r[0].tag
'bar'

&gt;&gt;&gt; bar = root[0]
&gt;&gt;&gt; r = bar.xpath('/foo/bar')
&gt;&gt;&gt; r[0].tag
'bar'

&gt;&gt;&gt; tree = bar.getroottree()
&gt;&gt;&gt; r = tree.xpath('/foo/bar')
&gt;&gt;&gt; r[0].tag
'bar'
</pre>
<p>Optionally, you can provide a <tt class="docutils literal"><span class="pre">namespaces</span></tt> keyword argument, which should be
a dictionary mapping the namespace prefixes used in the XPath expression to
namespace URIs:</p>
<pre class="literal-block">
&gt;&gt;&gt; f = StringIO('''\
... &lt;a:foo xmlns:a="http://codespeak.net/ns/test1"
...       xmlns:b="http://codespeak.net/ns/test2"&gt;
...    &lt;b:bar&gt;Text&lt;/b:bar&gt;
... &lt;/a:foo&gt;
... ''')
&gt;&gt;&gt; doc = etree.parse(f)
&gt;&gt;&gt; r = doc.xpath('/t:foo/b:bar', {'t': 'http://codespeak.net/ns/test1',
...                                'b': 'http://codespeak.net/ns/test2'})
&gt;&gt;&gt; len(r)
1
&gt;&gt;&gt; r[0].tag
'{http://codespeak.net/ns/test2}bar'
&gt;&gt;&gt; r[0].text
'Text'
</pre>
<p>There is also an optional <tt class="docutils literal"><span class="pre">extensions</span></tt> argument which is used to define
<a class="reference" href="extensions.html">extension functions</a> in Python that are local to this evaluation.</p>
<p>The return values of XPath evaluations vary, depending on the XPath expression
used:</p>
<ul class="simple">
<li>True or False, when the XPath expression has a boolean result</li>
<li>a float, when the XPath expression has a numeric result (integer or float)</li>
<li>a (unicode) string, when the XPath expression has a string result.</li>
<li>a list of items, when the XPath expression has a list as result.  The items
may include elements, strings and tuples.  Text nodes and attributes in the
result are returned as strings (the text node content or attribute value).
Comments are also returned as strings, enclosed by the usual <tt class="docutils literal"><span class="pre">&lt;!--</span></tt> and
<tt class="docutils literal"><span class="pre">--&gt;</span></tt> markers.  Namespace declarations are returned as tuples of strings:
<tt class="docutils literal"><span class="pre">(prefix,</span> <span class="pre">URI)</span></tt>.</li>
</ul>
<p>A related convenience method of ElementTree objects is <tt class="docutils literal"><span class="pre">getpath(element)</span></tt>,
which returns a structural, absolute XPath expression to find that element:</p>
<pre class="literal-block">
&gt;&gt;&gt; a  = etree.Element("a")
&gt;&gt;&gt; b  = etree.SubElement(a, "b")
&gt;&gt;&gt; c  = etree.SubElement(a, "c")
&gt;&gt;&gt; d1 = etree.SubElement(c, "d")
&gt;&gt;&gt; d2 = etree.SubElement(c, "d")

&gt;&gt;&gt; tree = etree.ElementTree(c)
&gt;&gt;&gt; print tree.getpath(d2)
/c/d[2]
&gt;&gt;&gt; tree.xpath(tree.getpath(d2)) == [d2]
True
</pre>
</div>
<div class="section">
<h1><a id="xslt" name="xslt">XSLT</a></h1>
<p>lxml.etree introduces a new class, lxml.etree.XSLT. The class can be
given an ElementTree object to construct an XSLT transformer:</p>
<pre class="literal-block">
&gt;&gt;&gt; f = StringIO('''\
... &lt;xsl:stylesheet version="1.0"
...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
...     &lt;xsl:template match="/"&gt;
...         &lt;foo&gt;&lt;xsl:value-of select="/a/b/text()" /&gt;&lt;/foo&gt;
...     &lt;/xsl:template&gt;
... &lt;/xsl:stylesheet&gt;''')
&gt;&gt;&gt; xslt_doc = etree.parse(f)
&gt;&gt;&gt; transform = etree.XSLT(xslt_doc)
</pre>
<p>You can then run the transformation on an ElementTree document by simply
calling it, and this results in another ElementTree object:</p>
<pre class="literal-block">
&gt;&gt;&gt; f = StringIO('&lt;a&gt;&lt;b&gt;Text&lt;/b&gt;&lt;/a&gt;')
&gt;&gt;&gt; doc = etree.parse(f)
&gt;&gt;&gt; result = transform(doc)
</pre>
<p>The result object can be accessed like a normal ElementTree document:</p>
<pre class="literal-block">
&gt;&gt;&gt; result.getroot().text
'Text'
</pre>
<p>but, as opposed to normal ElementTree objects, can also be turned into an (XML
or text) string by applying the str() function:</p>
<pre class="literal-block">
&gt;&gt;&gt; str(result)
'&lt;?xml version="1.0"?&gt;\n&lt;foo&gt;Text&lt;/foo&gt;\n'
</pre>
<p>The result is always a plain string, encoded as requested by the
<tt class="docutils literal"><span class="pre">xsl:output</span></tt> element in the stylesheet.  If you want a Python unicode string
instead, you should set this encoding to <tt class="docutils literal"><span class="pre">UTF-8</span></tt> (unless the <cite>ASCII</cite> default
is sufficient).  This allows you to call the builtin <tt class="docutils literal"><span class="pre">unicode()</span></tt> function on
the result:</p>
<pre class="literal-block">
&gt;&gt;&gt; unicode(result)
u'&lt;?xml version="1.0"?&gt;\n&lt;foo&gt;Text&lt;/foo&gt;\n'
</pre>
<p>You can use other encodings at the cost of multiple recoding.  Encodings that
are not supported by Python will result in an error:</p>
<pre class="literal-block">
&gt;&gt;&gt; xslt_tree = etree.XML('''\
... &lt;xsl:stylesheet version="1.0"
...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
...     &lt;xsl:output encoding="UCS4"/&gt;
...     &lt;xsl:template match="/"&gt;
...         &lt;foo&gt;&lt;xsl:value-of select="/a/b/text()" /&gt;&lt;/foo&gt;
...     &lt;/xsl:template&gt;
... &lt;/xsl:stylesheet&gt;''')
&gt;&gt;&gt; transform = etree.XSLT(xslt_tree)

&gt;&gt;&gt; result = transform(doc)
&gt;&gt;&gt; unicode(result)
Traceback (most recent call last):
  [...]
LookupError: unknown encoding: UCS4
</pre>
<p>It is possible to pass parameters, in the form of XPath expressions, to the
XSLT template:</p>
<pre class="literal-block">
&gt;&gt;&gt; xslt_tree = etree.XML('''\
... &lt;xsl:stylesheet version="1.0"
...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
...     &lt;xsl:template match="/"&gt;
...         &lt;foo&gt;&lt;xsl:value-of select="$a" /&gt;&lt;/foo&gt;
...     &lt;/xsl:template&gt;
... &lt;/xsl:stylesheet&gt;''')
&gt;&gt;&gt; transform = etree.XSLT(xslt_tree)
&gt;&gt;&gt; f = StringIO('&lt;a&gt;&lt;b&gt;Text&lt;/b&gt;&lt;/a&gt;')
&gt;&gt;&gt; doc = etree.parse(f)
</pre>
<p>The parameters are passed as keyword parameters to the transform call. First
let's try passing in a simple string expression:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = transform(doc, a="'A'")
&gt;&gt;&gt; str(result)
'&lt;?xml version="1.0"?&gt;\n&lt;foo&gt;A&lt;/foo&gt;\n'
</pre>
<p>Let's try a non-string XPath expression now:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = transform(doc, a="/a/b/text()")
&gt;&gt;&gt; str(result)
'&lt;?xml version="1.0"?&gt;\n&lt;foo&gt;Text&lt;/foo&gt;\n'
</pre>
<p>There's also a convenience method on the tree object for doing XSL
transformations.  This is less efficient if you want to apply the same XSL
transformation to multiple documents, but is shorter to write for one-shot
operations, as you do not have to instantiate a stylesheet yourself:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = doc.xslt(xslt_tree, a="'A'")
&gt;&gt;&gt; str(result)
'&lt;?xml version="1.0"?&gt;\n&lt;foo&gt;A&lt;/foo&gt;\n'
</pre>
<p>By default, XSLT supports all extension functions from libxslt and libexslt as
well as Python regular expressions through EXSLT.  Note that some extensions
enable style sheets to read and write files on the local file system.  See the
<a class="reference" href="resolvers.html">document loader documentation</a> on how to deal with this.</p>
<p>If you want to know how your stylesheet performed, pass the <tt class="docutils literal"><span class="pre">profile_run</span></tt>
keyword to the transform:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = transform(doc, a="/a/b/text()", profile_run=True)
&gt;&gt;&gt; profile = result.xslt_profile
</pre>
<p>The value of the <tt class="docutils literal"><span class="pre">xslt_profile</span></tt> property is an ElementTree with profiling
data about each template, similar to the following:</p>
<pre class="literal-block">
&lt;profile&gt;
  &lt;template rank="1" match="/" name="" mode="" calls="1" time="1" average="1"/&gt;
&lt;/profile&gt;
</pre>
<p>Note that this is a read-only document.  You must not move any of its elements
to other documents.  Please deep-copy the document if you need to modify it.
If you want to free it from memory, just do:</p>
<pre class="literal-block">
&gt;&gt;&gt; del result.xslt_profile
</pre>
</div>
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#bad-things-first">Bad things first</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#tree-traversal">Tree traversal</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#xinclude">xinclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu current"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#creating-objectify-trees">Creating objectify trees</a></li><li class="menu item"><a href="objectify.html#element-access-through-object-attributes">Element access through object attributes</a></li><li class="menu item"><a href="objectify.html#namespace-handling">Namespace handling</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#defining-additional-data-classes">Defining additional data classes</a></li><li class="menu item"><a href="objectify.html#recursive-string-representation-of-elements">Recursive string representation of elements</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-elementtree?">What is different from ElementTree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#document-loaders-in-context">Document loaders in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div></div>
</body>
</html>