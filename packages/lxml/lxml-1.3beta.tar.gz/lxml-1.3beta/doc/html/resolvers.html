<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Document loading and URL resolving</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="document-loading-and-url-resolving">
<h1 class="title">Document loading and URL resolving</h1>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#document-loaders-in-context" id="id1" name="id1">Document loaders in context</a></li>
<li><a class="reference" href="#i-o-access-control-in-xslt" id="id2" name="id2">I/O access control in XSLT</a></li>
</ul>
</div>
<p>Lxml has support for custom document loaders in both the parsers and XSL
transformations.  These so-called resolvers are subclasses of the
etree.Resolver class as in the following example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from lxml import etree

&gt;&gt;&gt; class DTDResolver(etree.Resolver):
...     def resolve(self, url, id, context):
...         print "Resolving URL '%s'" % url
...         return self.resolve_string(
...             '&lt;!ENTITY myentity "[resolved text: %s]"&gt;' % url, context)
</pre>
<p>This defines a resolver that always returns a dynamically generated DTD
fragment defining an entity.  The <tt class="docutils literal"><span class="pre">url</span></tt> argument passes the system URL of
the requested document, the <tt class="docutils literal"><span class="pre">id</span></tt> argument is the public ID.  Note that any
of these may be None.  The context object is not normally used by client code.</p>
<p>Resolving is based on three methods of the Resolver object that build internal
representations of the result document.  The following methods exist:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">resolve_string</span></tt> takes a parsable string as result document</li>
<li><tt class="docutils literal"><span class="pre">resolve_filename</span></tt> takes a filename</li>
<li><tt class="docutils literal"><span class="pre">resolve_file</span></tt> takes an open file-like object that has at least a read() method</li>
<li><tt class="docutils literal"><span class="pre">resolve_empty</span></tt> resolves into an empty document</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">resolve</span></tt> method may choose to return None, in which case the next
registered resolver (or the default resolver) is consulted.  It is never
called if the resolver returns the result of any of the above <tt class="docutils literal"><span class="pre">resolve_*</span></tt>
methods.</p>
<p>Resolvers are registered local to a parser:</p>
<pre class="literal-block">
&gt;&gt;&gt; parser = etree.XMLParser(load_dtd=True)
&gt;&gt;&gt; parser.resolvers.add( DTDResolver() )
</pre>
<p>Note that we instantiate a parser that loads the DTD.  This is not done by the
default parser, which does no validation.  When we use this parser to parse a
document that requires resolving a URL, it will call our custom resolver:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml = u'&lt;!DOCTYPE doc SYSTEM "MissingDTD.dtd"&gt;&lt;doc&gt;&amp;myentity;&lt;/doc&gt;'
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; tree = etree.parse(StringIO(xml), parser)
Resolving URL 'MissingDTD.dtd'
&gt;&gt;&gt; root = tree.getroot()
&gt;&gt;&gt; print root.text
[resolved text: MissingDTD.dtd]
</pre>
<p>The entity in the document was correctly resolved by the generated DTD
fragment.</p>
<div class="section">
<h1><a id="document-loaders-in-context" name="document-loaders-in-context">Document loaders in context</a></h1>
<p>XML documents memorise their initial parser (and its resolvers) during their
life-time.  This means that a lookup process related to a document will use
the resolvers of the document's parser.  We can demonstrate this with a
resolver that only responds to a specific prefix:</p>
<pre class="literal-block">
&gt;&gt;&gt; class PrefixResolver(etree.Resolver):
...     def __init__(self, prefix):
...         self.prefix = prefix
...         self.result_xml = '''\
...              &lt;xsl:stylesheet
...                     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
...                &lt;test xmlns="testNS"&gt;%s-TEST&lt;/test&gt;
...              &lt;/xsl:stylesheet&gt;
...              ''' % prefix
...     def resolve(self, url, pubid, context):
...         if url.startswith(self.prefix):
...             print "Resolved url %s as prefix %s" % (url, self.prefix)
...             return self.resolve_string(self.result_xml, context)
</pre>
<p>We demonstrate this in XSLT and use the following stylesheet as an example:</p>
<pre class="literal-block">
&gt;&gt;&gt; xml_text = """\
... &lt;xsl:stylesheet version="1.0"
...    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
...   &lt;xsl:include href="honk:test"/&gt;
...   &lt;xsl:template match="/"&gt;
...     &lt;test&gt;
...       &lt;xsl:value-of select="document('hoi:test')/*/*/text()"/&gt;
...     &lt;/test&gt;
...   &lt;/xsl:template&gt;
... &lt;/xsl:stylesheet&gt;
... """
</pre>
<p>Note that it needs to resolve two URIs: <tt class="docutils literal"><span class="pre">honk:test</span></tt> when compiling the XSLT
document (i.e. when resolving <tt class="docutils literal"><span class="pre">xsl:import</span></tt> and <tt class="docutils literal"><span class="pre">xsl:include</span></tt> elements) and
<tt class="docutils literal"><span class="pre">hoi:test</span></tt> at transformation time, when calls to the <tt class="docutils literal"><span class="pre">document</span></tt> function
are resolved.  If we now register different resolvers with two different
parsers, we can parse our document twice in different resolver contexts:</p>
<pre class="literal-block">
&gt;&gt;&gt; hoi_parser = etree.XMLParser()
&gt;&gt;&gt; normal_doc = etree.parse(StringIO(xml_text), hoi_parser)

&gt;&gt;&gt; hoi_parser.resolvers.add( PrefixResolver("hoi") )
&gt;&gt;&gt; hoi_doc = etree.parse(StringIO(xml_text), hoi_parser)

&gt;&gt;&gt; honk_parser = etree.XMLParser()
&gt;&gt;&gt; honk_parser.resolvers.add( PrefixResolver("honk") )
&gt;&gt;&gt; honk_doc = etree.parse(StringIO(xml_text), honk_parser)
</pre>
<p>These contexts are important for the further behaviour of the documents.  They
memorise their original parser so that the correct set of resolvers is used in
subsequent lookups.  To compile the stylesheet, XSLT must resolve the
<tt class="docutils literal"><span class="pre">honk:test</span></tt> URI in the <tt class="docutils literal"><span class="pre">xsl:include</span></tt> element.  The <tt class="docutils literal"><span class="pre">hoi</span></tt> resolver cannot
do that:</p>
<pre class="literal-block">
&gt;&gt;&gt; transform = etree.XSLT(normal_doc)
Traceback (most recent call last):
  [...]
XSLTParseError: Cannot resolve URI honk:test

&gt;&gt;&gt; transform = etree.XSLT(hoi_doc)
Traceback (most recent call last):
  [...]
XSLTParseError: Cannot resolve URI honk:test
</pre>
<p>However, if we use the <tt class="docutils literal"><span class="pre">honk</span></tt> resolver associated with the respective
document, everything works fine:</p>
<pre class="literal-block">
&gt;&gt;&gt; transform = etree.XSLT(honk_doc)
Resolved url honk:test as prefix honk
</pre>
<p>Running the transform accesses the same parser context again, but since it now
needs to resolve the <tt class="docutils literal"><span class="pre">hoi</span></tt> URI in the call to the document function, its
<tt class="docutils literal"><span class="pre">honk</span></tt> resolver will fail to do so:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = transform(normal_doc)
Traceback (most recent call last):
  [...]
XSLTApplyError: Cannot resolve URI hoi:test

&gt;&gt;&gt; result = transform(hoi_doc)
Traceback (most recent call last):
  [...]
XSLTApplyError: Cannot resolve URI hoi:test

&gt;&gt;&gt; result = transform(honk_doc)
Traceback (most recent call last):
  [...]
XSLTApplyError: Cannot resolve URI hoi:test
</pre>
<p>This can only be solved by adding a <tt class="docutils literal"><span class="pre">hoi</span></tt> resolver to the original parser:</p>
<pre class="literal-block">
&gt;&gt;&gt; honk_parser.resolvers.add( PrefixResolver("hoi") )
&gt;&gt;&gt; result = transform(honk_doc)
Resolved url hoi:test as prefix hoi
&gt;&gt;&gt; print str(result),
&lt;?xml version="1.0"?&gt;
&lt;test&gt;hoi-TEST&lt;/test&gt;
</pre>
<p>We can see that the <tt class="docutils literal"><span class="pre">hoi</span></tt> resolver was called to generate a document that
was then inserted into the result document by the XSLT transformation.  Note
that this is completely independent of the XML file you transform, as the URI
is resolved from within the stylesheet context:</p>
<pre class="literal-block">
&gt;&gt;&gt; result = transform(normal_doc)
Resolved url hoi:test as prefix hoi
&gt;&gt;&gt; print str(result),
&lt;?xml version="1.0"?&gt;
&lt;test&gt;hoi-TEST&lt;/test&gt;
</pre>
<p>It may be seen as a matter of taste what resolvers the generated document
inherits.  For XSLT, the output document inherits the resolvers of the input
document and not those of the stylesheet.  Therefore, the last result does not
inherit any resolvers at all.</p>
</div>
<div class="section">
<h1><a id="i-o-access-control-in-xslt" name="i-o-access-control-in-xslt">I/O access control in XSLT</a></h1>
<p>XSLT has an additional mechanism to control the access to certain I/O
operations during the transformation process.  This is most interesting where
XSL scripts come from potentially insecure sources and must be prevented from
modifying the local file system.  Note, however, that there is no way to keep
them from eating up your precious CPU time, so this should not stop you from
thinking about what XSLT you execute.</p>
<p>Access control is configured using the <tt class="docutils literal"><span class="pre">XSLTAccessControl</span></tt> class.  It can be
called with a number of keyword arguments that allow or deny specific
operations:</p>
<pre class="literal-block">
&gt;&gt;&gt; transform = etree.XSLT(honk_doc)
Resolved url honk:test as prefix honk
&gt;&gt;&gt; result = transform(normal_doc)
Resolved url hoi:test as prefix hoi

&gt;&gt;&gt; ac = etree.XSLTAccessControl(read_network=False)
&gt;&gt;&gt; transform = etree.XSLT(honk_doc, access_control=ac)
Resolved url honk:test as prefix honk
&gt;&gt;&gt; result = transform(normal_doc)
Traceback (most recent call last):
  [...]
XSLTApplyError: xsltLoadDocument: read rights for hoi:test denied
</pre>
<p>There are a few things to keep in mind:</p>
<ul class="simple">
<li>XSL parsing (<tt class="docutils literal"><span class="pre">xsl:import</span></tt>, etc.) is not affected by this mechanism</li>
<li><tt class="docutils literal"><span class="pre">read_file=False</span></tt> does not imply <tt class="docutils literal"><span class="pre">write_file=False</span></tt>, all controls are
independent.</li>
<li><tt class="docutils literal"><span class="pre">read_file</span></tt> only applies to files in the file system.  Any other scheme
for URLs is controlled by the <tt class="docutils literal"><span class="pre">*_network</span></tt> keywords.</li>
<li>If you need more fine-grained control than switching access on and off, you
should consider writing a custom document loader that returns empty
documents or raises exceptions if access is denied.</li>
</ul>
</div>
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#bad-things-first">Bad things first</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#tree-traversal">Tree traversal</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#xinclude">xinclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#creating-objectify-trees">Creating objectify trees</a></li><li class="menu item"><a href="objectify.html#element-access-through-object-attributes">Element access through object attributes</a></li><li class="menu item"><a href="objectify.html#namespace-handling">Namespace handling</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#defining-additional-data-classes">Defining additional data classes</a></li><li class="menu item"><a href="objectify.html#recursive-string-representation-of-elements">Recursive string representation of elements</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-elementtree?">What is different from ElementTree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu current"><li class="menu item"><a href="resolvers.html#document-loaders-in-context">Document loaders in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div></div>
</body>
</html>