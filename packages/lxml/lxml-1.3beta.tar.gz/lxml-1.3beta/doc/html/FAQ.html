<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Frequently Asked Questions</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="frequently-asked-questions">
<h1 class="title">Frequently Asked Questions</h1>
<p>See also the notes on <a class="reference" href="compatibility.html">compatibility</a> to <a class="reference" href="http://effbot.org/zone/element-index.htm">ElementTree</a>.</p>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#general-questions" id="id2" name="id2">General Questions</a><ul>
<li><a class="reference" href="#is-there-a-tutorial" id="id3" name="id3">Is there a tutorial?</a></li>
<li><a class="reference" href="#where-can-i-find-more-documentation-about-lxml" id="id4" name="id4">Where can I find more documentation about lxml?</a></li>
<li><a class="reference" href="#where-are-the-windows-binaries" id="id5" name="id5">Where are the Windows binaries?</a></li>
<li><a class="reference" href="#what-is-the-difference-between-lxml-etree-and-lxml-objectify" id="id6" name="id6">What is the difference between lxml.etree and lxml.objectify?</a></li>
<li><a class="reference" href="#why-is-my-application-so-slow" id="id7" name="id7">Why is my application so slow?</a></li>
<li><a class="reference" href="#why-do-i-get-errors-about-missing-ucs4-symbols-when-installing-lxml" id="id8" name="id8">Why do I get errors about missing UCS4 symbols when installing lxml?</a></li>
</ul>
</li>
<li><a class="reference" href="#bugs" id="id9" name="id9">Bugs</a><ul>
<li><a class="reference" href="#my-application-crashes-why-does-lxml-etree-do-that" id="id10" name="id10">My application crashes! Why does lxml.etree do that?</a></li>
<li><a class="reference" href="#i-think-i-have-found-a-bug-in-lxml-what-should-i-do" id="id11" name="id11">I think I have found a bug in lxml. What should I do?</a></li>
</ul>
</li>
<li><a class="reference" href="#id1" id="id12" name="id12">Threading</a><ul>
<li><a class="reference" href="#can-i-use-threads-to-concurrently-access-the-lxml-api" id="id13" name="id13">Can I use threads to concurrently access the lxml API?</a></li>
<li><a class="reference" href="#does-my-program-run-faster-if-i-use-threads" id="id14" name="id14">Does my program run faster if I use threads?</a></li>
<li><a class="reference" href="#would-my-single-threaded-program-run-faster-if-i-turned-off-threading" id="id15" name="id15">Would my single-threaded program run faster if I turned off threading?</a></li>
</ul>
</li>
<li><a class="reference" href="#parsing-and-serialisation" id="id16" name="id16">Parsing and Serialisation</a><ul>
<li><a class="reference" href="#why-doesn-t-the-pretty-print-option-reformat-my-xml-output" id="id17" name="id17">Why doesn't the <tt class="docutils literal"><span class="pre">pretty_print</span></tt> option reformat my XML output?</a></li>
<li><a class="reference" href="#why-can-t-lxml-parse-my-xml-from-unicode-strings" id="id18" name="id18">Why can't lxml parse my XML from unicode strings?</a></li>
<li><a class="reference" href="#what-is-the-difference-between-str-xslt-doc-and-xslt-doc-write" id="id19" name="id19">What is the difference between str(xslt(doc)) and xslt(doc).write() ?</a></li>
<li><a class="reference" href="#why-can-t-i-just-delete-parents-or-clear-the-root-node-in-iterparse" id="id20" name="id20">Why can't I just delete parents or clear the root node in iterparse()?</a></li>
</ul>
</li>
<li><a class="reference" href="#xpath-and-document-traversal" id="id21" name="id21">XPath and Document Traversal</a><ul>
<li><a class="reference" href="#what-are-the-findall-and-xpath-methods-on-element-tree" id="id22" name="id22">What are the <tt class="docutils literal"><span class="pre">findall()</span></tt> and <tt class="docutils literal"><span class="pre">xpath()</span></tt> methods on Element(Tree)?</a></li>
<li><a class="reference" href="#why-doesn-t-findall-support-full-xpath-expressions" id="id23" name="id23">Why doesn't <tt class="docutils literal"><span class="pre">findall()</span></tt> support full XPath expressions?</a></li>
<li><a class="reference" href="#how-can-i-find-out-which-namespace-prefixes-are-used-in-a-document" id="id24" name="id24">How can I find out which namespace prefixes are used in a document?</a></li>
<li><a class="reference" href="#how-can-i-specify-a-default-namespace-for-xpath-expressions" id="id25" name="id25">How can I specify a default namespace for XPath expressions?</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a id="general-questions" name="general-questions">General Questions</a></h1>
<div class="section">
<h2><a id="is-there-a-tutorial" name="is-there-a-tutorial">Is there a tutorial?</a></h2>
<p>There is a <a class="reference" href="http://effbot.org/zone/element.htm">tutorial for ElementTree</a> which also works for <tt class="docutils literal"><span class="pre">lxml.etree</span></tt>.
The <a class="reference" href="api.html">API documentation</a> also contains many examples for <tt class="docutils literal"><span class="pre">lxml.etree</span></tt>.  To
learn using <tt class="docutils literal"><span class="pre">lxml.objectify</span></tt>, read the <a class="reference" href="objectify.html">objectify documentation</a>.</p>
</div>
<div class="section">
<h2><a id="where-can-i-find-more-documentation-about-lxml" name="where-can-i-find-more-documentation-about-lxml">Where can I find more documentation about lxml?</a></h2>
<p>There is a lot of documentation as lxml implements the well-known <a class="reference" href="http://effbot.org/zone/element-index.htm">ElementTree
API</a> and tries to follow its documentation as closely as possible.  There are
a couple of issues where lxml cannot keep up compatibility.  They are
described in the <a class="reference" href="compatibility.html">compatibility</a> documentation.  The lxml specific extensions
to the API are described by individual files in the <tt class="docutils literal"><span class="pre">doc</span></tt> directory of the
distribution and on <a class="reference" href="http://codespeak.net/lxml/#documentation">the web page</a>.</p>
</div>
<div class="section">
<h2><a id="where-are-the-windows-binaries" name="where-are-the-windows-binaries">Where are the Windows binaries?</a></h2>
<p>Short answer: If you want to contribute a binary build, we are happy to put it
up on the Cheeseshop.</p>
<p>Long answer: Two of the bigger problems with the Windows system are the lack
of a pre-installed standard compiler and the missing package management.  Both
make it non-trivial to build lxml on this platform.  We are trying hard to
make lxml as platform-independent as possible and it is regularly tested on
Windows systems.  However, we currently cannot provide Windows binary
distributions ourselves.</p>
<p>From time to time, users of different environments kindly contribute binary
builds of lxml, most frequently for Windows or Mac-OS X.  We put these on the
Cheeseshop to make it as easy as possible for others to use lxml on their
platform.</p>
<p>If there is not currently a binary distribution of the most recent lxml
release for your platform available from the Cheeseshop, please look through
the older versions to see if they provide a binary build.  This is done by
appending the version number to the cheeseshop URL, e.g.:</p>
<blockquote>
<a class="reference" href="http://cheeseshop.python.org/pypi/lxml/1.1.2">http://cheeseshop.python.org/pypi/lxml/1.1.2</a></blockquote>
</div>
<div class="section">
<h2><a id="what-is-the-difference-between-lxml-etree-and-lxml-objectify" name="what-is-the-difference-between-lxml-etree-and-lxml-objectify">What is the difference between lxml.etree and lxml.objectify?</a></h2>
<p>The two modules provide different ways of handling XML.  However, objectify
builds on top of lxml.etree and therefore inherits most of its capabilities
and a large portion of its API.</p>
<ul>
<li><p class="first">lxml.etree is a generic API for XML and HTML handling.  It aims for
ElementTree <a class="reference" href="compatibility.html">compatibility</a> and supports the entire XML infoset.  It is well
suited for both mixed content and data centric XML.  Its generality makes it
the best choice for most applications.</p>
</li>
<li><p class="first">lxml.objectify is a specialized API for XML data handling in a Python object
syntax.  It provides a very natural way to deal with data fields stored in a
structurally well defined XML format.  Data is automatically converted to
Python data types and can be manipulated with normal Python operators.  Look
at the examples in the <a class="reference" href="objectify.html">objectify documentation</a> to see what it feels like
to use it.</p>
<p>Objectify is not well suited for mixed contents or HTML documents.  As it is
built on top of lxml.etree, however, it inherits the normal support for
XPath, XSLT or validation.</p>
</li>
</ul>
</div>
<div class="section">
<h2><a id="why-is-my-application-so-slow" name="why-is-my-application-so-slow">Why is my application so slow?</a></h2>
<p>lxml.etree is a very fast library for processing XML.  There are, however, <a class="reference" href="performance.html#the-elementtree-api">a
few caveats</a> involved in the mapping of the powerful libxml2 library to the
simple and convenient ElementTree API.  Not all operations are as fast as the
simplicity of the API might suggest.  The <a class="reference" href="performance.html">benchmark page</a> has a comparison
to other ElementTree implementations and a number of tips for performance
tweaking.  As with any Python application, the rule of thumb is: the more of
your processing runs in C, the faster your application gets.  See also the
section on <a class="reference" href="#threading">threading</a>.</p>
</div>
<div class="section">
<h2><a id="why-do-i-get-errors-about-missing-ucs4-symbols-when-installing-lxml" name="why-do-i-get-errors-about-missing-ucs4-symbols-when-installing-lxml">Why do I get errors about missing UCS4 symbols when installing lxml?</a></h2>
<p>Most likely, you use a Python installation that was configured for internal
use of UCS2 unicode, meaning 16-bit unicode.  The lxml egg distributions are
generally compiled on platforms that use UCS4, a 32-bit unicode encoding, as
this is used on the majority of platforms.  Sadly, both are not compatible, so
the eggs can only support the one they were compiled with.</p>
<p>This means that you have to compile lxml from sources for your system.  Note
that you do not need Pyrex for this, the lxml source distribution is directly
compilable on both platform types.  See the <a class="reference" href="build.html">build instructions</a> on how to do
this.</p>
</div>
</div>
<div class="section">
<h1><a id="bugs" name="bugs">Bugs</a></h1>
<div class="section">
<h2><a id="my-application-crashes-why-does-lxml-etree-do-that" name="my-application-crashes-why-does-lxml-etree-do-that">My application crashes! Why does lxml.etree do that?</a></h2>
<p>One of the goals of lxml is "no segfaults", so if there is no clear warning in
the documentation that you were doing something potentially harmful, you have
found a bug and we would like to hear about it.  Please report this bug to the
mailing list.  See the next section on how to do that.</p>
</div>
<div class="section">
<h2><a id="i-think-i-have-found-a-bug-in-lxml-what-should-i-do" name="i-think-i-have-found-a-bug-in-lxml-what-should-i-do">I think I have found a bug in lxml. What should I do?</a></h2>
<ol class="loweralpha">
<li><p class="first">First, you should look at the <a class="reference" href="http://codespeak.net/svn/lxml/trunk/CHANGES.txt">current developer changelog</a> to see if this
is a known problem that has already been fixed in the SVN trunk.</p>
</li>
<li><p class="first">If you are using threads, please see the following section to check if
you touch on one of the potential pitfalls.</p>
</li>
<li><p class="first">Otherwise, we would really like to hear about it.  Please report it to the
<a class="reference" href="http://codespeak.net/mailman/listinfo/lxml-dev">mailing list</a> so that we can fix it.  It is very helpful in this case if
you can come up with a short code snippet that demonstrates your problem.
Please also report the version of lxml, libxml2 and libxslt that you are
using by calling this:</p>
<pre class="literal-block">
from lxml import etree
print "lxml.etree:       ", etree.LXML_VERSION
print "libxml used:      ", etree.LIBXML_VERSION
print "libxml compiled:  ", etree.LIBXML_COMPILED_VERSION
print "libxslt used:     ", etree.LIBXSLT_VERSION
print "libxslt compiled: ", etree.LIBXSLT_COMPILED_VERSION
</pre>
</li>
</ol>
</div>
</div>
<div class="section">
<h1><a id="id1" name="id1">Threading</a></h1>
<div class="section">
<h2><a id="can-i-use-threads-to-concurrently-access-the-lxml-api" name="can-i-use-threads-to-concurrently-access-the-lxml-api">Can I use threads to concurrently access the lxml API?</a></h2>
<p>Yes, although not carelessly.</p>
<p>lxml frees the GIL (Python's global interpreter lock) internally when parsing
from disk and memory, as long as you use either the default parser (which is
replicated for each thread) or create a parser for each thread yourself.  lxml
also allows concurrency during validation (RelaxNG and XMLSchema) and XSL
transformation.  You can share RelaxNG, XMLSchema and XSLT objects between
threads.  While you can also share parsers between threads, this will
serialize the access to each of them, so it is better to copy() parsers or to
use the default parser.  Note that access to the XML() and HTML() functions is
always serialized.  If you need to parse concurrently from strings, use
<tt class="docutils literal"><span class="pre">parse()</span></tt> with <tt class="docutils literal"><span class="pre">StringIO</span></tt>.</p>
<p>Due to the way libxslt handles threading, concurrent access to stylesheets is
currently only possible if it was parsed in the main thread.  Parsing and
applying a stylesheet inside one thread also works.</p>
<p>Warning: You should generally avoid modifying trees in other threads than the
one it was generated in.  Although this should work in many cases, there are
certain scenarios where the termination of a thread that parsed a tree can
crash the application if subtrees of this tree were moved to other documents.
You should be on the safe side when passing trees between threads if you
either</p>
<ol class="loweralpha simple">
<li>do not modify these trees and do not move their elements to other trees, or</li>
<li>do not terminate threads while the trees they parsed are still in use
(e.g. by using a fixed size thread-pool or long-running threads in
processing chains)</li>
</ol>
</div>
<div class="section">
<h2><a id="does-my-program-run-faster-if-i-use-threads" name="does-my-program-run-faster-if-i-use-threads">Does my program run faster if I use threads?</a></h2>
<p>Depends.  The best way to answer this is timing and profiling.</p>
<p>The global interpreter lock (GIL) in Python serializes access to the
interpreter, so if the majority of your processing is done in Python code
(walking trees, modifying elements, etc.), your gain will be close to 0.  The
more of your XML processing moves into lxml, however, the higher your gain.
If your application is bound by XML parsing and serialisation, or by complex
XSLTs, your speedup on multi-processor machines can be substantial.</p>
<p>See the question above to learn which operations free the GIL to support
multi-threading.</p>
</div>
<div class="section">
<h2><a id="would-my-single-threaded-program-run-faster-if-i-turned-off-threading" name="would-my-single-threaded-program-run-faster-if-i-turned-off-threading">Would my single-threaded program run faster if I turned off threading?</a></h2>
<p>Can be.  You can see for yourself by compiling lxml entirely without threading
support.  Pass the <tt class="docutils literal"><span class="pre">--without-threading</span></tt> option to setup.py when building
lxml from source.</p>
</div>
</div>
<div class="section">
<h1><a id="parsing-and-serialisation" name="parsing-and-serialisation">Parsing and Serialisation</a></h1>
<div class="section">
<h2><a id="why-doesn-t-the-pretty-print-option-reformat-my-xml-output" name="why-doesn-t-the-pretty-print-option-reformat-my-xml-output">Why doesn't the <tt class="docutils literal"><span class="pre">pretty_print</span></tt> option reformat my XML output?</a></h2>
<p>Pretty printing (or formatting) an XML document means adding white space to
the content.  These modifications are harmless if they only impact elements in
the document that do not carry (text) data.  They corrupt your data if they
impact elements that contain data.  If lxml cannot distinguish between
whitespace and data, it will not alter your data.  Whitespace is therefore
only added between nodes that do not contain data.  This is always the case
for trees constructed element-by-element, so no problems should be expected
here.  For parsed trees, a good way to assure that no conflicting whitespace
is left in the tree is the <tt class="docutils literal"><span class="pre">remove_blank_text</span></tt> option:</p>
<pre class="literal-block">
&gt;&gt;&gt; parser = etree.XMLParser(remove_blank_text=True)
&gt;&gt;&gt; tree = etree.parse(file, parser)
</pre>
<p>This will allow the parser to drop blank text nodes when constructing the
tree.  If you now call a serialization function to pretty print this tree,
lxml can add fresh whitespace to the XML tree to indent it.</p>
</div>
<div class="section">
<h2><a id="why-can-t-lxml-parse-my-xml-from-unicode-strings" name="why-can-t-lxml-parse-my-xml-from-unicode-strings">Why can't lxml parse my XML from unicode strings?</a></h2>
<p>lxml can read Python unicode strings and even tries to support them if libxml2
does not.  However, if the unicode string declares an XML encoding internally
(<tt class="docutils literal"><span class="pre">&lt;?xml</span> <span class="pre">encoding="..."?&gt;</span></tt>), parsing is bound to fail, as this encoding is
most likely not the real encoding used in Python unicode.  The same is true
for HTML unicode strings that contain charset meta tags, although the problems
may be more subtle here.  The libxml2 HTML parser may not be able to parse the
meta tags in broken HTML and may end up ignoring them, so even if parsing
succeeds, later handling may still fail with character encoding errors.</p>
<p>Note that Python uses different encodings for unicode on different platforms,
so even specifying the real internal unicode encoding is not portable between
Python interpreters.  Don't do it.</p>
<p>Python unicode strings with XML data or HTML data that carry encoding
information are broken.  lxml will not parse them.  You must provide parsable
data in a valid encoding.</p>
</div>
<div class="section">
<h2><a id="what-is-the-difference-between-str-xslt-doc-and-xslt-doc-write" name="what-is-the-difference-between-str-xslt-doc-and-xslt-doc-write">What is the difference between str(xslt(doc)) and xslt(doc).write() ?</a></h2>
<p>The str() implementation of the XSLTResultTree class (a subclass of the
ElementTree class) knows about the output method chosen in the stylesheet
(xsl:output), write() doesn't.  If you call write(), the result will be a
normal XML tree serialization in the requested encoding.  Calling this method
may also fail for XSLT results that are not XML trees (e.g. string results).</p>
<p>If you call str(), it will return the serialized result as specified by the
XSL transform.  This correctly serializes string results to encoded Python
strings and honours <tt class="docutils literal"><span class="pre">xsl:output</span></tt> options like <tt class="docutils literal"><span class="pre">indent</span></tt>.  This almost
certainly does what you want, so you should only use <tt class="docutils literal"><span class="pre">write()</span></tt> if you are
sure that the XSLT result is an XML tree and you want to override the encoding
and indentation options requested by the stylesheet.</p>
</div>
<div class="section">
<h2><a id="why-can-t-i-just-delete-parents-or-clear-the-root-node-in-iterparse" name="why-can-t-i-just-delete-parents-or-clear-the-root-node-in-iterparse">Why can't I just delete parents or clear the root node in iterparse()?</a></h2>
<p>The <tt class="docutils literal"><span class="pre">iterparse()</span></tt> implementation is based on the libxml2 parser.  It
requires the tree to be intact to finish parsing.  If you delete or modify
parents of the current node, chances are you modify the structure in a way
that breaks the parser.  Normally, this will result in a segfault.  Please
refer to the <a class="reference" href="api.html#iterparse-and-iterwalk">iterparse section</a> of the lxml API documentation to find out
what you can do and what you can't do.</p>
</div>
</div>
<div class="section">
<h1><a id="xpath-and-document-traversal" name="xpath-and-document-traversal">XPath and Document Traversal</a></h1>
<div class="section">
<h2><a id="what-are-the-findall-and-xpath-methods-on-element-tree" name="what-are-the-findall-and-xpath-methods-on-element-tree">What are the <tt class="docutils literal"><span class="pre">findall()</span></tt> and <tt class="docutils literal"><span class="pre">xpath()</span></tt> methods on Element(Tree)?</a></h2>
<p><tt class="docutils literal"><span class="pre">findall()</span></tt> is part of the original <a class="reference" href="http://effbot.org/zone/element-index.htm">ElementTree API</a>.  It supports a
<a class="reference" href="http://effbot.org/zone/element-xpath.htm">simple subset of the XPath language</a>, without predicates, conditions and
other advanced features.  It is very handy for finding specific tags in a
tree.  Another important difference is namespace handling, which uses the
<tt class="docutils literal"><span class="pre">{namespace}tagname</span></tt> notation.  This is not supported by XPath.  The
findall, find and findtext methods are compatible with other ElementTree
implementations and allow writing portable code that runs on ElementTree,
cElementTree and lxml.etree.</p>
<p><tt class="docutils literal"><span class="pre">xpath()</span></tt>, on the other hand, supports the complete power of the XPath
language, including predicates, XPath functions and Python extension
functions.  The syntax is defined by the <a class="reference" href="http://www.w3.org/TR/xpath">XPath specification</a>.  If you need
the expressiveness and selectivity of XPath, the <tt class="docutils literal"><span class="pre">xpath()</span></tt> method, the
<tt class="docutils literal"><span class="pre">XPath</span></tt> class and the <tt class="docutils literal"><span class="pre">XPathEvaluator</span></tt> are the best <a class="reference" href="performance.html#xpath">choice</a>.</p>
</div>
<div class="section">
<h2><a id="why-doesn-t-findall-support-full-xpath-expressions" name="why-doesn-t-findall-support-full-xpath-expressions">Why doesn't <tt class="docutils literal"><span class="pre">findall()</span></tt> support full XPath expressions?</a></h2>
<p>It was decided that it is more important to keep compatibility with
<a class="reference" href="http://effbot.org/zone/element-index.htm">ElementTree</a> to simplify code migration between the libraries.  The main
difference compared to XPath is the <tt class="docutils literal"><span class="pre">{namespace}tagname</span></tt> notation used in
<tt class="docutils literal"><span class="pre">findall()</span></tt>, which is not valid XPath.</p>
<p>ElementTree and lxml.etree use the same implementation, which assures 100%
compatibility.  Note that <tt class="docutils literal"><span class="pre">findall()</span></tt> is <a class="reference" href="performance.html#tree-traversal">so fast</a> in lxml that a native
implementation would not bring any performance benefits.</p>
</div>
<div class="section">
<h2><a id="how-can-i-find-out-which-namespace-prefixes-are-used-in-a-document" name="how-can-i-find-out-which-namespace-prefixes-are-used-in-a-document">How can I find out which namespace prefixes are used in a document?</a></h2>
<p>You can traverse the document (<tt class="docutils literal"><span class="pre">getiterator()</span></tt>) and collect the prefix
attributes from all Elements into a set.  However, it is unlikely that you
really want to do that.  You do not need these prefixes, honestly.  You only
need the namespace URIs.  All namespace comparisons use these, so feel free to
make up your own prefixes when you use XPath expressions or extension
functions.</p>
<p>The only place where you might consider specifying prefixes is the
serialization of Elements that were created through the API.  Here, you can
specify a prefix mapping through the <tt class="docutils literal"><span class="pre">nsmap</span></tt> argument when creating the root
Element.  Its children will then inherit this prefix for serialization.</p>
</div>
<div class="section">
<h2><a id="how-can-i-specify-a-default-namespace-for-xpath-expressions" name="how-can-i-specify-a-default-namespace-for-xpath-expressions">How can I specify a default namespace for XPath expressions?</a></h2>
<p>You can't.  In XPath, there is no such thing as a default namespace.  Just use
an arbitrary prefix and let the namespace dictionary of the XPath evaluators
map it to your namespace.  See also the question above.</p>
</div>
</div>
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions</a><ul class="submenu current"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#bad-things-first">Bad things first</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#tree-traversal">Tree traversal</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#xinclude">xinclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#creating-objectify-trees">Creating objectify trees</a></li><li class="menu item"><a href="objectify.html#element-access-through-object-attributes">Element access through object attributes</a></li><li class="menu item"><a href="objectify.html#namespace-handling">Namespace handling</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#defining-additional-data-classes">Defining additional data classes</a></li><li class="menu item"><a href="objectify.html#recursive-string-representation-of-elements">Recursive string representation of elements</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-elementtree?">What is different from ElementTree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#document-loaders-in-context">Document loaders in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div></div>
</body>
</html>