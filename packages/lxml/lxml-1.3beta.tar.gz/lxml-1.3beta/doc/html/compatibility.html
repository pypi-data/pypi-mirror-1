<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>lxml.etree versus ElementTree</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="lxml-etree-versus-elementtree">
<h1 class="title">lxml.etree versus ElementTree</h1>
<p>A lot of care has been taken to ensure compatibility between etree and
ElementTree.  Nonetheless some differences and incompatibilities exist:</p>
<ul>
<li><p class="first">Importing etree is obviously different; etree uses a lower case
package name, while ElementTree a combination of upper-case and
lower case in imports:</p>
<pre class="literal-block">
# etree
from lxml.etree import Element

# ElementTree
from elementtree.ElementTree import Element

# ElementTree in the Python 2.5 standard library
from xml.etree.ElementTree import Element
</pre>
<p>When switching over code from ElementTree to lxml.etree, and you're using
the package name prefix 'ElementTree', you can do the following:</p>
<pre class="literal-block">
# instead of
from elementtree import ElementTree
# use
from lxml import etree as ElementTree
</pre>
</li>
<li><p class="first">Some minor parts of the API of ElementTree have not yet been implemented and
are thus missing in lxml.etree.  Feel free to help out!</p>
</li>
<li><p class="first">Then again, lxml.etree offers a lot more functionality, such as
XPath, XSLT, Relax NG, and XML Schema support, which (c)ElementTree
does not offer.</p>
</li>
<li><p class="first">etree has a different idea about Python unicode strings than ElementTree.
In most parts of the API, ElementTree uses plain strings and unicode strings
as what they are.  This includes Element.text, Element.tail and many other
places.  However, the ElementTree parsers assume by default that any string
(<cite>str</cite> or <cite>unicode</cite>) contains ASCII data.  They raise an exception if
strings do not match the expected encoding.</p>
<p>etree has the same idea about plain strings (<cite>str</cite>) as ElementTree.  For
unicode strings, however, etree assumes throughout the API that they are
Python unicode encoded strings rather than byte data.  This includes the
parsers.  It is therefore perfectly correct to pass XML unicode data into
the etree parsers in form of Python unicode strings.  It is an error, on the
other hand, if unicode strings specify an encoding in their XML declaration,
as this conflicts with the characteristic encoding of Python unicode
strings.</p>
</li>
<li><p class="first">ElementTree allows you to place an Element in two different trees at the
same time.  Thus, this:</p>
<pre class="literal-block">
a = Element('a')
b = SubElement(a, 'b')
c = Element('c')
c.append(b)
</pre>
<p>will result in the following tree a:</p>
<pre class="literal-block">
&lt;a&gt;&lt;b /&gt;&lt;/a&gt;
</pre>
<p>and the following tree c:</p>
<pre class="literal-block">
&lt;c&gt;&lt;b /&gt;&lt;/c&gt;
</pre>
<p>In lxml, this behavior is different, because lxml is built on top of a tree
that maintains parent relationships for elements (like W3C DOM).  This means
an element can only exist in a single tree at the same time.  Adding an
element in some tree to another tree will cause this element to be moved.</p>
<p>So, for tree a we will get:</p>
<pre class="literal-block">
&lt;a&gt;&lt;/a&gt;
</pre>
<p>and for tree c we will get:</p>
<pre class="literal-block">
&lt;c&gt;&lt;b/&gt;&lt;/c&gt;
</pre>
<p>Unfortunately this is a rather fundamental difference in behavior, which
will be hard to solve.  It won't affect some applications, but if you want
to port code you must unfortunately make sure that it doesn't.</p>
</li>
<li><p class="first">When trying to set a subelement using __setitem__ that is in fact not an
Element but some other object, etree raises a TypeError, and ElementTree
raises an AssertionError.  This also applies to some other places of the
API. In general, etree tries to avoid AssertionErrors in favour of being
more specific about the reason for the exception.</p>
</li>
<li><p class="first">When parsing fails in <tt class="docutils literal"><span class="pre">iterparse()</span></tt>, ElementTree raises an ExpatError
instead of a SyntaxError.  lxml.etree follows the other parts of the parser
API and raises an (XML)SyntaxError.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">iterparse()</span></tt> function in lxml is implemented based on the libxml2
parser.  This means that modifications of the document root or the ancestors
of the current element during parsing can irritate the parser and even
segfault.  While this is not a problem in the Python object structure used
by ElementTree, the C tree underlying lxml suffers from it.  The golden rule
for <tt class="docutils literal"><span class="pre">iterparse()</span></tt> on lxml therefore is: do not touch anything that will
have to be touched again by the parser later on.  See the lxml API
documentation on this.</p>
</li>
<li><p class="first">ElementTree ignores comments and processing instructions when parsing XML,
while etree will read them in and treat them as Comment or
ProcessingInstruction elements respectively.</p>
</li>
<li><p class="first">ElementTree has a bug when serializing an empty Comment (no text argument
given) to XML, etree serializes this successfully.</p>
</li>
<li><p class="first">ElementTree adds whitespace around comments on serialization, lxml does
not.  This means that a comment text "text" that ElementTree serializes as
"&lt;!-- text --&gt;" will become "&lt;!--text--&gt;" in lxml.</p>
</li>
<li><p class="first">ElementTree merges the target of a processing instruction into <tt class="docutils literal"><span class="pre">PI.text</span></tt>,
while lxml.etree puts it into the <tt class="docutils literal"><span class="pre">.target</span></tt> property and leaves it out of
the <tt class="docutils literal"><span class="pre">.text</span></tt> property.</p>
</li>
<li><p class="first">Because etree is built on top of libxml2, which is namespace prefix aware,
etree preserves namespaces declarations and prefixes while ElementTree tends
to come up with its own prefixes (ns0, ns1, etc).  When no namespace prefix
is given however, etree creates ElementTree style prefixes as well.</p>
</li>
<li><p class="first">etree has a 'prefix' attribute (read-only) on elements giving the Element's
prefix, if this is known, and None otherwise (in case of no namespace at
all, or default namespace).</p>
<p>etree further allows passing an 'nsmap' dictionary to the Element and
SubElement element factories to explicitly map namespace prefixes to
namespace URIs.  These will be translated into namespace declarations on
that element.  This means that in the probably rare case that you need to
construct an attribute called 'nsmap', you need to be aware that unlike in
ElementTree, you cannot pass it as a keyword argument to the Element and
SubElement factories directly.</p>
</li>
<li><p class="first">etree elements can be copied using copy.deepcopy() and copy.copy(), just
like ElementTree's.  copy.copy() however does <em>not</em> create a shallow copy
where elements are shared between trees, as this makes no sense in the
context of libxml2 trees.  Note that lxml can deep-copy trees considerably
faster than ElementTree.</p>
</li>
<li><p class="first">etree allows navigation to the parent of a node by the <tt class="docutils literal"><span class="pre">getparent()</span></tt>
method and to the siblings by calling <tt class="docutils literal"><span class="pre">getnext()</span></tt> and <tt class="docutils literal"><span class="pre">getprevious()</span></tt>.
This is not possible in ElementTree as the underlying tree model does not
have this information.</p>
</li>
</ul>
<div class="sidemenu"><ul id="lxml"><li><span class="section title">lxml</span><ul class="menu" id="index"><li class="menu title"><a href="index.html">lxml</a><ul class="submenu"><li class="menu item"><a href="index.html#introduction">Introduction</a></li><li class="menu item"><a href="index.html#download">Download</a></li><li class="menu item"><a href="index.html#documentation">Documentation</a></li><li class="menu item"><a href="index.html#mailing-list">Mailing list</a></li><li class="menu item"><a href="index.html#license">License</a></li><li class="menu item"><a href="index.html#old-versions">Old Versions</a></li></ul></li></ul><ul class="menu" id="intro"><li class="menu title"><a href="intro.html">Why lxml?</a><ul class="submenu"><li class="menu item"><a href="intro.html#motto">Motto</a></li><li class="menu item"><a href="intro.html#aims">Aims</a></li></ul></li></ul><ul class="menu" id="FAQ"><li class="menu title"><a href="FAQ.html">Frequently Asked Questions</a><ul class="submenu"><li class="menu item"><a href="FAQ.html#general-questions">General Questions</a></li><li class="menu item"><a href="FAQ.html#bugs">Bugs</a></li><li class="menu item"><a href="FAQ.html#threading">Threading</a></li><li class="menu item"><a href="FAQ.html#parsing-and-serialisation">Parsing and Serialisation</a></li><li class="menu item"><a href="FAQ.html#xpath-and-document-traversal">XPath and Document Traversal</a></li></ul></li></ul><ul class="menu" id="performance"><li class="menu title"><a href="performance.html">Benchmarks and Speed</a><ul class="submenu"><li class="menu item"><a href="performance.html#bad-things-first">Bad things first</a></li><li class="menu item"><a href="performance.html#parsing-and-serialising">Parsing and Serialising</a></li><li class="menu item"><a href="performance.html#the-elementtree-api">The ElementTree API</a></li><li class="menu item"><a href="performance.html#tree-traversal">Tree traversal</a></li><li class="menu item"><a href="performance.html#xpath">XPath</a></li><li class="menu item"><a href="performance.html#lxml-objectify">lxml.objectify</a></li></ul></li></ul><ul class="menu" id="build"><li class="menu title"><a href="build.html">How to build lxml from source</a><ul class="submenu"><li class="menu item"><a href="build.html#pyrex">Pyrex</a></li><li class="menu item"><a href="build.html#subversion">Subversion</a></li><li class="menu item"><a href="build.html#setuptools">Setuptools</a></li><li class="menu item"><a href="build.html#running-the-tests-and-reporting-errors">Running the tests and reporting errors</a></li><li class="menu item"><a href="build.html#contributing-an-egg">Contributing an egg</a></li><li class="menu item"><a href="build.html#static-linking-on-windows">Static linking on Windows</a></li><li class="menu item"><a href="build.html#building-debian-packages-from-svn-sources">Building Debian packages from SVN sources</a></li></ul></li></ul></li></ul><ul id="Developing with lxml"><li><span class="section title">Developing with lxml</span><ul class="menu" id="api"><li class="menu title"><a href="api.html">APIs specific to lxml</a><ul class="submenu"><li class="menu item"><a href="api.html#lxml-etree">lxml.etree</a></li><li class="menu item"><a href="api.html#other-element-apis">Other Element APIs</a></li><li class="menu item"><a href="api.html#trees-and-documents">Trees and Documents</a></li><li class="menu item"><a href="api.html#iteration">Iteration</a></li><li class="menu item"><a href="api.html#error-handling-on-exceptions">Error handling on exceptions</a></li><li class="menu item"><a href="api.html#xinclude">xinclude</a></li><li class="menu item"><a href="api.html#write-c14n-on-elementtree">write_c14n on ElementTree</a></li></ul></li></ul><ul class="menu" id="parsing"><li class="menu title"><a href="parsing.html">Parsing XML with lxml</a><ul class="submenu"><li class="menu item"><a href="parsing.html#parsers">Parsers</a></li><li class="menu item"><a href="parsing.html#iterparse-and-iterwalk">iterparse and iterwalk</a></li><li class="menu item"><a href="parsing.html#python-unicode-strings">Python unicode strings</a></li></ul></li></ul><ul class="menu" id="validation"><li class="menu title"><a href="validation.html">Validation with lxml</a><ul class="submenu"><li class="menu item"><a href="validation.html#dtd">DTD</a></li><li class="menu item"><a href="validation.html#relaxng">RelaxNG</a></li><li class="menu item"><a href="validation.html#xmlschema">XMLSchema</a></li></ul></li></ul><ul class="menu" id="xpathxslt"><li class="menu title"><a href="xpathxslt.html">XPath and XSLT with lxml</a><ul class="submenu"><li class="menu item"><a href="xpathxslt.html#xpath">XPath</a></li><li class="menu item"><a href="xpathxslt.html#xslt">XSLT</a></li></ul></li></ul><ul class="menu" id="objectify"><li class="menu title"><a href="objectify.html">lxml.objectify</a><ul class="submenu"><li class="menu item"><a href="objectify.html#setting-up-lxml-objectify">Setting up lxml.objectify</a></li><li class="menu item"><a href="objectify.html#creating-objectify-trees">Creating objectify trees</a></li><li class="menu item"><a href="objectify.html#element-access-through-object-attributes">Element access through object attributes</a></li><li class="menu item"><a href="objectify.html#namespace-handling">Namespace handling</a></li><li class="menu item"><a href="objectify.html#objectpath">ObjectPath</a></li><li class="menu item"><a href="objectify.html#python-data-types">Python data types</a></li><li class="menu item"><a href="objectify.html#how-data-types-are-matched">How data types are matched</a></li><li class="menu item"><a href="objectify.html#defining-additional-data-classes">Defining additional data classes</a></li><li class="menu item"><a href="objectify.html#recursive-string-representation-of-elements">Recursive string representation of elements</a></li><li class="menu item"><a href="objectify.html#what-is-different-from-elementtree?">What is different from ElementTree?</a></li></ul></li></ul></li></ul><ul id="Extending lxml"><li><span class="section title">Extending lxml</span><ul class="menu" id="resolvers"><li class="menu title"><a href="resolvers.html">Document loading and URL resolving</a><ul class="submenu"><li class="menu item"><a href="resolvers.html#document-loaders-in-context">Document loaders in context</a></li><li class="menu item"><a href="resolvers.html#i-o-access-control-in-xslt">I/O access control in XSLT</a></li></ul></li></ul><ul class="menu" id="extensions"><li class="menu title"><a href="extensions.html">Extension functions for XPath and XSLT</a><ul class="submenu"><li class="menu item"><a href="extensions.html#the-functionnamespace">The FunctionNamespace</a></li><li class="menu item"><a href="extensions.html#global-prefix-assignment">Global prefix assignment</a></li><li class="menu item"><a href="extensions.html#evaluators-and-xslt">Evaluators and XSLT</a></li><li class="menu item"><a href="extensions.html#evaluator-local-extensions">Evaluator-local extensions</a></li><li class="menu item"><a href="extensions.html#what-to-return-from-a-function">What to return from a function</a></li></ul></li></ul><ul class="menu" id="element_classes"><li class="menu title"><a href="element_classes.html">Using custom Element classes in lxml</a><ul class="submenu"><li class="menu item"><a href="element_classes.html#element-initialization">Element initialization</a></li><li class="menu item"><a href="element_classes.html#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a></li><li class="menu item"><a href="element_classes.html#implementing-namespaces">Implementing namespaces</a></li></ul></li></ul><ul class="menu" id="sax"><li class="menu title"><a href="sax.html">Sax support</a><ul class="submenu"><li class="menu item"><a href="sax.html#building-a-tree-from-sax-events">Building a tree from SAX events</a></li><li class="menu item"><a href="sax.html#producing-sax-events-from-an-elementtree-or-element">Producing SAX events from an ElementTree or Element</a></li><li class="menu item"><a href="sax.html#interfacing-with-pulldom-minidom">Interfacing with pulldom/minidom</a></li></ul></li></ul><ul class="menu" id="capi"><li class="menu title"><a href="capi.html">The public C-API of lxml.etree</a><ul class="submenu"><li class="menu item"><a href="capi.html#writing-external-modules-in-pyrex">Writing external modules in Pyrex</a></li><li class="menu item"><a href="capi.html#writing-external-modules-in-c">Writing external modules in C</a></li></ul></li></ul></li></ul></div></div>
</body>
</html>