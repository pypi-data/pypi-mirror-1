========================
XPath and XSLT with lxml
========================

lxml supports both XPath and XSLT through libxml2 and libxslt in a standards
compliant way.

.. contents::
..
   1  XPath
     1.1  The ``xpath()`` method
     1.2  XPath return values
     1.3  Generating XPath expressions
     1.4  The ``XPath`` class
     1.5  The ``XPathEvaluator`` classes
     1.6  ``ETXPath``
   2  XSLT
     2.1  XSLT result objects
     2.2  Stylesheet parameters
     2.3  The ``xslt()`` tree method
     2.4  Profiling


The usual setup procedure::

  >>> from lxml import etree
  >>> from StringIO import StringIO


XPath
=====

lxml.etree supports the simple path syntax of the `find, findall and
findtext`_ methods on ElementTree and Element, as known from the original
ElementTree library (ElementPath_).  As an lxml specific extension, these
classes also provide an ``xpath()`` method that supports expressions in the
complete XPath syntax, as well as `custom extension functions`_.

.. _ElementPath: http://effbot.org/zone/element-xpath.htm
.. _`find,  findall and findtext`: http://effbot.org/zone/element.htm#searching-for-subelements
.. _`custom extension functions`: extensions.html

There are also specialized XPath evaluator classes that are more efficient for
frequent evaluation: ``XPath`` and ``XPathEvaluator``.  See the `performance
comparison`_ to learn when to use which.  Their semantics when used on
Elements and ElementTrees are the same as for the ``xpath()`` method described
here.

.. _`performance comparison`: performance.html#xpath


The ``xpath()`` method
----------------------

For ElementTree, the xpath method performs a global XPath query against the
document (if absolute) or against the root node (if relative)::

  >>> f = StringIO('<foo><bar></bar></foo>')
  >>> tree = etree.parse(f)

  >>> r = tree.xpath('/foo/bar')
  >>> len(r)
  1
  >>> r[0].tag
  'bar'

  >>> r = tree.xpath('bar')
  >>> r[0].tag
  'bar'

When ``xpath()`` is used on an Element, the XPath expression is evaluated
against the element (if relative) or against the root tree (if absolute)::

  >>> root = tree.getroot()
  >>> r = root.xpath('bar')
  >>> r[0].tag
  'bar'

  >>> bar = root[0]
  >>> r = bar.xpath('/foo/bar')
  >>> r[0].tag
  'bar'

  >>> tree = bar.getroottree()
  >>> r = tree.xpath('/foo/bar')
  >>> r[0].tag
  'bar'

The ``xpath()`` method has support for XPath variables::

  >>> expr = "//*[local-name() = $name]"

  >>> print root.xpath(expr, name = "foo")[0].tag
  foo

  >>> print root.xpath(expr, name = "bar")[0].tag
  bar

  >>> print root.xpath("$text", text = "Hello World!")
  Hello World!

Optionally, you can provide a ``namespaces`` keyword argument, which should be
a dictionary mapping the namespace prefixes used in the XPath expression to
namespace URIs::

  >>> f = StringIO('''\
  ... <a:foo xmlns:a="http://codespeak.net/ns/test1" 
  ...       xmlns:b="http://codespeak.net/ns/test2">
  ...    <b:bar>Text</b:bar>
  ... </a:foo>
  ... ''')
  >>> doc = etree.parse(f)
  >>> r = doc.xpath('/t:foo/b:bar', {'t': 'http://codespeak.net/ns/test1', 
  ...                                'b': 'http://codespeak.net/ns/test2'})
  >>> len(r)
  1
  >>> r[0].tag
  '{http://codespeak.net/ns/test2}bar'
  >>> r[0].text
  'Text'

There is also an optional ``extensions`` argument which is used to define
`custom extension functions`_ in Python that are local to this evaluation.


XPath return values
-------------------

The return values of XPath evaluations vary, depending on the XPath expression
used:

* True or False, when the XPath expression has a boolean result

* a float, when the XPath expression has a numeric result (integer or float)

* a (unicode) string, when the XPath expression has a string result.

* a list of items, when the XPath expression has a list as result.  The items
  may include elements (also comments and processing instructions), strings
  and tuples.  Text nodes and attributes in the result are returned as strings
  (the text node content or attribute value).  Namespace declarations are
  returned as tuples of strings: ``(prefix, URI)``.


Generating XPath expressions
----------------------------

ElementTree objects have a method ``getpath(element)``, which returns a
structural, absolute XPath expression to find that element::

  >>> a  = etree.Element("a")
  >>> b  = etree.SubElement(a, "b")
  >>> c  = etree.SubElement(a, "c")
  >>> d1 = etree.SubElement(c, "d")
  >>> d2 = etree.SubElement(c, "d")

  >>> tree = etree.ElementTree(c)
  >>> print tree.getpath(d2)
  /c/d[2]
  >>> tree.xpath(tree.getpath(d2)) == [d2]
  True


The ``XPath`` class
-------------------

The ``XPath`` class compiles an XPath expression into a callable function::

  >>> root = etree.XML("<root><a><b/></a><b/></root>")

  >>> find = etree.XPath("//b")
  >>> print find(root)[0].tag
  b

The compilation takes as much time as in the ``xpath()`` method, but it is
done only once per class instantiation.  This makes it especially efficient
for repeated evaluation of the same XPath expression.

Just like the ``xpath()`` method, the ``XPath`` class supports XPath
variables::

  >>> count_elements = etree.XPath("count(//*[local-name() = $name])")

  >>> print count_elements(root, name = "a")
  1.0
  >>> print count_elements(root, name = "b")
  2.0

This supports very efficient evaluation of modified versions of an XPath
expression, as compilation is still only required once.

Prefix-to-namespace mappings can be passed as second parameter::

  >>> root = etree.XML("<root xmlns='NS'><a><b/></a><b/></root>")

  >>> find = etree.XPath("//n:b", {'n':'NS'})
  >>> print find(root)[0].tag
  {NS}b


The ``XPathEvaluator`` classes
------------------------------

lxml.etree provides two other efficient XPath evaluators that work on
ElementTrees or Elements respectively: ``XPathDocumentEvaluator`` and
``XPathElementEvaluator``.  They are automatically selected if you use the
XPathEvaluator helper for instantiation::

  >>> root = etree.XML("<root><a><b/></a><b/></root>")
  >>> xpatheval = etree.XPathEvaluator(root)

  >>> print isinstance(xpatheval, etree.XPathElementEvaluator)
  True

  >>> print xpatheval("//b")[0].tag
  b

This class provides efficient support for evaluating different XPath
expressions on the same Element or ElementTree.


``ETXPath``
-----------

ElementTree supports a language named ElementPath_ in its ``find*()`` methods.
One of the main differences between XPath and ElementPath is that the XPath
language requires an indirection through prefixes for namespace support,
whereas ElementTree uses the Clark notation (``{ns}name``) to avoid prefixes
completely.  The other major difference regards the capabilities of both path
languages.  Where XPath supports various sophisticated ways of restricting the
result set through functions and boolean expressions, ElementPath only
supports pure path traversal without nesting or further conditions.  So, while
the ElementPath syntax is self-contained and therefore easier to write and
handle, XPath is much more powerful and expressive.

lxml.etree bridges this gap through the class ``ETXPath``, which accepts XPath
expressions with namespaces in Clark notation.  It is identical to the
``XPath`` class, except for the namespace notation.  Normally, you would
write::

  >>> root = etree.XML("<root xmlns='ns'><a><b/></a><b/></root>")

  >>> find = etree.XPath("//p:b", {'p' : 'ns'})
  >>> print find(root)[0].tag
  {ns}b

``ETXPath`` allows you to change this to::

  >>> find = etree.ETXPath("//{ns}b")
  >>> print find(root)[0].tag
  {ns}b


XSLT
====

lxml.etree introduces a new class, lxml.etree.XSLT. The class can be
given an ElementTree object to construct an XSLT transformer::

  >>> f = StringIO('''\
  ... <xsl:stylesheet version="1.0"
  ...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  ...     <xsl:template match="/">
  ...         <foo><xsl:value-of select="/a/b/text()" /></foo>
  ...     </xsl:template>
  ... </xsl:stylesheet>''')
  >>> xslt_doc = etree.parse(f)
  >>> transform = etree.XSLT(xslt_doc)

You can then run the transformation on an ElementTree document by simply
calling it, and this results in another ElementTree object::

  >>> f = StringIO('<a><b>Text</b></a>')
  >>> doc = etree.parse(f)
  >>> result_tree = transform(doc)

By default, XSLT supports all extension functions from libxslt and libexslt as
well as Python regular expressions through the `EXSLT regexp functions`_.
Also see the documentation on `custom extension functions`_ and `document
resolvers`_.  There is a separate section on `controlling access`_ to external
documents and resources.

.. _`EXSLT regexp functions`: http://www.exslt.org/regexp/
.. _`document resolvers`: resolvers.html
.. _`controlling access`: resolvers.html#i-o-access-control-in-xslt


XSLT result objects
-------------------

The result of an XSL transformation can be accessed like a normal ElementTree
document::

  >>> f = StringIO('<a><b>Text</b></a>')
  >>> doc = etree.parse(f)
  >>> result = transform(doc)

  >>> result.getroot().text
  'Text'

but, as opposed to normal ElementTree objects, can also be turned into an (XML
or text) string by applying the str() function::

  >>> str(result)
  '<?xml version="1.0"?>\n<foo>Text</foo>\n'

The result is always a plain string, encoded as requested by the
``xsl:output`` element in the stylesheet.  If you want a Python unicode string
instead, you should set this encoding to ``UTF-8`` (unless the `ASCII` default
is sufficient).  This allows you to call the builtin ``unicode()`` function on
the result::

  >>> unicode(result)
  u'<?xml version="1.0"?>\n<foo>Text</foo>\n'

You can use other encodings at the cost of multiple recoding.  Encodings that
are not supported by Python will result in an error::

  >>> xslt_tree = etree.XML('''\
  ... <xsl:stylesheet version="1.0"
  ...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  ...     <xsl:output encoding="UCS4"/>
  ...     <xsl:template match="/">
  ...         <foo><xsl:value-of select="/a/b/text()" /></foo>
  ...     </xsl:template>
  ... </xsl:stylesheet>''')
  >>> transform = etree.XSLT(xslt_tree)

  >>> result = transform(doc)
  >>> unicode(result)
  Traceback (most recent call last):
    [...]
  LookupError: unknown encoding: UCS4


Stylesheet parameters
---------------------

It is possible to pass parameters, in the form of XPath expressions, to the
XSLT template::

  >>> xslt_tree = etree.XML('''\
  ... <xsl:stylesheet version="1.0"
  ...     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  ...     <xsl:template match="/">
  ...         <foo><xsl:value-of select="$a" /></foo>
  ...     </xsl:template>
  ... </xsl:stylesheet>''')
  >>> transform = etree.XSLT(xslt_tree)
  >>> f = StringIO('<a><b>Text</b></a>')
  >>> doc = etree.parse(f)

The parameters are passed as keyword parameters to the transform call. First
let's try passing in a simple string expression::

  >>> result = transform(doc, a="'A'")
  >>> str(result)
  '<?xml version="1.0"?>\n<foo>A</foo>\n'

Let's try a non-string XPath expression now::

  >>> result = transform(doc, a="/a/b/text()")
  >>> str(result)
  '<?xml version="1.0"?>\n<foo>Text</foo>\n'


The ``xslt()`` tree method
--------------------------

There's also a convenience method on ElementTree objects for doing XSL
transformations.  This is less efficient if you want to apply the same XSL
transformation to multiple documents, but is shorter to write for one-shot
operations, as you do not have to instantiate a stylesheet yourself::

  >>> result = doc.xslt(xslt_tree, a="'A'")
  >>> str(result)
  '<?xml version="1.0"?>\n<foo>A</foo>\n'

This is a shortcut for the following code::

  >>> transform = etree.XSLT(xslt_tree)
  >>> result = transform(doc, a="'A'")
  >>> str(result)
  '<?xml version="1.0"?>\n<foo>A</foo>\n'


Profiling
---------

If you want to know how your stylesheet performed, pass the ``profile_run``
keyword to the transform::

  >>> result = transform(doc, a="/a/b/text()", profile_run=True)
  >>> profile = result.xslt_profile

The value of the ``xslt_profile`` property is an ElementTree with profiling
data about each template, similar to the following::

  <profile>
    <template rank="1" match="/" name="" mode="" calls="1" time="1" average="1"/>
  </profile>

Note that this is a read-only document.  You must not move any of its elements
to other documents.  Please deep-copy the document if you need to modify it.
If you want to free it from memory, just do::

  >>> del result.xslt_profile
