<html>
<head>
	<title>
    Database Engines - SQLAlchemy 0.2 Documentation
</title>
</head>
<body>



<link href="style.css" rel="stylesheet" type="text/css"></link>
<link href="syntaxhighlight.css" rel="stylesheet" type="text/css"></link>

<link href="docs.css" rel="stylesheet" type="text/css"></link>
<script src="scripts.js"></script>


<div style="position:absolute;left:0px;top:0px;"><a name="top"></a>&nbsp;</div>

<div class="doccontainer">

<div class="docheader">

<div class="docheadertext" >Database Engines</div>
<div class="">Version: 0.2.5   Last Updated: 07/08/06 13:45:27</div>
</div>



		<A name="dbengine"></a>
		
	
<div class="topnav">


	
	<div class="topnavcontrol">
	View: <b>Paged</b> &nbsp;|&nbsp; <a href="documentation.html">One Page</a>
	</div>



<div class="topnavsectionlink">

<a href="index.html">Table of Contents</a>

<div class="prevnext">
Previous: <a href="tutorial.html">Tutorial</a>

&nbsp; | &nbsp;


Next: <a href="metadata.html">Database Meta Data</a>

</div>
</div>


<div class="topnavmain">
	<div class="topnavheader">Database Engines</div>
	<div class="topnavitems">
	


    
    
    <div class="toclink">
        <A style="" href="#dbengine_supported">Supported Databases</a>
    </div>
    
    <div class="toclinkcontainer">
    </div>


    
    
    <div class="toclink">
        <A style="" href="#dbengine_establishing">Establishing a Database Engine</a>
    </div>
    
    <div class="toclinkcontainer">
    </div>


    
    
    <div class="toclink">
        <A style="" href="#dbengine_options">Database Engine Options</a>
    </div>
    
    <div class="toclinkcontainer">
    </div>


    
    
    <div class="toclink">
        <A style="" href="#dbengine_connections">Using Connections</a>
    </div>
    
    <div class="toclinkcontainer">
        
        
    <div class="toclinkcontainer">
    
    <div class="smalltoclink">
    <A href="#dbengine_connections_context">Implicit Connection Contexts</a>
    </div>

    </div>


    </div>


    
    
    <div class="toclink">
        <A style="" href="#dbengine_transactions">Transactions</a>
    </div>
    
    <div class="toclinkcontainer">
    </div>



	</div>
</div>

</div>

		<div class="sectioncontent">
			




<div class="subsection" style="margin-left:10px;">

    <div class="sectiontext">



<p>A database engine is a subclass of <code>sqlalchemy.sql.Engine</code>, and is the starting point for where SQLAlchemy provides a layer of abstraction on top of the various DBAPI2 database modules.  For all databases supported by SA, there is a specific "implementation" module, found in the <code>sqlalchemy.databases</code> package, that provides all the objects an <code>Engine</code> needs in order to perform its job.  A typical user of SQLAlchemy never needs to deal with these modules directly.  For many purposes, the only knowledge that's needed is how to create an Engine for a particular connection URL.  When dealing with direct execution of SQL statements, one would also be aware of Result, Connection, and Transaction objects.  The primary public facing objects are:
</p>
<ul>
 <li>
      <strong>URL</strong> - represents the identifier for a particular database.  URL objects are usually created automatically based on a given connect string passed to the <code>create_engine()</code> function.
 </li>

 <li>
      <strong>Engine</strong> - Combines a connection-providing resource with implementation-provided objects that know how to generate, execute, and gather information about SQL statements.  It also provides the primary interface by which Connections are obtained, as well as a context for constructed SQL objects and schema constructs to "implicitly execute" themselves, which is an optional feature of SA 0.2.  The Engine object that is normally dealt with is an instance of <code>sqlalchemy.engine.base.ComposedSQLEngine</code>.
 </li>

 <li>
      <strong>Connection</strong> - represents a connection to the database.  The underlying connection object returned by a DBAPI's connect() method is referenced internally by the Connection object.  Connection provides methods that handle the execution of SQLAlchemy's own SQL constructs, as well as literal string-based statements.  <br /> 
 </li>

 <li>
      <strong>Transaction</strong> - represents a transaction on a single Connection.  Includes <code>begin()</code>, <code>commit()</code> and <code>rollback()</code> methods that support basic "nestable" behavior, meaning an outermost transaction is maintained against multiple nested calls to begin/commit.
 </li>

 <li>
      <strong>ResultProxy</strong> - Represents the results of an execution, and is most analgous to the cursor object in DBAPI.  It primarily allows iteration over result sets, but also provides an interface to information about inserts/updates/deletes, such as the count of rows affected, last inserted IDs, etc.
 </li>

 <li>
      <strong>RowProxy</strong> -  Represents a single row returned by the fetchone() method on ResultProxy.
 </li>
</ul>
<p>Underneath the public-facing API of <code>ComposedSQLEngine</code>, several components are provided by database implementations to provide the full behavior, including:
</p>
<ul>
 <li>
      <strong>Dialect</strong> - this object is provided by database implementations to describe the behavior of a particular database.  It acts as a repository for metadata about a database's characteristics, and provides factory methods for other objects that deal with generating SQL strings and objects that handle some of the details of statement execution.  <br /> 
 </li>

 <li>
      <strong>ConnectionProvider</strong> - this object knows how to return a DBAPI connection object.  It typically talks to a connection pool which maintains one or more connections in memory for quick re-use.
 </li>

 <li>
      <strong>ExecutionContext</strong> - this object is created for each execution of a single SQL statement, and tracks information about its execution such as primary keys inserted, the total count of rows affected, etc.  It also may implement any special logic that various DBAPI implementations may require before or after a statement execution.
 </li>

 <li>
      <strong>Compiler</strong> - receives SQL expression objects and assembles them into strings that are suitable for direct execution, as well as collecting bind parameters into a dictionary or list to be sent along with the statement.
 </li>

 <li>
      <strong>SchemaGenerator</strong> - receives collections of Schema objects and knows how to generate the appropriate SQL for <code>CREATE</code> and <code>DROP</code> statements.
 </li>
</ul>


			

			

			

			

			

    </div>

        



<A name="dbengine_supported"></a>

<div class="subsection" style="margin-left:20px;">

    <span class="sectionheadertext">Supported Databases</span>
    <div class="sectiontext">



<p>Engines exist for SQLite, Postgres, MySQL, and Oracle, using the Pysqlite, Psycopg2 (Psycopg1 will work to some degree but its typing model is not supported...install Psycopg2!), MySQLDB, and cx_Oracle modules.  There is also preliminary support for MS-SQL using adodbapi or pymssql, as well as Firebird.   For each engine, a distinct Python module exists in the <code>sqlalchemy.databases</code> package, which provides implementations of some of the objects mentioned in the previous section.
</p>
<p>Downloads for each DBAPI at the time of this writing are as follows:
</p>
<ul>
 <li>
     Postgres:  <a href="http://www.initd.org/tracker/psycopg">psycopg2</a> 
 </li>

 <li>
     SQLite:  <a href="http://initd.org/tracker/pysqlite">pysqlite</a> 
 </li>

 <li>
     MySQL:   <a href="http://sourceforge.net/projects/mysql-python">MySQLDB</a> 
 </li>

 <li>
     Oracle:  <a href="http://www.cxtools.net/default.aspx?nav=home">cx_Oracle</a> 
 </li>

 <li>
     MS-SQL:  <a href="http://adodbapi.sourceforge.net/">adodbapi</a>  <a href="http://pymssql.sourceforge.net/">pymssql</a> 
 </li>

 <li>
     Firebird:  <a href="http://kinterbasdb.sourceforge.net/">kinterbasdb</a> 
 </li>
</ul>
<p>The SQLAlchemy Wiki contains a page of database notes, describing whatever quirks and behaviors have been observed.  Its a good place to check for issues with specific databases.  <a href="http://www.sqlalchemy.org/trac/wiki/DatabaseNotes">Database Notes</a> 
</p>


    </div>


    <a href="#dbengine" class="toclink">back to section top</a>


</div>


        



<A name="dbengine_establishing"></a>

<div class="subsection" style="margin-left:20px;">

    <span class="sectionheadertext">Establishing a Database Engine</span>
    <div class="sectiontext">



<p>SQLAlchemy 0.2 indicates the source of an Engine strictly via <a href="http://rfc.net/rfc1738.html">RFC-1738</a> style URLs, combined with optional keyword arguments to specify options for the Engine.  The form of the URL is:
</p>
<pre><code>$ driver://username:password@host:port/database
</code></pre><p>Available drivernames are <code>sqlite</code>, <code>mysql</code>, <code>postgres</code>, <code>oracle</code>, <code>mssql</code>, and <code>firebird</code>.  For sqlite, the database name is the filename to connect to, or the special name ":memory:" which indicates an in-memory database.  The URL is typically sent as a string to the <code>create_engine()</code> function:
</p>


<div class="sliding_code">
<pre><span class="python_comment"># postgres
</span><span class="python_name">pg_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'postgres://scott:tiger@localhost:5432/mydatabase'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># sqlite (note the four slashes for an absolute path)
</span><span class="python_name">sqlite_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite:////absolute/path/to/database.txt'</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_name">sqlite_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite:///relative/path/to/database.txt'</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_name">sqlite_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite://'</span><span class="python_enclosure">)  </span><span class="python_comment"># in-memory database</span><span class="python_operator">
</span>
<span class="python_comment"># mysql
</span><span class="python_name">mysql_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'mysql://localhost/foo'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># oracle via TNS name
</span><span class="python_name">oracle_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'oracle://scott:tiger@dsn'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># oracle will feed host/port/SID into cx_oracle.makedsn
</span><span class="python_name">oracle_db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'oracle://scott:tiger@127.0.0.1:1521/sidname'</span><span class="python_enclosure">)</span><span class="python_operator"></span></pre></div>
<p>The <code>Engine</code> will create its first connection to the database when a SQL statement is executed.  As concurrent statements are executed, the underlying connection pool will grow to a default size of five connections, and will allow a default "overflow" of ten.   Since the <code>Engine</code> is essentially "home base" for the connection pool, it follows that you should keep a single <code>Engine</code> per database established within an application, rather than creating a new one for each connection.
</p>


    </div>


    <a href="#dbengine" class="toclink">back to section top</a>


</div>


        



<A name="dbengine_options"></a>

<div class="subsection" style="margin-left:20px;">

    <span class="sectionheadertext">Database Engine Options</span>
    <div class="sectiontext">



<p>Keyword options can also be specified to <code>create_engine()</code>, following the string URL as follows:
</p>


<div class="sliding_code">
<pre><span class="python_name">db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'postgres://...'</span><span class="python_operator">, </span><span class="python_name">encoding</span><span class="python_operator">=</span><span class="python_literal">'latin1'</span><span class="python_operator">, </span><span class="python_name">echo</span><span class="python_operator">=</span><span class="python_name">True</span><span class="python_operator">, </span><span class="python_name">module</span><span class="python_operator">=</span><span class="python_name">psycopg1</span><span class="python_enclosure">)</span><span class="python_operator"></span></pre></div>
<p>Options that can be specified include the following:
</p>
<ul>
 <li>
     strategy='plain' : the Strategy describes the general configuration used to create this Engine.  The two available values are <code>plain</code>, which is the default, and <code>threadlocal</code>, which applies a "thread-local context" to implicit executions performed by the Engine.  This context is further described in <a href="dbengine.html#dbengine_connections_context" >Implicit Connection Contexts</a>.
 </li>

 <li>
     pool=None : an instance of <code>sqlalchemy.pool.Pool</code> to be used as the underlying source for connections, overriding the engine's connect arguments (pooling is described in <a href="pooling.html#pooling" >Connection Pooling</a>).  If None, a default <code>Pool</code> (usually <code>QueuePool</code>, or <code>SingletonThreadPool</code> in the case of SQLite) will be created using the engine's connect arguments.
 </li>
</ul>
<p>Example:
</p>


<div class="sliding_code">
<pre><span class="python_keyword">from </span><span class="python_name">sqlalchemy </span><span class="python_keyword">import </span><span class="python_operator">*
</span><span class="python_keyword">import </span><span class="python_name">sqlalchemy</span><span class="python_operator">.</span><span class="python_name">pool as pool</span><span class="python_operator">
</span><span class="python_keyword">import </span><span class="python_name">MySQLdb</span><span class="python_operator">
</span>
<span class="python_keyword">def </span><span class="python_name">getconn</span><span class="python_enclosure">()</span><span class="python_operator">:
    </span><span class="python_keyword">return </span><span class="python_name">MySQLdb</span><span class="python_operator">.</span><span class="python_name">connect</span><span class="python_enclosure">(</span><span class="python_name">user</span><span class="python_operator">=</span><span class="python_literal">'ed'</span><span class="python_operator">, </span><span class="python_name">dbname</span><span class="python_operator">=</span><span class="python_literal">'mydb'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_operator"></span><span class="python_name">engine </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'mysql'</span><span class="python_operator">, </span><span class="python_name">pool</span><span class="python_operator">=</span><span class="python_name">pool</span><span class="python_operator">.</span><span class="python_name">QueuePool</span><span class="python_enclosure">(</span><span class="python_name">getconn</span><span class="python_operator">, </span><span class="python_name">pool_size</span><span class="python_operator">=</span><span class="python_number">20</span><span class="python_operator">, </span><span class="python_name">max_overflow</span><span class="python_operator">=</span><span class="python_number">40</span><span class="python_enclosure">))</span><span class="python_operator"></span></pre></div>
<ul>
 <li>
     pool_size=5 : the number of connections to keep open inside the connection pool.  This is only used with <code>QueuePool</code>.
 </li>

 <li>
     max_overflow=10 : the number of connections to allow in "overflow", that is connections that can be opened above and beyond the initial five.  this is only used with <code>QueuePool</code>.
 </li>

 <li>
     pool_timeout=30 : number of seconds to wait before giving up on getting a connection from the pool.  This is only used with <code>QueuePool</code>.
 </li>

 <li>
     echo=False : if True, the Engine will log all statements as well as a repr() of their parameter lists to the engines logger, which defaults to sys.stdout.  The <code>echo</code> attribute of <code>ComposedSQLEngine</code> can be modified at any time to turn logging on and off.  If set to the string <code>"debug"</code>, result rows will be printed to the standard output as well.
 </li>

 <li>
     logger=None : a file-like object where logging output can be sent, if echo is set to True.  Newlines will not be sent with log messages.  This defaults to an internal logging object which references <code>sys.stdout</code>.
 </li>

 <li>
     module=None : used by database implementations which support multiple DBAPI modules, this is a reference to a DBAPI2 module to be used instead of the engine's default module.  For Postgres, the default is psycopg2, or psycopg1 if 2 cannot be found.  For Oracle, its cx_Oracle.
 </li>

 <li>
     use_ansi=True : used only by Oracle;  when False, the Oracle driver attempts to support a particular "quirk" of Oracle versions 8 and previous, that the LEFT OUTER JOIN SQL syntax is not supported, and the "Oracle join" syntax of using <code>&amp;lt;column1&amp;gt;(+)=&amp;lt;column2&amp;gt;</code> must be used in order to achieve a LEFT OUTER JOIN.  <br /> 
 </li>

 <li>
     threaded=True : used by cx_Oracle; sets the <code>threaded</code> parameter of the connection indicating thread-safe usage.  cx_Oracle docs indicate setting this flag to <code>False</code> will speed performance by 10-15%.  While this defaults to <code>False</code> in cx_Oracle, SQLAlchemy defaults it to <code>True</code>, preferring stability over early optimization.
 </li>

 <li>
     use_oids=False : used only by Postgres, will enable the column name "oid" as the object ID column, which is also used for the default sort order of tables.  Postgres as of 8.1 has object IDs disabled by default.
 </li>

 <li>
     convert_unicode=False : if set to True, all String/character based types will convert Unicode values to raw byte values going into the database, and all raw byte values to Python Unicode coming out in result sets.  This is an engine-wide method to provide unicode across the board.  For unicode conversion on a column-by-column level, use the <code>Unicode</code> column type instead.
 </li>

 <li>
     encoding='utf-8' : the encoding to use for all Unicode translations, both by engine-wide unicode conversion as well as the <code>Unicode</code> type object.
 </li>
</ul>


    </div>


    <a href="#dbengine" class="toclink">back to section top</a>


</div>


        



<A name="dbengine_connections"></a>

<div class="subsection" style="margin-left:20px;">

    <span class="sectionheadertext">Using Connections</span>
    <div class="sectiontext">



<p>In this section we describe the SQL execution interface available from an <code>Engine</code> instance.  Note that when using the Object Relational Mapper (ORM) as well as when dealing with with "bound" metadata objects (described later), SQLAlchemy deals with the Engine for you and you generally don't need to know much about it; in those cases, you can skip this section and go to <a href="metadata.html#metadata" >Database Meta Data</a>.
</p>
<p>The Engine provides a <code>connect()</code> method which returns a <code>Connection</code> object.  This object provides methods by which literal SQL text as well as SQL clause constructs can be compiled and executed.  <br /> 
</p>


<div class="sliding_code">
<pre><span class="python_name">engine </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite:///:memory:'</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_name">connection </span><span class="python_operator">= </span><span class="python_name">engine</span><span class="python_operator">.</span><span class="python_name">connect</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_name">result </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from mytable where col1=:col1"</span><span class="python_operator">, </span><span class="python_name">col1</span><span class="python_operator">=</span><span class="python_number">5</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">result</span><span class="python_operator">:
    </span><span class="python_keyword">print </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col1'</span><span class="python_enclosure">]</span><span class="python_operator">, </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col2'</span><span class="python_enclosure">]</span><span class="python_operator">
</span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator"></span></pre></div>
<p>The <code>close</code> method on <code>Connection</code> does not actually remove the underlying connection to the database, but rather indicates that the underlying resources can be returned to the connection pool.  When using the <code>connect()</code> method, the DBAPI connection referenced by the <code>Connection</code> object is not referenced anywhere else. 
</p>
<p>In both execution styles above, the <code>Connection</code> object will also automatically return its resources to the connection pool when the object is garbage collected, i.e. its <code>__del__()</code> method is called.  When using the standard C implementation of Python, this method is usually called immediately as soon as the object is dereferenced.  With other Python implementations such as Jython, this is not so guaranteed.  <br /> 
</p>
<p>The execute method on <code>Engine</code> and <code>Connection</code> can also receive SQL clause constructs as well, which are described in <a href="sqlconstruction.html#sql" >Constructing SQL Queries via Python Expressions</a>:
</p>


<div class="sliding_code">
<pre><span class="python_name">connection </span><span class="python_operator">= </span><span class="python_name">engine</span><span class="python_operator">.</span><span class="python_name">connect</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_name">result </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_name">select</span><span class="python_enclosure">([</span><span class="python_name">table1</span><span class="python_enclosure">]</span><span class="python_operator">, </span><span class="python_name">table1</span><span class="python_operator">.</span><span class="python_name">c</span><span class="python_operator">.</span><span class="python_name">col1</span><span class="python_operator">==</span><span class="python_number">5</span><span class="python_enclosure">))</span><span class="python_operator">
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">result</span><span class="python_operator">:
    </span><span class="python_keyword">print </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col1'</span><span class="python_enclosure">]</span><span class="python_operator">, </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col2'</span><span class="python_enclosure">]</span><span class="python_operator">
</span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator"></span></pre></div>
<p>Both <code>Connection</code> and <code>Engine</code> fulfill an interface known as <code>Connectable</code> which specifies common functionality between the two objects, such as getting a <code>Connection</code> and executing queries.  Therefore, most SQLAlchemy functions which take an <code>Engine</code> as a parameter with which to execute SQL will also accept a <code>Connection</code>:
</p>


<div class="sliding_code">
    <div class="codetitle">Specify Engine or Connection</div>
<pre><span class="python_name">engine </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite:///:memory:'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># specify some Table metadata
</span><span class="python_name">metadata </span><span class="python_operator">= </span><span class="python_name">MetaData</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_name">table </span><span class="python_operator">= </span><span class="python_name">Table</span><span class="python_enclosure">(</span><span class="python_literal">'sometable'</span><span class="python_operator">, </span><span class="python_name">metadata</span><span class="python_operator">, </span><span class="python_name">Column</span><span class="python_enclosure">(</span><span class="python_literal">'col1'</span><span class="python_operator">, </span><span class="python_name">Integer</span><span class="python_enclosure">))</span><span class="python_operator">
</span>
<span class="python_comment"># create the table with the Engine
</span><span class="python_name">table</span><span class="python_operator">.</span><span class="python_name">create</span><span class="python_enclosure">(</span><span class="python_name">engine</span><span class="python_operator">=</span><span class="python_name">engine</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># drop the table with a Connection off the Engine
</span><span class="python_name">connection </span><span class="python_operator">= </span><span class="python_name">engine</span><span class="python_operator">.</span><span class="python_name">connect</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_name">table</span><span class="python_operator">.</span><span class="python_name">drop</span><span class="python_enclosure">(</span><span class="python_name">engine</span><span class="python_operator">=</span><span class="python_name">connection</span><span class="python_enclosure">)</span><span class="python_operator"></span></pre></div>


			

    </div>

        



<A name="dbengine_connections_context"></a>

<div class="subsection" style="margin-left:30px;">

    <span class="sectionheadertext">Implicit Connection Contexts</span>
    <div class="sectiontext">



<p>An <strong>implicit connection</strong> refers to connections that are allocated by the <code>Engine</code> internally.  There are two general cases when this occurs:  when using the various <code>execute()</code> methods that are available off the <code>Engine</code> object itself, and when calling the <code>execute()</code> method on constructed SQL objects, which are described in <b>None</b>.
</p>


<div class="sliding_code">
    <div class="codetitle">Implicit Connection</div>
<pre><span class="python_name">engine </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'sqlite:///:memory:'</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_name">result </span><span class="python_operator">= </span><span class="python_name">engine</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from mytable where col1=:col1"</span><span class="python_operator">, </span><span class="python_name">col1</span><span class="python_operator">=</span><span class="python_number">5</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">result</span><span class="python_operator">:
    </span><span class="python_keyword">print </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col1'</span><span class="python_enclosure">]</span><span class="python_operator">, </span><span class="python_name">row</span><span class="python_enclosure">[</span><span class="python_literal">'col2'</span><span class="python_enclosure">]</span><span class="python_operator">
</span><span class="python_name">result</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator"></span></pre></div>
<p>When using implicit connections, the returned <code>ResultProxy</code> has a <code>close()</code> method which will return the resources used by the underlying <code>Connection</code>.   <br /> 
</p>
<p>The <code>strategy</code> keyword argument to <code>create_engine()</code> affects the algorithm used to retreive the underlying DBAPI connection used by implicit executions.  When set to <code>plain</code>, each implicit execution requests a unique connection from the connection pool, which is returned to the pool when the resulting <code>ResultProxy</code> falls out of scope (i.e. <code>__del__()</code> is called) or its <code>close()</code> method is called.  If a second implicit execution occurs while the <code>ResultProxy</code> from the previous execution is still open, then a second connection is pulled from the pool.
</p>
<p>When <code>strategy</code> is set to <code>threadlocal</code>, the <code>Engine</code> still checks out a connection which is closeable in the same manner via the <code>ResultProxy</code>, except the connection it checks out will be the <strong>same</strong> connection as one which is already checked out, assuming the operation is in the same thread.  When all <code>ResultProxy</code> objects are closed, the connection is returned to the pool normally.
</p>
<p>It is crucial to note that the <code>plain</code> and <code>threadlocal</code> contexts <strong>do not impact the connect() method on the Engine.</strong>  <code>connect()</code> always returns a unique connection.  Implicit connections use a different method off of <code>Engine</code> for their operations called <code>contextual_connect()</code>.
</p>
<p>The <code>plain</code> strategy is better suited to an application that insures the explicit releasing of the resources used by each execution.  This is because each execution uses its own distinct connection resource, and as those resources remain open, multiple connections can be checked out from the pool quickly.  Since the connection pool will block further requests when too many connections have been checked out, not keeping track of this can impact an application's stability.
</p>


<div class="sliding_code">
    <div class="codetitle">Plain Strategy</div>
<pre><span class="python_name">db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'mysql://localhost/test'</span><span class="python_operator">, </span><span class="python_name">strategy</span><span class="python_operator">=</span><span class="python_literal">'plain'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># execute one statement and receive results.  r1 now references a DBAPI connection resource.
</span><span class="python_name">r1 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from table1"</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># execute a second statement and receive results.  r2 now references a *second* DBAPI connection resource.
</span><span class="python_name">r2 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from table2"</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">r1</span><span class="python_operator">:
    ...
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">r2</span><span class="python_operator">:
    ...
</span><span class="python_comment"># release connection 1
</span><span class="python_operator"></span><span class="python_name">r1</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator">
</span>
<span class="python_comment"># release connection 2
</span><span class="python_name">r2</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator"></span></pre></div>
<p>Advantages to <code>plain</code> include that connection resources are immediately returned to the connection pool, without any reliance upon the <code>__del__()</code> method; there is no chance of resources being left around by a Python implementation that doesn't necessarily call <code>__del__()</code> immediately. 
</p>
<p>The <code>threadlocal</code> strategy is better suited to a programming style which relies upon the <code>__del__()</code> method of Connection objects in order to return them to the connection pool, rather than explicitly issuing a <code>close()</code> statement upon the <code>ResultProxy</code> object.   This is because all of the executions within a single thread will share the same connection, if one has already been checked out in the current thread.  Using this style, an application will use only one connection per thread at most within the scope of all implicit executions.
</p>


<div class="sliding_code">
    <div class="codetitle">Threadlocal Strategy</div>
<pre><span class="python_name">db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'mysql://localhost/test'</span><span class="python_operator">, </span><span class="python_name">strategy</span><span class="python_operator">=</span><span class="python_literal">'threadlocal'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># execute one statement and receive results.  r1 now references a DBAPI connection resource.
</span><span class="python_name">r1 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from table1"</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_comment"># execute a second statement and receive results.  r2 now references the *same* resource as r1
</span><span class="python_name">r2 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"select * from table2"</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">r1</span><span class="python_operator">:
    ...
</span><span class="python_keyword">for </span><span class="python_name">row </span><span class="python_keyword">in </span><span class="python_name">r2</span><span class="python_operator">:
    ...
</span><span class="python_comment"># dereference r1.  the connection is still held by r2.
</span><span class="python_operator"></span><span class="python_name">r1 </span><span class="python_operator">= </span><span class="python_name">None</span><span class="python_operator">
</span>
<span class="python_comment"># dereference r2.  with no more references to the underlying connection resources, they
# are returned to the pool.
</span><span class="python_name">r2 </span><span class="python_operator">= </span><span class="python_name">None</span><span class="python_operator"></span></pre></div>
<p>Advantages to <code>threadlocal</code> include that resources can be left to clean up after themselves, application code can be more minimal, its guaranteed that only one connection is used per thread, and there is no chance of a "connection pool block", which is when an execution hangs because the current thread has already checked out all remaining resources.
</p>
<p>To get at the actual <code>Connection</code> object which is used by implicit executions, call the <code>contextual_connection()</code> method on <code>Engine</code>:
</p>


<div class="sliding_code">
    <div class="codetitle">Contextual Connection</div>
<pre><span class="python_comment"># threadlocal strategy
</span><span class="python_name">db </span><span class="python_operator">= </span><span class="python_name">create_engine</span><span class="python_enclosure">(</span><span class="python_literal">'mysql://localhost/test'</span><span class="python_operator">, </span><span class="python_name">strategy</span><span class="python_operator">=</span><span class="python_literal">'threadlocal'</span><span class="python_enclosure">)</span><span class="python_operator">
</span>
<span class="python_name">conn1 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">contextual_connection</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_name">conn2 </span><span class="python_operator">= </span><span class="python_name">db</span><span class="python_operator">.</span><span class="python_name">contextual_connection</span><span class="python_enclosure">()</span><span class="python_operator">
</span>
<span class="python_literal">>>> </span><span class="python_keyword">assert </span><span class="python_name">conn1</span><span class="python_operator">.</span><span class="python_name">connection </span><span class="python_keyword">is </span><span class="python_name">conn2</span><span class="python_operator">.</span><span class="python_name">connection</span><span class="python_operator">
</span><span class="python_name">True</span><span class="python_operator"></span></pre></div>
<p>When the <code>plain</code> strategy is used, the <code>contextual_connection()</code> method is synonymous with the <code>connect()</code> method; both return a distinct connection from the pool.
</p>


    </div>


    <a href="#dbengine" class="toclink">back to section top</a>


</div>





</div>


        



<A name="dbengine_transactions"></a>

<div class="subsection" style="margin-left:20px;">

    <span class="sectionheadertext">Transactions</span>
    <div class="sectiontext">



<p>The <code>Connection</code> object provides a <code>begin()</code> method which returns a <code>Transaction</code> object.  This object is usually used within a try/except clause so that it is guaranteed to <code>rollback()</code> or <code>commit()</code>:
</p>


<div class="sliding_code">
<pre><span class="python_name">trans </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">begin</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_keyword">try</span><span class="python_operator">:
    </span><span class="python_name">r1 </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_name">table1</span><span class="python_operator">.</span><span class="python_name">select</span><span class="python_enclosure">())</span><span class="python_operator">
    </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_name">table1</span><span class="python_operator">.</span><span class="python_name">insert</span><span class="python_enclosure">()</span><span class="python_operator">, </span><span class="python_name">col1</span><span class="python_operator">=</span><span class="python_number">7</span><span class="python_operator">, </span><span class="python_name">col2</span><span class="python_operator">=</span><span class="python_literal">'this is some data'</span><span class="python_enclosure">)</span><span class="python_operator">
    </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">commit</span><span class="python_enclosure">()</span><span class="python_operator">
</span><span class="python_keyword">except</span><span class="python_operator">:
    </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">rollback</span><span class="python_enclosure">()</span><span class="python_operator">
    </span><span class="python_keyword">raise</span><span class="python_operator"></span></pre></div>
<p>The <code>Transaction</code> object also handles "nested" behavior by keeping track of the outermost begin/commit pair.  In this example, two functions both issue a transaction on a Connection, but only the outermost Transaction object actually takes effect when it is committed.
</p>


<div class="sliding_code">
<pre><span class="python_comment"># method_a starts a transaction and calls method_b
</span><span class="python_keyword">def </span><span class="python_name">method_a</span><span class="python_enclosure">(</span><span class="python_name">connection</span><span class="python_enclosure">)</span><span class="python_operator">:
    </span><span class="python_name">trans </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">begin</span><span class="python_enclosure">() </span><span class="python_comment"># open a transaction</span><span class="python_operator">
    </span><span class="python_keyword">try</span><span class="python_operator">:
        </span><span class="python_name">method_b</span><span class="python_enclosure">(</span><span class="python_name">connection</span><span class="python_enclosure">)</span><span class="python_operator">
        </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">commit</span><span class="python_enclosure">()  </span><span class="python_comment"># transaction is committed here</span><span class="python_operator">
    </span><span class="python_keyword">except</span><span class="python_operator">:
        </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">rollback</span><span class="python_enclosure">() </span><span class="python_comment"># this rolls back the transaction unconditionally</span><span class="python_operator">
        </span><span class="python_keyword">raise</span><span class="python_operator">
</span>
<span class="python_comment"># method_b also starts a transaction
</span><span class="python_operator"></span><span class="python_keyword">def </span><span class="python_name">method_b</span><span class="python_enclosure">(</span><span class="python_name">connection</span><span class="python_enclosure">)</span><span class="python_operator">:
    </span><span class="python_name">trans </span><span class="python_operator">= </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">begin</span><span class="python_enclosure">() </span><span class="python_comment"># open a transaction - this runs in the context of method_a's transaction</span><span class="python_operator">
    </span><span class="python_keyword">try</span><span class="python_operator">:
        </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_literal">"insert into mytable values ('bat', 'lala')"</span><span class="python_enclosure">)</span><span class="python_operator">
        </span><span class="python_name">connection</span><span class="python_operator">.</span><span class="python_name">execute</span><span class="python_enclosure">(</span><span class="python_name">mytable</span><span class="python_operator">.</span><span class="python_name">insert</span><span class="python_enclosure">()</span><span class="python_operator">, </span><span class="python_name">col1</span><span class="python_operator">=</span><span class="python_literal">'bat'</span><span class="python_operator">, </span><span class="python_name">col2</span><span class="python_operator">=</span><span class="python_literal">'lala'</span><span class="python_enclosure">)</span><span class="python_operator">
        </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">commit</span><span class="python_enclosure">()  </span><span class="python_comment"># transaction is not committed yet</span><span class="python_operator">
    </span><span class="python_keyword">except</span><span class="python_operator">:
        </span><span class="python_name">trans</span><span class="python_operator">.</span><span class="python_name">rollback</span><span class="python_enclosure">() </span><span class="python_comment"># this rolls back the transaction unconditionally</span><span class="python_operator">
        </span><span class="python_keyword">raise</span><span class="python_operator">
</span>
<span class="python_comment"># open a Connection and call method_a
</span><span class="python_operator"></span><span class="python_name">conn </span><span class="python_operator">= </span><span class="python_name">engine</span><span class="python_operator">.</span><span class="python_name">connect</span><span class="python_enclosure">()                </span><span class="python_operator">
</span><span class="python_name">method_a</span><span class="python_enclosure">(</span><span class="python_name">conn</span><span class="python_enclosure">)</span><span class="python_operator">
</span><span class="python_name">conn</span><span class="python_operator">.</span><span class="python_name">close</span><span class="python_enclosure">()</span><span class="python_operator"></span></pre></div>
<p>Above, <code>method_a</code> is called first, which calls <code>connection.begin()</code>.  Then it calls <code>method_b</code>. When <code>method_b</code> calls <code>connection.begin()</code>, it just increments a counter that is decremented when it calls <code>commit()</code>.  If either <code>method_a</code> or <code>method_b</code> calls <code>rollback()</code>, the whole transaction is rolled back.  The transaction is not committed until <code>method_a</code> calls the <code>commit()</code> method.
</p>
<p>Note that SQLAlchemy's Object Relational Mapper also provides a way to control transaction scope at a higher level; this is described in <a href="unitofwork.html#unitofwork_transaction" >SessionTransaction</a>.
</p>


    </div>


    <a href="#dbengine" class="toclink">back to section top</a>


</div>




    
<div class="sectionnavblock">
<div class="sectionnav">


        Previous: <a href="tutorial.html">Tutorial</a>

                |

        Next: <a href="metadata.html">Database Meta Data</a>

</div>
</div>


</div>


		</div>






</div>

















<center>
</center>
</body>
</html>




