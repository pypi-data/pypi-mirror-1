<?xml version='1.0' encoding='iso-8859-1'?>
<section><h>Migration info for the old core package</h>

<section><h>Migrating to ll-core 0.3</h>

<section><h>Changes to namespaces</h>
<p>Functions will no longer will turned into <class>staticmethod</class>s
automatically, so you have to decorate them yourself.</p>
</section>

</section>

</section>

<section><h>Migration info for ll-make</h>

<section><h>Migrating to ll-make 1.0</h>
<p><class>Target</class>s now have four action chains instead of one, so you
have to rewrite your <class>Target</class> constructors. How the new call looks
depends on the target itself. For example a simple copy operation might look
like this:</p>
<example>
<h>Copying files with action chains</h>
<prog>
source = make.FileTarget(project, "foo", readaction=make.ReadAction())
target = make.FileTarget(project, "bar", convertaction=make.SelectMainAction(), writeaction=make.WriteAction())
target.dependOn(make.MainDep, source)
</prog>
</example>

<p>Importing modules from other modules can now be done like this:</p>

<example>
<h>Import module targets</h>
<prog>
from ll import make

foo = make.currentproject["build/foo.py"].getdata()
</prog>
</example>

<p>Furthermore if <lit>build/foo.py</lit> itself is generated by other actions,
these actions will be executed before <lit>build/foo.py</lit> is imported.
For this to work you need to use the correct action chains for your target:</p>

<example>
<h>Defining Python modules as targets</h>
<prog>
srcfoo = make.PythonTarget(
	project,
	"src/foo.py",
	readaction=make.ReadAction()
)
buildfoo = make.PythonTarget(
	project,
	"build/foo.py",
	cache=True,
	convertaction=make.SelectMainAction()+make.WriteAction()+make.ImportAction()+make.UseModuleAction(),
	readaction=make.ImportAction()+make.UseModuleAction(),
	useaction=make.UseModuleAction()
)
buildfoo.dependOn(make.MainDep, srcfoo)
</prog>
</example>

</section>


<section><h>Migrating to ll-make 0.26</h>
<p>All <class>Target</class> constructors expect to be passed <em>one</em>
<class>Action</class> instance only now, so instead of:</p>
<prog>
t = make.FileTarget(project, id, action1, action2, action3)
</prog>
<p>you should use:</p>
<prog>
t = make.FileTarget(project, id, action=action1+action2+action3)
</prog>
<p>Adding targets will create an appropriate <class>ChainedAction</class> object
from the added actions.</p>
</section>


<section><h>Migrating to ll-make 0.23</h>
<p>A class variable <lit>name</lit> in an action class will
be ignored now. You have to implement a method <meth>desc</meth>
(and might implement <meth>fulldesc</meth> to give a longer description).</p>
</section>


<section><h>Migrating to ll-make 0.17</h>
<p><class>OracleTarget</class> has been renamed to <class>DBTarget</class>.</p>
</section>


<section><h>Migrating to ll-make 0.15</h>
<p>The environment variable <lit>MAKE_REPRANSI</lit> has been renamed to
<lit>LL_MAKE_REPRANSI</lit>.</p>
</section>


<section><h>Migrating to ll-make 0.14</h>
<p>The way actions are handled has changed completely. Instead of a single action
that loads the input, does something and saves to output, each of these steps is
done by a separate action.</p>
<p>&xist; transformations will now look something like this:</p>
<example>
<prog>
from ll import make
p = make.Project()
t0 = make.XISTTarget(p, url.File("foo.htmlxsc"))
t1 = make.XISTTarget(p,
	url.File("../install/foo.html",
	make.ReadAction(),
	make.XISTParseAction(base=url.File("root:foo.html")),
	make.XISTConvertAction(),
	make.XISTPublishAction(
		publisher=publishers.Publisher(encoding="us-ascii"),
		base=url.File("root:foo.html")
	),
	make.WriteAction(),
	make.ModeAction(0644)
)
t1.dependOn(make.MainDep, t0)
</prog>
</example>

<p>Several <class>Target</class> methods have been renamed:
<meth>sources</meth> has been renamed to <meth>inputs</meth>.
<meth>targets</meth> has been renamed to <meth>outputs</meth>.
Several related methods and options have been renamed too.</p>

<p>The output during the build has changed. Instead of newer
sources, the main sources will always be displayed now.</p>

<p>The options controlling the output during the build have
beed changed and joined into one option, where letters in the
option value switch certain output on and off. For more info
simply invoke the build script with the option <option>--help</option>.</p>

</section>


<section><h>Migrating to ll-make 0.12</h>
<p><app>make</app> has been updated for &xist; 2.4: Parsing and publishing
&xist; files is now no longer the job of the <class>XISTAction</class> class
itself, but is done through the attributes <lit>parser</lit> and <lit>publisher</lit>
of the <class>XISTTarget</class> object, which must be an &xist; parser and
&xist; publisher respectively.</p>
</section>


<section><h>Migrating to ll-make 0.8</h>
<p>All dictionary access method now try the literal id first,
and if it's a string, they will retry with an &url; and an
absolute &url;. So now you can no longer have a phony target
and a file target with the same name (which shouldn't be a problem
anyway, because a file target should include the full path).</p>
</section>


<section><h>Migrating to ll-make 0.6</h>

<p>The <class>Target</class> methods <meth>sources</meth>
and <meth>targets</meth> have been changed, so that they
return the source and target <class>Target</class>s instead of
the dependency objects.</p>

<p>This should be more convenient, because in most cases
the targets are needed anyway. The old functionality
is available through the new methods <meth>sourcedeps</meth>
and <meth>targetdeps</meth>. If you've defined your own
action classes you'll probably have to update them.</p>

<p>The same change has been made for the method <meth>newerSources</meth>
(and the method name has been made lowercase). So <meth>newersources</meth>
will return a list of <class>Target</class>s and <meth>newersourcedeps</meth>
will return the list of dependencies accordingly.</p>

</section>

</section>
