<par>The class <pyref module="ll.url" class="URL"><class>ll.url.URL</class></pyref>
supports many common schemes and one additional special scheme named
<lit>root</lit> that deserves an explanation.</par>

<par>A <lit>root</lit> &url; is supposed to be an &url; that is relative
to a <z>project</z> directory instead to a base &url; of the document that contains
the &url;.</par>

<par>Suppose we have the following document with the following
base &url;:</par>

<prog>
&gt;&gt;&gt; from ll import url
&gt;&gt;&gt; base = url.URL("root:company/it/about/index.html")
</prog>

<par>Now, if we have the following relative &url; in this document:</par>

<prog>
&gt;&gt;&gt; url1 = url.URL("images/logos/spam.png")
</prog>

<par>the combined &url; will be:</par>

<prog>
&gt;&gt;&gt; base/url1
URL('root:company/it/about/images/logos/spam.png')
</prog>

<par>Now it we use this combined &url; and interpret
it relative to the base &url; we get back our
original relative &url;:</par>

<prog>
&gt;&gt;&gt; (base/url1).relative(base)
URL('images/logos/spam.png')
</prog>

<par>Let's try a <lit>root</lit> &url; now:</par>

<prog>
&gt;&gt;&gt; url2 = url.URL("root:images/logos/spam.png")
</prog>

<par>Combining this &url; with the base &url; gives us
the same as <lit>url2</lit>:</par>

<prog>
&gt;&gt;&gt; base/url2
URL('root:images/logos/spam.png')
</prog>

<par>But if we interpret this result relative to <lit>base</lit>, we'll get:</par>
<prog>
&gt;&gt;&gt; (base/url2).relative(base)
URL('../../../images/logos/spam.png')
</prog>

<par>I.e. this gives us a relative &url; that references <lit>url2</lit>
from <lit>base</lit> when both &url;s are relative to the same root directory.</par>
