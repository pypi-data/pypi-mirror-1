<?xml version="1.0"?>
<dictionary 
  namespace="http://www.kjemi.uio.no/software/dalton/"
  dictionaryPrefix="dalton" 
  title="DALTON dictionary"
  xmlns="http://www.xml-cml.org/schema"
  xmlns:h="http://www.w3.org/1999/xhtml/"
  xmlns:cml="http://www.xml-cml.org/schema"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:golem="http://www.lexical.org.uk/golem"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <metadataList>
    <metadata name="dc:creator" content="golem-kiln" />
  </metadataList>

  <!-- This dictionary created using pyGolem -->

  <entry id="EMCSCF" term="Final MCSCF energy">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:module[@dictRef="dalton:WAVFUN"]/cml:property[@dictRef="dalton:EMCSCF"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>
    <golem:childOf>WAVFUN</golem:childOf>

    
  </entry>

  <entry id="dc:creator" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:metadataList/cml:metadata[@name="dc:creator"]</golem:xpath>
    <golem:template call="metadata" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="POLARIZE" term="Polarizability calculations">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:module[@dictRef="dalton:POLARIZE"]</golem:xpath>


    <golem:implements>grouping</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="basisSets" term="Basis Sets">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:parameterList[@dictRef="dalton:basisSets"]</golem:xpath>


    <golem:implements>grouping</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="NUCDEP" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:parameterList[@dictRef="dalton:basisSets"]/cml:parameter[@dictRef="dalton:NUCDEP"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>
    <golem:childOf>basisSets</golem:childOf>

    
  </entry>

  <entry id="TOTMAS" term="Total mass">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:property[@dictRef="dalton:TOTMAS"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="WAVFUN" term="Wave function calculations">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:module[@dictRef="dalton:WAVFUN"]</golem:xpath>


    <golem:implements>grouping</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="POTNUC" term="Nuclear repulsion energy">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:property[@dictRef="dalton:POTNUC"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="dc:contributor" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:metadata[@name="dc:contributor"]</golem:xpath>
    <golem:template call="metadata" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="GAMMA" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:module[@dictRef="dalton:POLARIZE"]/cml:module[@dictRef="dalton:GAMMA"]</golem:xpath>


    <golem:implements>grouping</golem:implements>
    <golem:implements>absolute</golem:implements>
    <golem:childOf>POLARIZE</golem:childOf>

    
  </entry>

  <entry id="DISTMX" term="Max. interatomic distance">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:property[@dictRef="dalton:DISTMX"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="NONTYP" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:parameterList[@dictRef="dalton:basisSets"]/cml:parameter[@dictRef="dalton:NONTYP"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>
    <golem:childOf>basisSets</golem:childOf>

    
  </entry>

  <entry id="UUID" term="">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:metadata[@name="UUID"]</golem:xpath>
    <golem:template call="metadata" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>

    
  </entry>

  <entry id="MCSCFTYPE" term="MCSCF type">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>.//cml:parameterList/cml:parameter[@dictRef="dalton:MCSCFTYPE"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>relative</golem:implements>
    <golem:childOf>WAVFUN</golem:childOf>
    <golem:childOf>POLARIZE</golem:childOf>

    
  </entry>

  <entry id="ISTATE" term="State number">
    <annotation />
    <definition />
    <description />    
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:xpath>/cml:cml/cml:module[@dictRef="dalton:WAVFUN"]/cml:property[@dictRef="dalton:ISTATE"]</golem:xpath>
    <golem:template call="scalar" role="getvalue" binding="pygolem_serialization" />


    <golem:implements>value</golem:implements>
    <golem:implements>absolute</golem:implements>
    <golem:childOf>WAVFUN</golem:childOf>

    
  </entry>



   <!-- pyGolem Internals. DO NOT EDIT BEYOND THIS POINT UNLESS YOU
        KNOW WHAT YOU ARE DOING - or things will probably stop working. -->
        
   <!--
     XSLT found in this dictionary is licensed according to the following
     terms:
     
     Copyright (c) 2005-2008 Toby White <tow21@cam.ac.uk>
               (c) 2007-2008 Andrew Walkingshaw <andrew@lexical.org.uk>
               
     Permission is hereby granted, free of charge, to any person obtaining 
     a copy of this software and associated documentation files (the 
     "Software"), to deal in the Software without restriction, including 
     without limitation the rights to use, copy, modify, merge, publish, 
     distribute, sublicense, and/or sell copies of the Software, and to 
     permit persons to whom the Software is furnished to do so, subject to 
     the following conditions:

     The above copyright notice and this permission notice shall be 
      included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   -->

  <entry id="gwtsystem" term="INTERNAL ENTRY for golem web tool use">
    <definition/>
    <description/>
    <metadataList/>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="absolute" term="Absolutely-positioned concept">
    <definition>Concept which only occurs once in a document</definition>
    <description>
      <h:p>Absolutely-positioned concepts occur exactly once in a document,
           and therefore do not need to be located by specifying a given 
           grouping concept (or chain of grouping concepts).
      </h:p>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="relative" term="Relatively-positioned concept">
    <definition>Concept which may occur many times in a document</definition>
    <description>
      <h:p>Relatively-positioned concepts can occur more than once in a 
           document, and therefore need to be located by specifying a given 
           grouping concept (or chain of grouping concepts).
      </h:p>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="grouping" term="Grouping concept">
    <definition>Concept acting as a container for other concepts</definition>
    <description>
      <h:p>
      Grouping concepts do not directly contain values; instead, they contain
      other, relatively positioned, concepts, which themselves may or may not
      contain values.
      </h:p>
    </description>          
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="value" term="Value-bearing concept">
    <definition>Concept with a direct payload of data</definition>
    <description>
      <h:p>
        Value-bearing concepts directly contain observables -
        data with a value we can extract and evaluate.
      </h:p>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="parameterInInput" term="Input parameter">
    <definition>User-specified input parameters for the simulation.</definition>
    <description>
      <h:p>
      </h:p>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="convertibleToInput" term="Input parameter">
    <definition>User-specified input parameters with defined transforms to
    code-native input.</definition>
    <description>
      <h:p>
      </h:p>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>
  
  <entry id="inFinalProperties" term="Final property">
    <definition>A concept appearing the final properties of a task.</definition>
    <description>
    </description>
    <metadataList>
      <metadata name="dc:author" content="golem-kiln" />
    </metadataList>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="atomArray" term="FoX Atom array parser">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
      <xsl:stylesheet version='1.0' 
		xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		xmlns:cml='http://www.xml-cml.org/schema'
		xmlns:str="http://exslt.org/strings"
		extension-element-prefixes="str"
		>
      <xsl:output method="text" />
      <xsl:template match="/">
        <xsl:apply-templates />
      </xsl:template>
      <xsl:template match="cml:atomArray">
        <xsl:text>[[</xsl:text>
        <xsl:for-each select="cml:atom">
          <xsl:text>["</xsl:text><xsl:value-of select="@elementType" /><xsl:text>"</xsl:text>
          <xsl:text>,</xsl:text>
          <xsl:value-of select="@xFract" />
          <xsl:text>,</xsl:text>
          <xsl:value-of select="@yFract" />
          <xsl:text>,</xsl:text>
          <xsl:value-of select="@zFract" />
          <xsl:text>,</xsl:text>
          <xsl:choose>
            <xsl:when test="@occupancy">
              <xsl:value-of select="@occupancy" />
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>1</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>,</xsl:text>
          <xsl:choose>
	    <xsl:when test="@id">
	      <xsl:text>"</xsl:text><xsl:value-of select="@id" /><xsl:text>"</xsl:text>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:text>"Unspecified"</xsl:text>
	    </xsl:otherwise>
          </xsl:choose>
          <xsl:choose>
	    <xsl:when test="position() != last()">
	      <xsl:text>],</xsl:text>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:text>]</xsl:text>
	    </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each>
        <xsl:text>], ""]</xsl:text>
      </xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:xpath>.//cml:atomArray</golem:xpath>
  </entry>
  
  <entry id="lattice" term="Set of lattice vectors - generic read">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">

      <xsl:stylesheet version='1.0' 
		      xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		      xmlns:cml='http://www.xml-cml.org/schema'
		      xmlns:str="http://exslt.org/strings"
		      extension-element-prefixes="str"
		      >
	<xsl:output method="text" />

	<xsl:template match="/">
	  <xsl:apply-templates />
	</xsl:template>
	
	<xsl:template match="cml:lattice">
	  <xsl:text>[</xsl:text>
	  <xsl:for-each select="cml:latticeVector">
	    <xsl:text>[</xsl:text> 
	    <xsl:for-each select="str:tokenize(string(.), ' ')" >
	      <xsl:choose>
		<xsl:when test="position() != last()">
		  <xsl:value-of select="." /><xsl:text>,</xsl:text>
		</xsl:when>
		<xsl:otherwise>
		  <xsl:value-of select="." />
		</xsl:otherwise>
	      </xsl:choose>
	    </xsl:for-each>
	    <xsl:choose>
	      <xsl:when test="position() != last()">
		<xsl:text>],</xsl:text>
	      </xsl:when>
	      <xsl:otherwise>
		<xsl:text>]</xsl:text>
	      </xsl:otherwise>
	    </xsl:choose>
	  </xsl:for-each>
	  <xsl:text>]</xsl:text>
	</xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:xpath>.//cml:lattice</golem:xpath>
    <golem:possibleValues type="matrix">
      <golem:matrix dimensionx="3" dimensiony="3" type="float" symmetric="false"/>
      <golem:range>
	<golem:minimum>0</golem:minimum>
      </golem:range>
    </golem:possibleValues>
  </entry>
  
  <entry id="metadata" term="Metadata default call">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
        <xsl:stylesheet version='1.0' 
                xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		xmlns:cml='http://www.xml-cml.org/schema'
		xmlns:str="http://exslt.org/strings"
		xmlns:func="http://exslt.org/functions"
		xmlns:exsl="http://exslt.org/common"
		xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
		extension-element-prefixes="func exsl tohw str"
		exclude-result-prefixes="exsl func tohw xsl str">
        <xsl:output method="text" />
        <xsl:template match="/">
          <xsl:apply-templates />
        </xsl:template>    
	<xsl:template match="cml:metadata">
	  <xsl:text>["</xsl:text><xsl:value-of select="@content" /><xsl:text>", "golem:metadata"]</xsl:text>
	</xsl:template>
      </xsl:stylesheet>
    </golem:template>
  </entry>
  
  <entry id="matrix" term="Matrix default call">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
        <xsl:stylesheet version='1.0' 
                xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		xmlns:cml='http://www.xml-cml.org/schema'
		xmlns:str="http://exslt.org/strings"
		xmlns:func="http://exslt.org/functions"
		xmlns:exsl="http://exslt.org/common"
		xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
		extension-element-prefixes="func exsl tohw str"
		exclude-result-prefixes="exsl func tohw xsl str">
        <xsl:output method="text" />
  
  <func:function name="tohw:isAListOfDigits">
    <!-- look only for [0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:choose>
      <xsl:when test="string-length($x)=0">
        <func:result select="false()"/>
      </xsl:when>
      <xsl:when test="substring($x, 1, 1)='0' or
                      substring($x, 1, 1)='1' or
                      substring($x, 1, 1)='2' or
                      substring($x, 1, 1)='3' or
                      substring($x, 1, 1)='4' or
                      substring($x, 1, 1)='5' or
                      substring($x, 1, 1)='6' or
                      substring($x, 1, 1)='7' or
                      substring($x, 1, 1)='8' or
                      substring($x, 1, 1)='9'">
        <xsl:choose>
          <xsl:when test="string-length($x)=1">
            <func:result select="true()"/>
          </xsl:when>
          <xsl:otherwise>
            <func:result select="tohw:isAListOfDigits(substring($x, 2))"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="false()"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnInteger">
    <!-- numbers fitting [\+-][0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:variable name="try">
      <xsl:choose>
        <xsl:when test="starts-with($x, '+')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:when test="starts-with($x, '-')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$x"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <func:result select="tohw:isAListOfDigits($try)"/>
  </func:function>

  <func:function name="tohw:isANumberWithoutExponent">
    <!-- numbers fitting [\+-][0-9]+(\.[0-9]*) -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, '.')">
        <func:result select="tohw:isAnInteger(substring-before($x, '.')) and
                             tohw:isAListOfDigits(substring-after($x, '.'))"/>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="tohw:isAnInteger($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnFPNumber">
    <!-- Try and interpret a string as an exponential number -->
    <!-- should only recognise strings of the form: [\+-][0-9]*\.[0-9]*([DdEe][\+-][0-9]+)? -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, 'd')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'd')) and
                             tohw:isAnInteger(substring-after($x, 'd'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'D')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'D')) and
                             tohw:isAnInteger(substring-after($x, 'D'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'e')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'e')) and
                             tohw:isAnInteger(substring-after($x, 'e'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'E')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'E')) and
                             tohw:isAnInteger(substring-after($x, 'E'))"/>
      </xsl:when>
      <xsl:otherwise>
         <func:result select="tohw:isANumberWithoutExponent($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>
  
      <xsl:output method="text" />
  
      <xsl:template match="/">
        <xsl:apply-templates />
      </xsl:template>
    
      <xsl:template match="cml:matrix">
        <xsl:param name="rowlength">
          <xsl:value-of select="@columns" />
        </xsl:param>
        <xsl:text>[[</xsl:text>
        <xsl:for-each select="str:tokenize(string(.), ' ')" >
          <xsl:if test="position() mod $rowlength = 1">
            <xsl:text>[</xsl:text>
          </xsl:if>
          <xsl:choose>
            <xsl:when test="position() = last()">
              <xsl:choose>
                <xsl:when test="tohw:isAnFPNumber(.)">
                  <xsl:value-of select="." /><xsl:text>]</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:text>"</xsl:text><xsl:value-of select="." /><xsl:text>"]</xsl:text>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="position() mod $rowlength = 0">
              <xsl:choose>
                <xsl:when test="tohw:isAnFPNumber(.)">
                  <xsl:value-of select="." /><xsl:text>],</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:text>"</xsl:text><xsl:value-of select="." /><xsl:text>"],</xsl:text>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="tohw:isAnFPNumber(.)">
                  <xsl:value-of select="." /><xsl:text>,</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:text>"</xsl:text><xsl:value-of select="." /><xsl:text>",</xsl:text>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each>
        <xsl:text>],</xsl:text>
        <xsl:choose>
          <xsl:when test="@units">
            <xsl:text>"</xsl:text><xsl:value-of select="@units" /><xsl:text>"</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>""</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:text>]</xsl:text>
      </xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="cellParameter" term="Cell parameter default call">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
      <xsl:stylesheet version='1.0' 
                      xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
                      xmlns:cml='http://www.xml-cml.org/schema'
                      xmlns:str="http://exslt.org/strings"
                      extension-element-prefixes="str"
                      >
        <xsl:output method="text" />
        
        <xsl:template match="/">
          <xsl:apply-templates />
        </xsl:template>
    
        <xsl:template match="cml:cellParameter[@parameterType='length']">
          <xsl:text>[[[</xsl:text>
          <xsl:for-each select="str:tokenize(string(.), ' ')" >
            <xsl:choose>
              <xsl:when test="position() = last()">
                <xsl:value-of select="." />
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="." /><xsl:text>,</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>
          <xsl:text>],</xsl:text>
          <xsl:choose>
            <xsl:when test="@units">
              <xsl:text>"</xsl:text><xsl:value-of select="@units" /><xsl:text>"</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>""</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>],[[</xsl:text>
        </xsl:template>
        
        <xsl:template match="cml:cellParameter[@parameterType='angle']">
          <xsl:for-each select="str:tokenize(string(.), ' ')" >
            <xsl:choose>
              <xsl:when test="position() = last()">
                <xsl:value-of select="." />
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="." /><xsl:text>,</xsl:text>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>
          <xsl:text>],</xsl:text>
          <xsl:choose>
            <xsl:when test="@units">
              <xsl:text>"</xsl:text><xsl:value-of select="@units" /><xsl:text>"</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>""</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>]]</xsl:text>
        </xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="array" term="Array default call">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
        <xsl:stylesheet version='1.0' 
                xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		xmlns:cml='http://www.xml-cml.org/schema'
		xmlns:str="http://exslt.org/strings"
		xmlns:func="http://exslt.org/functions"
		xmlns:exsl="http://exslt.org/common"
		xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
		extension-element-prefixes="func exsl tohw str"
		exclude-result-prefixes="exsl func tohw xsl str">
        <xsl:output method="text" />
    
  <func:function name="golemxsl:escape">
    <xsl:param name="text"/>
    <func:result select='str:replace($text, "&apos;", "\&apos;")'/>
  </func:function>
  
  <func:function name="tohw:isAListOfDigits">
    <!-- look only for [0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:choose>
      <xsl:when test="string-length($x)=0">
        <func:result select="false()"/>
      </xsl:when>
      <xsl:when test="substring($x, 1, 1)='0' or
                      substring($x, 1, 1)='1' or
                      substring($x, 1, 1)='2' or
                      substring($x, 1, 1)='3' or
                      substring($x, 1, 1)='4' or
                      substring($x, 1, 1)='5' or
                      substring($x, 1, 1)='6' or
                      substring($x, 1, 1)='7' or
                      substring($x, 1, 1)='8' or
                      substring($x, 1, 1)='9'">
        <xsl:choose>
          <xsl:when test="string-length($x)=1">
            <func:result select="true()"/>
          </xsl:when>
          <xsl:otherwise>
            <func:result select="tohw:isAListOfDigits(substring($x, 2))"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="false()"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnInteger">
    <!-- numbers fitting [\+-][0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:variable name="try">
      <xsl:choose>
        <xsl:when test="starts-with($x, '+')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:when test="starts-with($x, '-')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$x"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <func:result select="tohw:isAListOfDigits($try)"/>
  </func:function>

  <func:function name="tohw:isANumberWithoutExponent">
    <!-- numbers fitting [\+-][0-9]+(\.[0-9]*) -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, '.')">
        <func:result select="tohw:isAnInteger(substring-before($x, '.')) and
                             tohw:isAListOfDigits(substring-after($x, '.'))"/>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="tohw:isAnInteger($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnFPNumber">
    <!-- Try and interpret a string as an exponential number -->
    <!-- should only recognise strings of the form: [\+-][0-9]*\.[0-9]*([DdEe][\+-][0-9]+)? -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, 'd')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'd')) and
                             tohw:isAnInteger(substring-after($x, 'd'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'D')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'D')) and
                             tohw:isAnInteger(substring-after($x, 'D'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'e')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'e')) and
                             tohw:isAnInteger(substring-after($x, 'e'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'E')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'E')) and
                             tohw:isAnInteger(substring-after($x, 'E'))"/>
      </xsl:when>
      <xsl:otherwise>
         <func:result select="tohw:isANumberWithoutExponent($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>
  
        <xsl:template match="/">
          <xsl:apply-templates />
        </xsl:template>

        <xsl:template match="cml:array">
          <xsl:variable name="delim">
            <xsl:choose>
               <xsl:when test="@delimiter">
                 <xsl:value-of select="@delimiter" />
               </xsl:when> 
               <xsl:otherwise>
                 <xsl:text> </xsl:text>
               </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:text>[[</xsl:text>
            <xsl:for-each select="str:tokenize(string(.), $delim)" >
              <xsl:choose>
                <xsl:when test="tohw:isAnFPNumber(.)">
                  <xsl:value-of select="." />
                </xsl:when>
                <xsl:otherwise>
                  <xsl:text>"</xsl:text><xsl:value-of select="." /><xsl:text>"</xsl:text>
                </xsl:otherwise>
              </xsl:choose>
              <xsl:if test="position() != last()">
                <xsl:text>,</xsl:text>
              </xsl:if>
            </xsl:for-each>
          <xsl:text>],</xsl:text>
          <xsl:choose>
            <xsl:when test="@units">
              <xsl:text>"</xsl:text><xsl:value-of select="@units" /><xsl:text>"</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text>""</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:text>]</xsl:text>
        </xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>

  <entry id="scalar" term="Scalar default call">
    <annotation />
    <definition />
    <description />
    <metadataList />
    <golem:template role="getvalue" binding="pygolem_serialization">
        <xsl:stylesheet version='1.0' 
                xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
		xmlns:cml='http://www.xml-cml.org/schema'
		xmlns:str="http://exslt.org/strings"
		xmlns:func="http://exslt.org/functions"
		xmlns:exsl="http://exslt.org/common"
		xmlns:tohw="http://www.uszla.me.uk/xsl/1.0/functions"
		extension-element-prefixes="func exsl tohw str"
		exclude-result-prefixes="exsl func tohw xsl str">
        <xsl:output method="text" />
  
  
  <func:function name="tohw:isAListOfDigits">
    <!-- look only for [0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:choose>
      <xsl:when test="string-length($x)=0">
        <func:result select="false()"/>
      </xsl:when>
      <xsl:when test="substring($x, 1, 1)='0' or
                      substring($x, 1, 1)='1' or
                      substring($x, 1, 1)='2' or
                      substring($x, 1, 1)='3' or
                      substring($x, 1, 1)='4' or
                      substring($x, 1, 1)='5' or
                      substring($x, 1, 1)='6' or
                      substring($x, 1, 1)='7' or
                      substring($x, 1, 1)='8' or
                      substring($x, 1, 1)='9'">
        <xsl:choose>
          <xsl:when test="string-length($x)=1">
            <func:result select="true()"/>
          </xsl:when>
          <xsl:otherwise>
            <func:result select="tohw:isAListOfDigits(substring($x, 2))"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="false()"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnInteger">
    <!-- numbers fitting [\+-][0-9]+ -->
    <xsl:param name="x_"/>
    <xsl:variable name="x" select="normalize-space($x_)"/>
    <xsl:variable name="try">
      <xsl:choose>
        <xsl:when test="starts-with($x, '+')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:when test="starts-with($x, '-')">
          <xsl:value-of select="substring($x,2)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$x"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <func:result select="tohw:isAListOfDigits($try)"/>
  </func:function>

  <func:function name="tohw:isANumberWithoutExponent">
    <!-- numbers fitting [\+-][0-9]+(\.[0-9]*) -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, '.')">
        <func:result select="tohw:isAnInteger(substring-before($x, '.')) and
                             tohw:isAListOfDigits(substring-after($x, '.'))"/>
      </xsl:when>
      <xsl:otherwise>
        <func:result select="tohw:isAnInteger($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>

  <func:function name="tohw:isAnFPNumber">
    <!-- Try and interpret a string as an exponential number -->
    <!-- should only recognise strings of the form: [\+-][0-9]*\.[0-9]*([DdEe][\+-][0-9]+)? -->
    <xsl:param name="x"/>
    <xsl:choose>
      <xsl:when test="contains($x, 'd')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'd')) and
                             tohw:isAnInteger(substring-after($x, 'd'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'D')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'D')) and
                             tohw:isAnInteger(substring-after($x, 'D'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'e')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'e')) and
                             tohw:isAnInteger(substring-after($x, 'e'))"/>
      </xsl:when>
      <xsl:when test="contains($x, 'E')">
        <func:result select="tohw:isANumberWithoutExponent(substring-before($x, 'E')) and
                             tohw:isAnInteger(substring-after($x, 'E'))"/>
      </xsl:when>
      <xsl:otherwise>
         <func:result select="tohw:isANumberWithoutExponent($x)"/>
      </xsl:otherwise>
    </xsl:choose>
  </func:function>
        
  <xsl:template match="/">
    <xsl:apply-templates />
  </xsl:template>
  
  <xsl:template match="cml:scalar">
    <xsl:variable name="value">
      <xsl:choose>
	<xsl:when test="tohw:isAnFPNumber(.)">
          <xsl:value-of select="." />
	</xsl:when>
	<xsl:otherwise>
          <xsl:text>"</xsl:text><xsl:value-of select="." /><xsl:text>"</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="units">
      <xsl:choose>
	<xsl:when test="@units">
	  <xsl:text>"</xsl:text><xsl:value-of select="@units" /><xsl:text>"</xsl:text>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:text>""</xsl:text>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:text>[</xsl:text><xsl:value-of select="$value"/><xsl:text>,</xsl:text><xsl:value-of select="$units" /><xsl:text>]</xsl:text>
  </xsl:template>
</xsl:stylesheet>
    </golem:template>

    <golem:template role="defaultoutput">
      <xsl:stylesheet version='1.0' 
                      xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
                      xmlns:cml='http://www.xml-cml.org/schema'
                      xmlns:str="http://exslt.org/strings"
                      extension-element-prefixes="str"
                      >
        <xsl:output method="text" />
        <xsl:param name="name" />
        <xsl:param name="value" />
        <xsl:template match="/">
          <xsl:value-of select='$name' /><xsl:value-of select='$value' />
        </xsl:template>
      </xsl:stylesheet>
    </golem:template>
    <golem:seealso>gwtsystem</golem:seealso>
  </entry>
</dictionary>

