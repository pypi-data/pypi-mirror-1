<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:p4d="http://fiber-space.de/p4dns">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <title>Bytelets</title>
  <meta content="Kay Schluehr" name="author">
  <meta content="Description of Bytelets" name="description">
</head>
<body>
<table
 style="width: 100%; text-align: left; margin-left: auto; margin-right: auto;"
 cellpadding="0" cellspacing="2">
  <tbody>
    <tr>
      <td><br>
      </td>
      <td
 style="background-color: rgb(102, 255, 255); width: 100%; text-align: left;">
      <div style="margin-left: 320px;"><span
 style="font-weight: bold; font-family: arial;">Easy Extend</span><br>
      </div>
      </td>
    </tr>
  </tbody>
</table>
<img alt="" src="bytelets-Dateien/EELogo_Small2.PNG"
 style="width: 67px; height: 53px;"><br>
<hr style="width: 100%; height: 2px;"><br>
<table style="text-align: left; width: 864px; height: 346px;"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 243px; height: 242px;" alt=""
 src="bytelets-Dateien/Bytelets.png"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><small><span
 style="font-family: copperplate gothic light;"><big
 style="font-family: franklin gothic book;">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Author:
Kay Schluehr<br>
      </big></span><big style="font-family: franklin gothic book;">&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
Date: 08-08-08<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vers: 1.0</big></small><small><span
 style="font-family: arial;"></span></small><small><span
 style="font-family: arial;"><br>
      </span></small></td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<hr style="width: 100%; height: 2px;">
<ul id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
  <li><a href="#mozTocId419618">1.
Introduction&nbsp;</a></li>
  <li><a href="#mozTocId616328">2. Using
Bytelets </a>
    <ul>
      <li><a href="#mozTocId237510">2.1
Bytelets and Hex objects</a></li>
      <li><a href="#mozTocId993466">2.2 Flow objects</a>
        <ul>
          <li><a href="#mozTocId203530">2.2.1 Anatomy
of a Flow object </a></li>
          <li><a href="#mozTocId554940">2.2.2 How LEN works </a></li>
          <li><a href="#mozTocId188697">2.2.3 LEN
and&nbsp; RAWLEN</a></li>
          <li><a href="#mozTocId216314"> </a></li>
          <li><a href="#mozTocId416380">2.2.4&nbsp; LEN
Expressions </a></li>
        </ul>
      </li>
      <li><a href="#mozTocId851966">2.3&nbsp;
Bytelet Schemas </a>
        <ul>
          <li><a href="#mozTocId547924">2.3.1&nbsp; The
Standard Schema</a></li>
          <ul>
            <li><a href="#mozTocId348080">2.3.1.1&nbsp;
How VAL
works </a></li>
          </ul>
          <li><a href="#mozTocId701690">2.3.2&nbsp; The tlvlist
Schema</a></li>
          <ul>
            <li><a href="#mozTocId940395">2.3.2.1&nbsp;
Mixing the Schema modes </a></li>
          </ul>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#mozTocId287682">3. Playing with
Bits</a>
    <ul>
      <li><a href="#mozTocId532467">3.1 Bin objects</a></li>
      <li><a href="#mozTocId854075">3.2 Sort of runtime type checks</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId329178">4. History</a></li>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<hr style="width: 100%; height: 2px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
<table style="text-align: left; width: 822px; height: 4228px;"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <h1><a class="mozTocH1" name="mozTocId419618"></a>1.
Introduction&nbsp;</h1>
      <span style="font-weight: bold;">B</span>ytelets are networks of
binary data encoded within a P4D data
structure. Bytelets originate from a flexible representation of <a
 target="_blank"
 href="http://en.wikipedia.org/wiki/Basic_encoding_rules">BER</a>-<a
 target="_blank" href="http://en.wikipedia.org/wiki/Type-length-value">TLV</a>s
which lets users easily create, modify and parse TLV (
Tag-Length-Value)
objects. Bytelets are more general than TLVs and L fields
can&nbsp; refer to arbitrary subfields of V which reflects many
practical applications found in technical specifications. L fields are
represented by functions that respond to changes of fields values they
are bound to. This way a simple dataflow network
emerges. This network can be extended to support more
advanced causal relationships between Bytelet fields. <br>
      <br>
All Bytelets can be serialized as binary data. Those binary data can be
parsed into Bytelets using again Bytelets as structural descriptions. A
Bytelet used as such a description is called a <span
 style="font-style: italic;">Bytelet Schema</span> or just <span
 style="font-style: italic;">Schema</span>. Often Bytelet Schemas and
the Bytelets created by parsing hexcode from those Schemas are
isomorphic i.e. they have the same structural properties and differ
only in field values. This is not much unlike C structs that can also
be used to cast on memory chunks to create new instances of those
structs.<br>
      <br>
Otherwise Bytelets are somewhat more low level than C-structs or ASN.1
based encodings because they are untyped<span
 style="font-style: italic;"></span>
There are no strings, ints, chars, arrays,&nbsp; pointers etc.and there
is no metalevel description available that translates type information
into sizes of memory chunks. <br>
      <br>
      <h1><a class="mozTocH1" name="mozTocId616328"></a>2. Using
Bytelets<br>
      </h1>
Bytelets are part of P4D and you need to <a href="p4d.html">install P4D</a>
to run the follwoing code. <br>
      <br>
Bytelets are represented by ordinary P4D elements. Using the <small><span
 style="font-weight: bold; font-family: Courier New,Courier,monospace;">bl</span></small>
prefix of the namespace<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(255, 255, 255); vertical-align: top;"><small>&nbsp;
prefix: bl<br>
&nbsp; uri: http://fiber-space.de/byteletns<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
informs the P4D langlet to create a Bytelet object instead of a P4D
object.<br>
      <br>
The first example shows how to create a simple Bytelet.<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
elm bl:A:<br>
....&nbsp;&nbsp;&nbsp; Tag: 0x01<br>
            </small><small>....&nbsp;&nbsp;&nbsp; Len: &amp;LEN<br>
....&nbsp;&nbsp;&nbsp; Val: 0x77AA<br>
....<br>
p4d&gt; A<br>
Bytelet&lt;bl:A&gt;<br>
p4d&gt; A.hex()<br>
0x01 0x02 0x77 0xAA<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
The Bytelet class is derived from P4D. This means all Bytelets are also
P4D objects. The Bytelet method hex() is new and Bytelet specific. It
enables serialization of Bytelets as hexacdecimal numbers. The LEN
object we assigned to the Len field as a Python object is one of two
builtin Flow objects. The other one is called VAL. We will treat them
in detail in section 2.2.<br>
      <h2><a class="mozTocH1" name="mozTocId237510"></a>2.1
Bytelets and Hex objects</h2>
The content of P4D objects are all strings. We assign either strings or
numbers and numbers will be converted into strings. Bytelets are
somewhat more featureful in this hindsight. We can also assign Flow
objects like LEN as seen in the example above but also hexadecimal
literals which have a special status.<br>
      <br>
In P4D 1.2 we have broken Pythons semantics for hexadecimal numbers.
When you type a hexadecimal number in a Python console its base is
automatically converted into that of a decimal number:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
0x0E<br>
14<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
So hexadecimal numbers don't have a proper status but their base
changes automatically. In P4D 1.2 hex literals will not be mapped onto
Python ints but on Hex objects that are defined <small><span
 style="font-family: Courier New,Courier,monospace;"></span></small>in <small><span
 style="font-family: Courier New,Courier,monospace;">EasyExtend.util.hexobject</span></small>.
Hex objects are used to store, manipulate and represent hexcode. <br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
0x0E 0xA0<br>
            </small><small>0x0E 0xA0<br>
p4d&gt; type(</small><small>0x0E 0xA0)<br>
&lt;class 'EasyExtend.util.hexobject.Hex'&gt;<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
Hex objects have plenty of conversion functions and representations:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
Hex("89 07 0A")<br>
0x89 0x07 0x0A<br>
            </small><small><br>
p4d&gt; Hex.format =
Hex.F_STD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # changing the
representation format for Hex objects<br>
            <br>
p4d&gt; </small><small>Hex("89 07 0A")<br>
89 07 0A<br>
            <br>
            </small><small>p4d&gt; Hex.format =
Hex.F_0x &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # changing the
representation format for Hex objects again<br>
            </small><br>
            <small>p4d&gt;
Hex(0x89070A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# another constructor call<br>
            </small><small>0x89 0x07 0x0A<br>
            <br>
p4d&gt; Hex("89 {Hello Hex} 00")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # curly
braces are used to inline ASCII - strings<br>
0x89 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x48 0x65 0x78 0x00<br>
            <br>
            </small><small>p4d&gt; Hex("89 {escape\{ and
\}}")&nbsp;&nbsp; # inlined curlies<br>
0x89 0x65 0x73 0x63 0x61 0x70 0x65 0x7B 0x20 0x61 0x6E 0x64 0x20 0x7D<br>
            <br>
            </small><small>p4d&gt; Hex.from_decimal("16")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # string conversion from decimals
obviously differs from ...<br>
0x10<br>
            </small><small><br>
p4d&gt; Hex("16") &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; # ... interpretation as Hex<br>
0x16<br>
            <br>
p4d&gt; Hex("{Hex Hex}0").binary()&nbsp;&nbsp;&nbsp; # sort of
0-terminated string<br>
'Hex Hex\x00'<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
Of course we have plenty of operations we can apply immediately to Hex
object literals<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
h = 0x0E 0xA0 </small><small><br>
p4d&gt; h //
0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;&nbsp; &nbsp; # concatenation</small><small><br>
            </small><small>0x0E 0xA0 0x00<br>
            </small><small>p4d&gt; 0x0E + 0x03
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# addition<br>
0x11<br>
            </small><small>p4d&gt; p4d&gt; 0x0E 0x89 0x89 &amp; 0x78
0x75
0x56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>#
bitwise and</small><br>
            <small>0x08 0x01 0x00<br>
            </small><small>p4d&gt; p4d&gt; 0x0E 0x89 0x89 ^ 0x78 0x75
0x56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>#
xor</small><br>
            <small>0x76 0xFC 0xDF</small><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
For a more comprehensive overview you have to look at tha API
description of the Hex object.<br>
      <h2><a class="mozTocH2" name="mozTocId993466"></a>2.2 Flow objects</h2>
      <h3><a class="mozTocH3" name="mozTocId203530"></a>2.2.1 Anatomy
of a Flow object<br>
      </h3>
The Flow object is the key feature of Bytelets. One can understand a
Flow object roughly by considering three properties. A Flow object has<br>
      <br>
1) an internal state which is expressed by the <small
 style="font-family: Courier New,Courier,monospace;">_value</small>
attribute. The <small
 style="font-family: Courier New,Courier,monospace;">_value</small>
attribute can be accessed using the <small><span
 style="font-family: Courier New,Courier,monospace;">flow_value()</span></small>&nbsp;
      <br>
&nbsp;&nbsp;&nbsp; method. The type of <small
 style="font-family: Courier New,Courier,monospace;">_value</small> is
Hex. On initialization <small
 style="font-family: Courier New,Courier,monospace;">_value</small> is
None.<br>
      <br>
2) a reference to the containing Bytelet. A Flow object is usually the <small><span
 style="font-family: Courier New,Courier,monospace;">CONTENT</span></small>
of a Bytelet having the following simple <br>
&nbsp;&nbsp;&nbsp; structure&nbsp; <small><span
 style="font-family: Courier New,Courier,monospace;">[TAG, {}, [],
CONTENT]</span></small>.&nbsp; We aren't so much interested in this
containing Bytelet though but in its parent: <br>
&nbsp;&nbsp;&nbsp; <small><span
 style="font-family: Courier New,Courier,monospace;">[TAG, {}, [</span></small><small><span
 style="font-family: Courier New,Courier,monospace;">[TAG, {}, [],
CONTENT]...</span></small><small><span
 style="font-family: Courier New,Courier,monospace;">], '']</span></small>.
The containing Bytelet and the parent of the containing Bytelet are <br>
&nbsp;&nbsp;&nbsp; represented by the Flow attributes <small><span
 style="font-family: Courier New,Courier,monospace;">_node</span></small>
and <small><span style="font-family: Courier New,Courier,monospace;">_parent</span></small>.<br>
      <br>
3) an <small style="font-family: Courier New,Courier,monospace;">update()</small>
method. The <small style="font-family: Courier New,Courier,monospace;">update()</small>
method is either called when a <small
 style="font-family: Courier New,Courier,monospace;">_value</small>
attribute is demanded and is <small
 style="font-family: Courier New,Courier,monospace;">_value </small>None
      <br>
&nbsp;&nbsp;&nbsp; or it is called when a Bytelet changes e.g. when a
field gets updated using __setattr__. The update() method implements
the <br>
&nbsp;&nbsp;&nbsp; behaviour of the Flow object. It is the distinctive
property of flow objects and shall be overridden in subclasses of Flow.<br>
      <br>
Coming back to our initial example.<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
elm bl:A:<br>
....&nbsp;&nbsp;&nbsp; Tag:0x01<br>
....&nbsp;&nbsp;&nbsp; Len:&amp;LEN<br>
....&nbsp;&nbsp;&nbsp; Val:0x77<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
The LEN object is a Flow object assigned to Len as a Python object.
Actually LEN is of type FlowLen and it is a global or builtin Flow
object. On assignment to Len it will be copied. So you can use it in
arbitrary many places without danger of sharing its value. Initially
the attribute values are all None.<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
import pprint<br>
p4d&gt; pprint.pprint(A._tree)<br>
['bl:A',<br>
&nbsp;{},<br>
&nbsp;[['Tag', {}, [], 0x01],<br>
&nbsp; ['Len',<br>
&nbsp;&nbsp; {},<br>
&nbsp;&nbsp; [],<br>
&nbsp;&nbsp; &lt;EasyExtend.langlets.p4d.bytelet.FlowLen object at
0x014E40B0&gt;],<br>
&nbsp; ['Val', {}, [], 0x77]],<br>
&nbsp;'']<br>
p4d&gt;<br>
p4d&gt; flow = p4d&gt; A._tree[2][1][-1]<br>
p4d&gt; flow</small><small><br>
p4d&gt; assert </small><small>flow._value is None<br>
p4d&gt; assert flow._node is None<br>
            </small><small>p4d&gt; assert flow._parent is None</small><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
This changes when we try to compute the hex value of Len:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
A.Len.hex()<br>
0x01<br>
p4d&gt; flow._value<br>
0x01<br>
p4d&gt; flow._node<br>
Bytelet&lt;Len&gt;<br>
            </small><small>p4d&gt; flow._parent<br>
Bytelet&lt;bl:A&gt;</small><br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <h3><a class="mozTocH3" name="mozTocId554940"></a>2.2.2 How <small
 style="font-family: Courier New,Courier,monospace;">LEN</small> works<br>
      </h3>
The <small style="font-family: Courier New,Courier,monospace;">update()</small>
method of LEN locates <small><span
 style="font-family: Courier New,Courier,monospace;">_node</span></small>
with <small><span style="font-family: Courier New,Courier,monospace;">_parent</span></small>
and computes the sum of the lengths of all subsequent fields So it is
roughly:<br>
      <small style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
children = _parent.children()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum( len(field.hex()) for field in
children[children.index(_node)+1:]))<br>
      <br>
      </small>Notice that LEN._value is BER encoded: <br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If
len(_value) &gt; 0x80 then the first byte of the _value encodes the
number of subsequent bytes used to store the length value.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The
most significant bit is always set in this case ( most significant
=&nbsp; left most bit in the bitmap
representation of a <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
number where the powers of 2 are ordered from left to right).<br>
      <br>
Examples:<br>
      <br>
      <table style="text-align: left; width: 440px; height: 116px;"
 border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">len(_value)</span><br>
            </td>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">BER encoding</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0x78<br>
            </td>
            <td style="vertical-align: top;">0x78<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0xA2<br>
            </td>
            <td style="vertical-align: top;">0x81 0xA2<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0x12F<br>
            </td>
            <td style="vertical-align: top;">0x82 0x01 0x2F<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
With this scheme one can encode byte streams up to a length of 2<sup>120</sup>.
This shall be sufficient for most practical purposes.<br>
      <br>
      <h3><a class="mozTocH3" name="mozTocId188697"></a>2.2.3 <small><small><small><small
 style="font-family: Courier New,Courier,monospace;">LEN</small></small></small></small>
and&nbsp; <small><small
 style="font-family: Courier New,Courier,monospace;">RAWLEN</small></small></h3>
Sometimes a BER encoded length field is inappropriate and we just want
to count the raw number of bytes within fixed bounds. In those cases we
use <small style="font-family: Courier New,Courier,monospace;">RAWLEN</small>.
      <br>
      <br>
      <span style="font-weight: bold;">Example:</span> for a length
field having a fixed length of 2 we have following encodings:<br>
      <br>
      <table style="text-align: left; width: 440px; height: 116px;"
 border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">len(_value)</span><br>
            </td>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">LEN</span><br>
            </td>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">RAWLEN</span></td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0x78<br>
            </td>
            <td style="vertical-align: top;">0x78<br>
            </td>
            <td style="vertical-align: top;">0x00 0x78<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0xA2<br>
            </td>
            <td style="vertical-align: top;">0x81 0xA2<br>
            </td>
            <td style="vertical-align: top;">0x00 0xA2<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">0x12F<br>
            </td>
            <td style="vertical-align: top;">-<br>
            </td>
            <td style="vertical-align: top;">0x01 0x2F<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
      <h3><a class="mozTocH3" name="mozTocId416380"></a>2.2.4&nbsp; <small
 style="font-family: Courier New,Courier,monospace;">LEN</small>
Expressions<br>
      </h3>
Computing the length of all fields subsequent to the Bytelet containing
LEN is the most common application of Flow objects in Bytelets. But
sometimes one might want to compute just the length of a particular
field or the length of two adjecent fields, one with a fixed size and
one with a variable size.<br>
      <br>
All those cases one can new Flow objects from LEN by applying simple
arithmetic operations or subscripting.<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
elm bl:A:<br>
....&nbsp;&nbsp;&nbsp; Tag:0x01<br>
....&nbsp;&nbsp;&nbsp; Len:&amp;LEN<br>
....&nbsp;&nbsp;&nbsp; DCS:0x04<br>
....&nbsp;&nbsp;&nbsp; Text: "{some bytelet text}"<br>
p4d&gt;<br>
p4d&gt; A.Len.hex()<br>
0x12<br>
            </small> </td>
          </tr>
        </tbody>
      </table>
      <br>
This is what we already know. But we can extend it:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
A.Len = LEN["Text"]<br>
p4d&gt; A.Len.hex()<br>
0x11<br>
            </small> </td>
          </tr>
        </tbody>
      </table>
      <br>
or<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
A.Len = LEN["Text"]+1<br>
p4d&gt; A.Len.hex()<br>
0x12<br>
            </small> </td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
Supported operations:<br>
      <br>
      <table style="text-align: left; width: 440px; height: 116px;"
 border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">operator</span><br>
            </td>
            <td style="vertical-align: top; text-align: center;"><span
 style="font-weight: bold;">operand type</span><br>
            </td>
          </tr>
          <tr>
            <td
 style="vertical-align: top; font-family: Courier New,Courier,monospace; text-align: center;">+
| - | * | / </td>
            <td style="vertical-align: top;">int<br>
            </td>
          </tr>
          <tr>
            <td
 style="vertical-align: top; font-family: Courier New,Courier,monospace; text-align: center;">[]<br>
            </td>
            <td style="vertical-align: top;">string<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
Same operations are valid for RAWLEN.<br>
      <br>
      <h2><a class="mozTocH2" name="mozTocId851966"></a>2.3&nbsp;
Bytelet Schemas<br>
      </h2>
Bytelet Schemas are Bytelets used to parse hexcode into other Bytelets.
Often Bytelet Schemas are <span style="font-style: italic;">isomorphic</span>
with target Bytelets i.e. they have the same structure but different
values. This isn't very much different from using a structure type in C
for casting on an array and produce a new C struct. There are different
types of Schemas but two of them are the most relevant. The first is
called <span style="font-style: italic;">Standard Schema</span> and
the second one <span style="font-style: italic;">TLVList Schema</span>.
These shall be treated in more detail now.<br>
      <h3><a class="mozTocH3" name="mozTocId547924"></a><a
 class="mozTocH3" name="mozTocId385456"></a>2.3.1&nbsp; The
Standard Schema</h3>
A Schema for the Bytelet<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl:A:<br>
&nbsp;&nbsp; Tag:0x01<br>
&nbsp;&nbsp; Len:&amp;LEN<br>
&nbsp;&nbsp; DCS:0x04<br>
&nbsp;&nbsp; Text: "{some bytelet text}"<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
looks like this<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:AS:<br>
&nbsp;&nbsp; Tag: 1<br>
&nbsp;&nbsp; Len: &amp;LEN<br>
&nbsp;&nbsp; DCS: 1<br>
&nbsp;&nbsp; Text: &amp;VAL -1 <br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
Now we can use the AS Schema and parse a Hex object. <br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>p4d&gt;
R = AS.parse( A.hex() )<br>
p4d&gt; R<br>
Bytelet&lt;bl:AS&gt;<br>
p4d&gt; R.DCS.hex()<br>
0x04<br>
p4d&gt; R.Text.hex().ascii()<br>
"some bytelet text"<br>
            <br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
The Standard Schema defines a new namespace defined by<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(255, 255, 255); vertical-align: top;"><small>&nbsp;
prefix: bl-schema<br>
&nbsp; uri: http://fiber-space.de/byteletschemans<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
It corresponds with a new class ByteletSchema which is derived from
Bytelet and implements the single public method<br>
      <br>
      <h3><a class="mozTocH3" name="mozTocId348080"></a>2.3.1.1&nbsp;
How <small><span style="font-family: Courier New,Courier,monospace;">VAL</span></small>
works<br>
      </h3>
The <small><span style="font-family: Courier New,Courier,monospace;">VAL</span></small>
object is <small><span
 style="font-family: Courier New,Courier,monospace;">FlowFieldVal</span></small>
instance. It is complementary to <small><span
 style="font-family: Courier New,Courier,monospace;">LEN</span></small>
and it is used in Schemas only. The functionality is this: <small><span
 style="font-family: Courier New,Courier,monospace;">VAL</span></small>
refers to a <small><span
 style="font-family: Courier New,Courier,monospace;">LEN</span></small>
field and when the _value of the <small><span
 style="font-family: Courier New,Courier,monospace;">LEN</span></small>
field is k, k bytes will be read from the hexcode stream and assigned
to <small><span style="font-family: Courier New,Courier,monospace;">Text</span></small>._value.
      <br>
      <br>
In the last example the value read from the <small><span
 style="font-family: Courier New,Courier,monospace;">A.hex()</span></small>
for <small><span style="font-family: Courier New,Courier,monospace;">LEN</span></small>
was <small><span style="font-family: Courier New,Courier,monospace;">0x12</span></small>.
Therefore <small><span
 style="font-family: Courier New,Courier,monospace;">VAL-1</span></small>
was <small><span style="font-family: Courier New,Courier,monospace;">0x11</span></small>
and as much bytes were read from <small><span
 style="font-family: Courier New,Courier,monospace;">A.hex()</span></small>.
As for <small><span style="font-family: Courier New,Courier,monospace;">LEN</span></small>
which might refer to a particular field <small><span
 style="font-family: Courier New,Courier,monospace;">F</span></small>
via <small><span style="font-family: Courier New,Courier,monospace;">LEN["F"]</span></small>
a reference can be used with <small><span
 style="font-family: Courier New,Courier,monospace;">VAL</span></small>:
      <small><span style="font-family: Courier New,Courier,monospace;">VAL["F"]</span></small>
reads <small><span style="font-family: Courier New,Courier,monospace;">F.hex()</span></small>
bytes<small><span style="font-family: Courier New,Courier,monospace;"></span></small>.<small><span
 style="font-family: Courier New,Courier,monospace;"></span></small><br>
      <br>
      <h3><a class="mozTocH3" name="mozTocId701690"></a>2.3.2&nbsp; The
      <small><span style="font-family: Courier New,Courier,monospace;">tlvlist</span></small>
Schema</h3>
A ByteletSchema element specifies an attribute <small><span
 style="font-family: Courier New,Courier,monospace;">use</span></small>.
If <small><span style="font-family: Courier New,Courier,monospace;">use</span></small>
is omitted than the value <small><span
 style="font-family: Courier New,Courier,monospace;">std</span></small>
is implied. Another value is <small
 style="font-family: Courier New,Courier,monospace;">tlvlist</small>. A
      <br>
      <small style="font-family: Courier New,Courier,monospace;">tlvlist</small>
value changes the way a hexcode object is parsed.<br>
      <br>
When a tlvlist Schema is used it is assumed that a TLV object has a
tree structure with TLV objects specified by sub-TLVs and their tags. <br>
      <br>
      <span style="font-weight: bold;">Example 1:</span><br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:A(use="tlvlist"):<br>
&nbsp;&nbsp; TLV(tag = 0x00):<br>
&nbsp; &nbsp;&nbsp; &nbsp; SubTLV1(tag = 0x01)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>SubTLV2(tag =
0x02):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubSubTLV1(tag = 0x00)<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubSubTLV2(tag = 0x01)</small><br>
            <small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SubTLV3(tag =
0x03)<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
There are some default assumptions being made about tlvlist Schemas
when parsing hexcode. Those are<br>
      <br>
      <ol>
        <li>A TLV object is uniquely specified by its tag within a TLV
structure. So the sequence of occurence in the tlvlist Schema is
arbitrary.The schema specified above is the same as </li>
      </ol>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: left;">&nbsp;<br>
            </td>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:A(use="tlvlist"):<br>
&nbsp;&nbsp; TLV(tag = 0x00):<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>SubTLV2(tag
= 0x02):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubSubTLV1(tag = 0x00)<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubSubTLV2(tag = 0x01)</small><br>
            <small>&nbsp; &nbsp;&nbsp; &nbsp; SubTLV1(tag = 0x01)<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubTLV3(tag = 0x03)<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
      <ol start="2">
        <li>A TLV object may occur arbitrary many times within a
hexcode object. You can interpret the presence of an a sub-TLV
specifier as: zero or more occurences in the target.</li>
        <li>If some unknown tag is found it will not be ignored but
some Bytelet with tag UNDEF is created.</li>
      </ol>
You see that the parsing rules are rather liberal. There isn't much
checked by the parser except for consistency with a nested TLV
structure. This keeps the Schema simple and delegates more
responsibilities to Python libraries. <br>
      <br>
Notice further that definitions where a tag-name occurs more than once
are permitted:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:B(use="tlvlist"):<br>
&nbsp;&nbsp; TLV(tag = 0x00):<br>
&nbsp; &nbsp;&nbsp; &nbsp; Sub(tag = 0x01)<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sub(tag
= 0x02)<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
      <h3><a class="mozTocH3" name="mozTocId940395"></a>2.3.2.1&nbsp;
Mixing the Schema modes<small><span
 style="font-family: Courier New,Courier,monospace;"></span></small><br>
      </h3>
You can flip the schema mode as shown below <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:C(use="tlvlist"):<br>
&nbsp;&nbsp; TLV(tag = 0x00):<br>
&nbsp; &nbsp;&nbsp; &nbsp; SubTLV1(tag = 0x01)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>SubTLV2(tag = 0x02
use = "std"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tag: 0x02<br>
            </small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Len: &amp;LEN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DCS: 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextLen: 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text:
&amp;VAL<br>
            </small> <small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubTLV3(tag = 0x03)<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
It is also possible to refer to another Schema this way and assamble a
Schema:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:TextSchema:<br>
            </small><small>&nbsp;&nbsp;&nbsp; Tag: 0x02<br>
            </small><small>&nbsp;&nbsp;&nbsp; Len: &amp;LEN<br>
&nbsp;&nbsp;&nbsp; DCS: 1<br>
&nbsp;&nbsp;&nbsp; TextLen: 1<br>
&nbsp;&nbsp;&nbsp; Text: &amp;VAL<br>
            </small> <small><br>
            </small><small>elm
bl-schema:D(use="tlvlist"):<br>
            </small><small></small><small>&nbsp;&nbsp; TLV(tag = 0x00):<br>
&nbsp; &nbsp;&nbsp; &nbsp; SubTLV1(tag = 0x01)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </small><small>SubTLV2(tag = 0x02
use = "std"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;TextSchema<br>
            </small><small></small><small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SubTLV3(tag = 0x03)</small><br>
            <br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <h1><a class="mozTocH1" name="mozTocId287682"></a>3. Playing with
Bits</h1>
In section 2 we have seen how Bytelets can be used to specify
structures and TLV objects on byte arrays. Now we move to individual
bits and bit arrays. Specifying bitarrays requires a little more
notation.<br>
      <br>
      <h2><a class="mozTocH2" name="mozTocId532467"></a>3.1 Bin objects</h2>
Unlike Hex objects which encapsulate operations on arrays of bytes a
Bin object is just a subclass of int with some notational convention
that are used to specify bit arrays. <br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
0b89&nbsp;&nbsp;&nbsp; # this creates a Bin object<br>
0b89<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
With Bin objects we can specify ByteletSchemas on a finer level:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl-schema:OneByte:<br>
&nbsp;&nbsp;&nbsp; F1: 0b1<br>
&nbsp;&nbsp;&nbsp;
F2: 0b3<br>
&nbsp;&nbsp;&nbsp; F3: 0b4<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
With the OneByte Schema we parse a single byte:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
btl = OneByte.parse(0x85)<br>
&gt;&gt;&gt; btl.F1.hex()<br>
0x01<br>
&gt;&gt;&gt; btl.F2.hex()<br>
0x00<br>
            </small><small>&gt;&gt;&gt; btl.F5.hex()<br>
0x05<br>
&gt;&gt;&gt; btl.hex()<br>
0x85<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
In order to fit the three field values 0x01, 0x00 and 0x05 in the hex
method of btl together in a precise way ( i.e. other than 0x01 0x00
0x05 ) the Bytelet object has to store the bitarray characteristics in
the fields. This is done using the <span style="font-weight: bold;">w</span>(idth)
attribute:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
btl.F1.@w<br>
0b1<br>
&gt;&gt;&gt; btl.F2.@w<br>
0b3<br>
            </small><small>&gt;&gt;&gt; btl.F3.@w<br>
0b4<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
Of course one can start with a Bytelet which predefined widths:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>elm
bl:btl:<br>
&nbsp;&nbsp;&nbsp; Tag(w=0b4): 0x07<br>
&nbsp;&nbsp;&nbsp; Len(w=0b16): &amp;RAWLEN<br>
&nbsp;&nbsp;&nbsp; DCS(w=0b4): 0x04<br>
&nbsp;&nbsp;&nbsp; </small><small>Text: "{Some Text}"<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
We get <br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
btl.hex()<br>
0x70 0x00 0xA4 0x53 0x6F 0x6D 0x65 0x20 0x54 0x65 0x78 0x74<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
Note that using RAWLEN instead of LEN has no meaning in this example.
It is just the recommended way to assign length fields in cases of
fixed sized length fields.<br>
      <h2><a class="mozTocH2" name="mozTocId854075"></a>3.2 Sort of
runtime type checks</h2>
Currently there are no checks when you assign values to fields and P4D
won't complain when you set:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>...&nbsp;&nbsp;
Tag(w=0b4): 0x100<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
However evaluation of hex() will check whether the assigned Hex object
values are within the bounds of the specified bit arrays. Otherwise as
TypeError exception is raised:<br>
      <br>
      <table
 style="background-color: rgb(255, 255, 239); font-family: courier new; width: 793px; height: 29px; text-align: left;"
 border="0" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="background-color: rgb(236, 236, 236); vertical-align: top;"><small>&gt;&gt;&gt;
btl.Tag = 0x100<br>
&gt;&gt;&gt; btl.hex()<br>
Traceback (most recent call last):<br>
...<br>
TypeError: Hex object 0x100 does not fit into a 4 bit array.<br>
            </small></td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
      <h1><a class="mozTocH1" name="mozTocId329178"></a>4. History</h1>
      <table style="text-align: left; width: 785px; height: 68px;"
 border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td
 style="vertical-align: top; text-align: left; background-color: rgb(240, 240, 240);"><span
 style="font-weight: bold;">Date</span><br>
            </td>
            <td
 style="vertical-align: top; text-align: left; background-color: rgb(240, 240, 240);"><span
 style="font-weight: bold;">Version</span><br>
            </td>
            <td
 style="vertical-align: top; text-align: left; background-color: rgb(240, 240, 240);"><span
 style="font-weight: bold;">Change</span><br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">2008-08-08</td>
            <td style="vertical-align: top;">1.2<br>
            </td>
            <td style="vertical-align: top;">
            <ul>
              <li>One can now set attribute values and content easily
without referring to the internal datastructure.</li>
              <li>Introduction of Bytelets and the <span
 style="font-style: italic;">bl</span> namespace which is supported on
language level.</li>
              <li>Introduction of ByteletSchema objects and the <span
 style="font-style: italic;">bl-schema</span> namespace which is
supported on
language level.</li>
              <li>Adding a Hex object context.<br>
              </li>
              <li><small><span
 style="font-family: Courier New,Courier,monospace;">elm foo:bar</span></small><small><span
 style="font-family: Courier New,Courier,monospace;">:</span></small>
... works like an assignment&nbsp; <small><span
 style="font-family: Courier New,Courier,monospace;">bar = </span></small><small><span
 style="font-family: Courier New,Courier,monospace;">foo:bar:</span></small>...
which is valid for all non keywords and non hyphened
names.<br>
              </li>
            </ul>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">2008-07-11</td>
            <td style="vertical-align: top;">1.1.1<br>
            </td>
            <td style="vertical-align: top;">
            <ul>
              <li>Fix: remove py4as3 import from xmlutils and p4dbase<br>
              </li>
            </ul>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">2008-07-11</td>
            <td style="vertical-align: top;">1.1</td>
            <td style="vertical-align: top;">
            <ul>
              <li>Fix XML formatAttributes() in xmlutils.</li>
              <li>Make locals() available for mapeval.<br>
              </li>
              <li>Add flexutils module</li>
              <li>Add elm keyword</li>
              <li>Add P4D comments</li>
              <li>Fix double-colon access for namespaces with p4d
prefix.</li>
              <li>Add element lists or tuples.</li>
              <li>Add P4D.eval()</li>
              <li>Add CDATA handling</li>
              <li>Change filter semantics<br>
              </li>
            </ul>
            </td>
          </tr>
          <tr>
            <td
 style="vertical-align: top; background-color: rgb(250, 250, 250);">2008-06-26<br>
            </td>
            <td style="vertical-align: top;">1.0<br>
            </td>
            <td style="vertical-align: top;">Initial release<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <hr style="width: 100%; height: 2px;"></td>
    </tr>
  </tbody>
</table>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
<br>
</body>
</html>
