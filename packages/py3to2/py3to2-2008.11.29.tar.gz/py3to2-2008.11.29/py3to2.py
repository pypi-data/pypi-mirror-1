"""
AUTHOR
  kai zhu
  kaizhu@ugcs.caltech.edu

REQUIREMENTS
  - posix/unix os (Windows currently unsupported)
  - w/ python2.6 & python3.0 installed

INSTALL
  $ python2.6 setup.py build
  $ python2.6 setup.py install
  $ python2.6 setup.py dev --quicktest
  $ python2.6 setup.py dev --py2to3test ## takes awhile to finish

  the above will build & install 3 files:
  - extended python2.6 interpreter: bin/py3to2
  - initialization script:          lib/python2.6/site-packages/py3to2_init.py
  - python3.0 bytecode compiler:    lib/python2.6/site-packages/py3to2.py

################################################################################
ABSTRACT

py3to2 is a python2.6 interpreter w/ extended python3.0 opcodes, allowing it to
natively run python3.0 & 2to3 generated scripts. it should b
mostly backwards-compatible w/ cpython2.6 & its extensions.

the intended purpose is to allow developers to migrate python2.6 scripts to
python3.0 while retaining backwards compatibility w/ existing extension modules.
py3to2 coexists w/ ur existing python2.6 installation (it consists of 3 files)

for a real-world py3to2 app (python3.0 script using 2.6 extension modules),
checkout img2txt: http://pypi.python.org/pypi/img2txt

MECHANISM

py3to2 has 3 components:
- py3to2
  python interpreter. can evaluate python2.6 bytecode containing additional
  python3.0 opcode instructions

- py3to2_init.py
  initialization script.  sets up import hook for recognizing python3.0 scripts

- py3to2.py
  bytecode compiler. the compile process takes 2 steps:
  - a persistent python3.0 process is created for compiling scripts into
    python3.0 code
  - py3to2.py then converts the code from python3.0 to python2.6 format

MANIFEST

./patch/ - patched files
./py3to2.diff - summary of patches (maybe out-of-date)

################################################################################
MAGIC
  simply add the MAGIC LINE:

    from __future__ import py3k_syntax

  to make py3to2 aware that a script is using python3.0 syntax

PSEUDOMETHOD
  py3to2 supports ".." syntax notation for pseudomethods
  goto: http://pypi.python.org/pypi/pseudomethod
  for more details about this feature

2TO3
  py3to2 includes convenience functions for automatically generating &
  testing scripts using 2to3:
  - class py2to3:
    - __call__ - overwrites file w/ one generated by 2to3
    - overwrite_and_load_module - overwrites file & then attempt to import it
    - test_stdlib - given a directory containing a copy of python2.6's
                    standard library, it will overwrite them using 2to3 & then
                    attempts to load each file

API: try help(py3to2)  ^_-

  py3to2 module:
  - class codetree - mutable codeobj & disassembler/assembler/debugger
  - class compiler - compiling tools
  - python3.0 wrappers:
    - py3k_compile() - compile python3.0 src
    - py3k_eval() - eval py3thon3.0 src
    - py3k_exec() - exec python3.0 src

USAGE
  start up the py3to2 interpreter by typing "py3to2" in ur shell:
    $ py3to2

    Python 2.6.py3to2 (r26:66714, Nov 18 2008, 00:56:43)
    [GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>>

  try out this simple python3.0 script:
    ################################################################
    ## PEP3132  Extended Iterable Unpacking
    ## copy this to file test_pep3132.py

    from __future__ import py3k_syntax

    a,*b = 1,2,3
    assert a == 1 and b == [2,3]
    print(a,b)
    ################################################################
    >>>
    >>> import test_pep3132
    created...
    py3k server starting...
    ...py3k server started w/...

    1 [2, 3]

  here's another python3.0 script using scipy (python2.6) extension module:
    ################################################################
    ## u must have scipy installed for this script to work
    ## copy this to file test_pep3132_scipy.py

    from __future__ import py3k_syntax

    import scipy
    a,*b = scipy.array([1,2,3])
    assert a == 1 and b == [2,3]
    print(a,b)
    ################################################################
    >>>
    >>> import test_pep3132_scipy
    1 [2, 3]

  another simple, but more thorough test script, test_py3k,
  is included w/ this distribution:
    >>>
    >>> import test_py3k
    testing PEP3102  Keyword-Only Arguments
    testing PEP3104  Access to Names in Outer Scopes
    testing PEP3105  Make print a function
    testing PEP3107  Function Annotations
    testing PEP3112  Bytes literals in Python 3000
    testing PEP3113  Removal of Tuple Parameter Unpacking
    testing PEP3114  Renaming iterator.next() to .__next__()
    testing PEP3115  Metaclasses in Python 3000
    testing PEP3120  Using UTF-8 as the default source encoding
    testing PEP3127  Integer Literal Support and Syntax
    testing PEP3129  Class Decorators
    testing PEP3131  Supporting Non-ASCII Identifiers
    testing PEP3132  Extended Iterable Unpacking
    testing PEP3135  New Super
    testing pseudomethod example 0
    testing pseudomethod example 1
    testing pseudomethod example 2
    testing pseudomethod example 3
    testing numpy example

FEATURES
  PEP3102  Keyword-Only Arguments
  PEP3104  Access to Names in Outer Scopes
  PEP3105  Make print a function
  PEP3107  Function Annotations
  PEP3111  Simple input built-in in Python 3000
  PEP3112  Bytes literals in Python 3000
  PEP3113  Removal of Tuple Parameter Unpacking
  PEP3114  Renaming iterator.next() to .__next__()
  PEP3115  Metaclasses in Python 3000
  PEP3120  Using UTF-8 as the default source encoding
  PEP3127  Integer Literal Support and Syntax
  PEP3129  Class Decorators
  PEP3131  Supporting Non-ASCII Identifiers
  PEP3132  Extended Iterable Unpacking
  PEP3135  New Super

UNICODE SUPPORT
  py3to2 will only load ascii & utf8-encoded scripts
  (utf8 is the default encoding in python3.0).

  although they're illegal in python3.0, for backwards-compatibility sake,
  py3to2 supports unicode literals for explicit <unicode> obj creation:

    u"\u1234" is an explicit <unicode> obj (note unicode literal in front)
     "\u1234" is NOT a <unicode> obj when converted back to python2.6

  note also the following r equivalent under python2.6:

    u"\u1234"  <==>  "\u1234".decode("raw_unicode_escape")

  so u MUST do either u"..." or "...".decode("raw_unicode_escape")
  to create explicit <unicode> obj in py3to2.

LIMITATIONS (FEATURES NOT FULLY SUPPORTED)
  except for the aforementioned unicode issue, from a migration standpoint,
  py3to2 is mostly feature complete in terms of python3.0's language syntax,

  language issue aside, python3.0 scripts will still behave differently b/c of
  internal differences between python2.6 & python3.0:
  - exception handling.  py3to2 implements python3.0 syntax for raising &
    catching exceptions.  but the underlying behavior is still python2.6
  - builtin functions / types.  a few of these have become different beasts
    under python3.0

################################################################################
PYTHON2.6 COMPATIBILITY TEST
  $ python setup.py dev --maketest
  ...
  test_sys
  test test_sys failed -- Traceback (most recent call last):
    File ".../Python-2.6/Lib/test/test_sys.py", line 487, in test_objecttypes
      check(get_cell().func_code, size(h + '4i8Pi2P'))
    File ".../Python-2.6/Lib/test/test_sys.py", line 423, in check_sizeof
      self.assertEqual(result, size, msg)
  AssertionError: wrong size for <type 'code'>: got 128, expected 120
  ...
  323 tests OK.
  1 test failed:
      test_sys
  36 tests skipped:
      test_aepack test_al test_applesingle test_bsddb185 test_bsddb3
      test_cd test_cl test_codecmaps_cn test_codecmaps_hk
      test_codecmaps_jp test_codecmaps_kr test_codecmaps_tw test_curses
      test_dl test_gdbm test_gl test_imageop test_imgfile test_kqueue
      test_linuxaudiodev test_macos test_macostools test_normalization
      test_ossaudiodev test_pep277 test_py3kwarn test_scriptpackages
      test_socketserver test_startfile test_sunaudiodev test_timeout
      test_urllib2net test_urllibnet test_winreg test_winsound
      test_zipfile64
  1 skip unexpected on linux2:
      test_gdbm
  completed 2.6 (r26:66714, Dec  2 2008, 00:54:55)
  [GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] regression tests

2TO3 COMPATIBILITY TEST
  $ python setup.py dev --py2to3test
  ...
  tested 200 2to3 generated scripts from 2.6.py3to2 (r26:66714, Dec  2 2008, 00:54:55)
  [GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] standard library

  0 skipped:


  23 couldn't import required modules:
  BaseHTTPServer CGIHTTPServer cgi cookielib copy dummy_threading HTMLParser httplib macurl2path mimetypes os pdb pydoc re robotparser sgmllib SimpleHTTPServer SimpleXMLRPCServer _strptime tempfile threading urllib2 urllib

  6 were non-utf8 compliant scripts:
  base64 getopt heapq shlex smtpd tarfile

  14 failed import due to other reasons:
  anydbm dbhash doctest fractions _LWPCookieJar _MozillaCookieJar pickle sets socket tabnanny UserList UserString whichdb xmlrpclib

  158 passed import:
  _abcoll abc aifc ast asynchat asyncore atexit audiodev Bastion bdb binhex bisect calendar cgitb chunk cmd codecs codeop code collections colorsys commands compileall ConfigParser contextlib Cookie copy_reg cProfile csv decimal difflib dircache dis DocXMLRPCServer dumbdbm dummy_thread filecmp fileinput fnmatch formatter fpformat ftplib functools __future__ genericpath getpass gettext glob gzip hashlib hmac htmlentitydefs htmllib ihooks imaplib imghdr imputil inspect io keyword linecache locale macpath mailbox mailcap markupbase md5 mhlib mimetools MimeWriter mimify modulefinder multifile mutex netrc new nntplib ntpath nturl2path numbers opcode optparse os2emxpath __phello__.foo pickletools pipes pkgutil platform plistlib popen2 poplib posixfile posixpath pprint profile pstats pty pyclbr py_compile pydoc_topics Queue quopri random repr rexec rfc822 rlcompleter runpy sched sha shelve shutil site smtplib sndhdr SocketServer sre_compile sre_constants sre_parse sre ssl stat statvfs StringIO stringold stringprep string struct subprocess sunaudio sunau symbol symtable telnetlib textwrap this _threading_local timeit toaiff tokenize token traceback trace tty types unittest urlparse UserDict user uuid uu warnings wave weakref webbrowser xdrlib xmllib zipfile

################################################################################
RECENT CHANGES:
20081129 - major revision
  PyCodeObject now has kwonlyargcount attr
  - breaks one regression test but greatly simplifies patch & prevents many
    future bugs
  - fixes pydoc bug
  PyFunctionObject now has __kwdefaults__ & __annotations__ attr
  ceval.c re-patched in light of above changes (much simpler)
20081128
  more documentation
  added 2to3 convenience functions
  added unicode utf-8 support
20081123
  moved pseudomethod syntax handling to py3k server
  added more checks during setup
  added more documentation
  backported patch r67299 fixing an issue w/ super()
  cleaned up py3to2.compiler class
20081120
  fixed package importing bug - py3to2 failed to import foo.bar
20081119
  created self-installing distutils distribution
20081019
  ported to python-2.6
  consolidate & simplify patches to 1 file: ceval.c
  created extension module builtins_py3k
  revamped import hook again
  removed unicode support & restrict source code to ascii-only
20080727
  revampled import hook
20080911
  consolidate patches to 2 files: bltinmodule.c & ceval.c
20080828
  add kwonlyargcount 'attr' to codeobj
  add __annotations__ & __kwdefaults__ attr to funcobj
  add __pseudomethod__ feature to baseobj
20080819
  pure python import hook - removed magic comment & use magic path instead
  revamped str & bytes handling
  revamped py3k .pyc file handling
20080802
  pep3135  New Super
20080717
  pep3107  Function Annotations
  pep3120  Using UTF-8 as the default source encoding
  pep3131  Supporting Non-ASCII Identifiers
20080713
  import / reload works transparently on py3k scripts using a magic comment
  added pep3102  Keyword-Only Arguments
20080709 added a py3k preparser
20080702
  rewrote py3k server's pipe io.  implemented partial bytearray & bytes class.
  wrote a few simple tests
20080630
  __build_class__ function to bltmodule.c.  tested class decorators to b working.
################################################################################
"""
## import py3to2; reload(py3to2); from py3to2 import *
from __future__ import print_function
__author__ =	"kai zhu"
__author_email__ =	"kaizhu@ugcs.caltech.edu"
__description__ =	"run python3.0 & 2to3 generated scripts under python2.6 w/ extension support"
__download_url__ =	None
__keywords__ =	None
__license__ =	"BSD"
__maintainer__ =	None
__maintainer_email__ =	None
__name__ = "py3to2"
__obsoletes__ =	None
__platforms__ =	None
__provides__ =	None
__requires__ =	None
__url__ = "http://www-rcf.usc.edu/~kaizhu/work/py3to2"
__version__  = "2008.11.29"
## end setup info

import io, imp, itertools, os, sys; from itertools import *
ISPY3K = True if sys.version_info[0] == 3 else None
MAGIC = "\nfrom __future__ import py3k_syntax\n"
if "DEBUG" not in globals(): DEBUG = 0 ## set to 0 to suppress printing debug info
def echo(x): return x ## useful debug function
def isascii(s):
  for x in "\t", "\n", "\r": s = s.replace(x, " ")
  return not s or " " <= min(s) <= max(s) <= "~"
def isint(x):
  try: x & 0; return True
  except: return False
def system(cmd): print( cmd ); import subprocess; return subprocess.check_call(cmd, shell = True)
def uniquestring(s, pre = "q", suf = ""): ## create a unique alphanumeric keyword in s
  keyword = str(id(s))
  while keyword in s: keyword += str(hash(keyword))
  return pre + keyword + suf


######## builtins
if ISPY3K:
  import builtins; builtins.reload = imp.reload

else: ## emulate py3k builtins
  import __builtin__, _py3to2, py3to2, py3to2_init; reload(py3to2_init)
  sys.modules["builtins"] = builtins = _py3to2
  __builtin__.__build_class__ = builtins.__build_class__
  py3k_compile = builtins.compile
  py3k_eval = builtins.eval
  py3k_exec = builtins.__dict__["exec"]

  builtins.filter = itertools.filter = ifilter
  itertools.filterfalse = ifilterfalse
  builtins.input = raw_input ## PEP3111  Simple input built-in in Python 3000
  builtins.range = xrange
  builtins.map = itertools.map = imap
  builtins.zip = itertools.zip = izip
  itertools.zip_longest = izip_longest
  from itertools import *

  def add2builtins(f):
    fname = f.__name__.replace("py3k_", "")
    f.__doc__ = getattr( getattr(__builtin__, fname, None), "__doc__", None )
    setattr(builtins, fname, f); return f
  @add2builtins
  def py3k_oct(x): return __builtin__.oct(x).replace("0", "0o", 1)
  @add2builtins
  def printiter(*args, **kwds): print( *tuple(tuple(x) if hasattr(x, "next")  else x for x in args), **kwds )

  from builtins import *; del compile, eval, globals()["exec"]
  for k, x in __builtins__.items(): ## fill in missing functions/types w/ ones from __builtin__
    if k not in builtins.__dict__ and (callable(x) or type(x) is type): setattr(builtins, k, x)



######## py3k server
if ISPY3K:
  import parser
  def server_compile(s, fpath, mode, flags, dont_inherit):
    try:
      s = s.decode("raw_unicode_escape")
      node = ast.parse(s, fpath, mode); node = parser().visit(node)
      c = builtins.compile(node, fpath, mode, flags, dont_inherit)
      t = codetree(c)
      t = t.op3to2()
      s = ascii(t)
    except Exception as e: s = ascii(e)
    sys.stdout.write(s)

else:
  import atexit, signal, subprocess
  ## tell py3k server to compile(*args, **kwds) & returns repr( <py3k codetree obj> )
  def server_compile(s, *args, **kwds): py3k_input("server_compile(b%r, *%s, **%s)" % (s, args, kwds)); s = py3k_read(); return s

  def py3k_close():
    "kill & cleanup py3k server process"
    try: os.kill(SERVER.pid, signal.SIGTERM) ## kill prev server
    except: pass
    try: map(os.close, SERVERIO) ## close prev io pipe
    except: pass
    try: del py3to2.SERVER ## prevent annoying error upon SystemExit
    except: pass
  if "SERVER" not in globals(): atexit.register(py3k_close) ## close server @ exit
  py3k_close() ## close existing server if any

  SERVERIO = os.pipe()[::-1]

  try: ## start up py3k server
    print( "py3k server starting..." );
    SERVER = subprocess.Popen(
      "python3.0 -E -i %s" % py3to2.__file__.replace(".pyc", ".py"),
      stdin = subprocess.PIPE,
        stdout = SERVERIO[0],
      stderr = subprocess.STDOUT,
      shell = True)
  except OSError: raise OSERROR("py3to2 could not find or run python3.0.  make sure python3.0 is properly installed & exists in $PATH env variable")

  ## input command to py3k server's stdin
  def py3k_input(s): SERVER.stdin.write(s)
  py3k_input("sys.ps1 = ''\n")

  EOF = "%r\n" % hex(id("eof"))
  ## read from py3k server's stdout
  def py3k_read():
    n = len(EOF); py3k_input("\n" + EOF); arr = io.BytesIO()
    while True:
      x = os.read(SERVERIO[1], 4096); arr.write(x)
      if len(x) < len(EOF): x = arr.getvalue()
      if x[-n:] == EOF: break
    return arr.getvalue()[:-n]
  py3k_input("print( '...py3k server started w/ <pid %i> & <i/o pipes %i/%i>' )\n" % (SERVER.pid, SERVERIO[0], SERVERIO[1])); print( py3k_read() )



######## codetree
import dis, opcode, types
class codetree(object):
  """
  ################################################################
  mutable, serializable pseudo-codeobj which u can edit,
  disassemble, debug, & recompile into a real codeobj

  >>> codeobj = compile( "def echo(x): return x", "", "exec" )
  >>> tree = codetree( codeobj )
  >>> print( tree )
  codetree(
  co_argcount =     0,
  co_cellvars =     (),
  co_code =         'd\\x00\\x00\\x84\\x00\\x00Z\\x00\\x00d\\x01\\x00S',
  co_filename =     '',
  co_firstlineno =  1,
  co_flags =        64,
  co_freevars =     (),
  co_lnotab =       '',
  co_name =         '<module>',
  co_names =        ('echo',),
  co_nlocals =      0,
  co_stacksize =    1,
  co_varnames =     (),
  depth =           0,
  co_consts = (
   codetree(
   co_argcount =     1,
   co_cellvars =     (),
   co_code =         '|\\x00\\x00S',
   co_filename =     '',
   co_firstlineno =  1,
   co_flags =        67,
   co_freevars =     (),
   co_lnotab =       '',
   co_name =         'echo',
   co_names =        (),
   co_nlocals =      1,
   co_stacksize =    1,
   co_varnames =     ('x',),
   depth =           1,
   co_consts = (
    None,
    )),
   None,
   ))

  >>> print( tree.dis() )
    1           0 LOAD_CONST               0 (<code object echo...
                3 MAKE_FUNCTION            0
                6 STORE_NAME               0 (echo)
                9 LOAD_CONST               1 (None)
               12 RETURN_VALUE

        1           0 LOAD_FAST                0 (x)
                    3 RETURN_VALUE

  >>> exec( tree.compile() )
  >>> echo( "hello world" )
  hello world
  """
  py2x_opname = "STOP_CODE POP_TOP ROT_TWO ROT_THREE DUP_TOP ROT_FOUR <6> <7> <8> NOP UNARY_POSITIVE UNARY_NEGATIVE UNARY_NOT UNARY_CONVERT <14> UNARY_INVERT <16> <17> LIST_APPEND BINARY_POWER BINARY_MULTIPLY BINARY_DIVIDE BINARY_MODULO BINARY_ADD BINARY_SUBTRACT BINARY_SUBSCR BINARY_FLOOR_DIVIDE BINARY_TRUE_DIVIDE INPLACE_FLOOR_DIVIDE INPLACE_TRUE_DIVIDE SLICE+0 SLICE+1 SLICE+2 SLICE+3 <34> <35> <36> <37> <38> <39> STORE_SLICE+0 STORE_SLICE+1 STORE_SLICE+2 STORE_SLICE+3 <44> <45> <46> <47> <48> <49> DELETE_SLICE+0 DELETE_SLICE+1 DELETE_SLICE+2 DELETE_SLICE+3 STORE_MAP INPLACE_ADD INPLACE_SUBTRACT INPLACE_MULTIPLY INPLACE_DIVIDE INPLACE_MODULO STORE_SUBSCR DELETE_SUBSCR BINARY_LSHIFT BINARY_RSHIFT BINARY_AND BINARY_XOR BINARY_OR INPLACE_POWER GET_ITER <69> PRINT_EXPR PRINT_ITEM PRINT_NEWLINE PRINT_ITEM_TO PRINT_NEWLINE_TO INPLACE_LSHIFT INPLACE_RSHIFT INPLACE_AND INPLACE_XOR INPLACE_OR BREAK_LOOP WITH_CLEANUP LOAD_LOCALS RETURN_VALUE IMPORT_STAR EXEC_STMT YIELD_VALUE POP_BLOCK END_FINALLY BUILD_CLASS STORE_NAME DELETE_NAME UNPACK_SEQUENCE FOR_ITER <94> STORE_ATTR DELETE_ATTR STORE_GLOBAL DELETE_GLOBAL DUP_TOPX LOAD_CONST LOAD_NAME BUILD_TUPLE BUILD_LIST BUILD_MAP LOAD_ATTR COMPARE_OP IMPORT_NAME IMPORT_FROM <109> JUMP_FORWARD JUMP_IF_FALSE JUMP_IF_TRUE JUMP_ABSOLUTE <114> <115> LOAD_GLOBAL <117> <118> CONTINUE_LOOP SETUP_LOOP SETUP_EXCEPT SETUP_FINALLY <123> LOAD_FAST STORE_FAST DELETE_FAST <127> <128> <129> RAISE_VARARGS CALL_FUNCTION MAKE_FUNCTION BUILD_SLICE MAKE_CLOSURE LOAD_CLOSURE LOAD_DEREF STORE_DEREF <138> <139> CALL_FUNCTION_VAR CALL_FUNCTION_KW CALL_FUNCTION_VAR_KW EXTENDED_ARG <144> <145> <146> <147> <148> <149> <150> <151> <152> <153> <154> <155> <156> <157> <158> <159> <160> <161> <162> <163> <164> <165> <166> <167> <168> <169> <170> <171> <172> <173> <174> <175> <176> <177> <178> <179> <180> <181> <182> <183> <184> <185> <186> <187> <188> <189> <190> <191> <192> <193> <194> <195> <196> <197> <198> <199> <200> <201> <202> <203> <204> <205> <206> <207> <208> <209> <210> <211> <212> <213> <214> <215> <216> <217> <218> <219> <220> <221> <222> <223> <224> <225> <226> <227> <228> <229> <230> <231> <232> <233> <234> <235> <236> <237> <238> <239> <240> <241> <242> <243> <244> <245> <246> <247> <248> <249> <250> <251> <252> <253> <254> <255>".split(" ")
  py3k_opname = "STOP_CODE POP_TOP ROT_TWO ROT_THREE DUP_TOP ROT_FOUR <6> <7> <8> NOP UNARY_POSITIVE UNARY_NEGATIVE UNARY_NOT <13> <14> UNARY_INVERT <16> SET_ADD LIST_APPEND BINARY_POWER BINARY_MULTIPLY <21> BINARY_MODULO BINARY_ADD BINARY_SUBTRACT BINARY_SUBSCR BINARY_FLOOR_DIVIDE BINARY_TRUE_DIVIDE INPLACE_FLOOR_DIVIDE INPLACE_TRUE_DIVIDE <30> <31> <32> <33> <34> <35> <36> <37> <38> <39> <40> <41> <42> <43> <44> <45> <46> <47> <48> <49> <50> <51> <52> <53> STORE_MAP INPLACE_ADD INPLACE_SUBTRACT INPLACE_MULTIPLY <58> INPLACE_MODULO STORE_SUBSCR DELETE_SUBSCR BINARY_LSHIFT BINARY_RSHIFT BINARY_AND BINARY_XOR BINARY_OR INPLACE_POWER GET_ITER STORE_LOCALS PRINT_EXPR LOAD_BUILD_CLASS <72> <73> <74> INPLACE_LSHIFT INPLACE_RSHIFT INPLACE_AND INPLACE_XOR INPLACE_OR BREAK_LOOP WITH_CLEANUP <82> RETURN_VALUE IMPORT_STAR <85> YIELD_VALUE POP_BLOCK END_FINALLY POP_EXCEPT STORE_NAME DELETE_NAME UNPACK_SEQUENCE FOR_ITER UNPACK_EX STORE_ATTR DELETE_ATTR STORE_GLOBAL DELETE_GLOBAL DUP_TOPX LOAD_CONST LOAD_NAME BUILD_TUPLE BUILD_LIST BUILD_SET BUILD_MAP LOAD_ATTR COMPARE_OP IMPORT_NAME IMPORT_FROM JUMP_FORWARD JUMP_IF_FALSE JUMP_IF_TRUE JUMP_ABSOLUTE <114> <115> LOAD_GLOBAL <117> <118> CONTINUE_LOOP SETUP_LOOP SETUP_EXCEPT SETUP_FINALLY <123> LOAD_FAST STORE_FAST DELETE_FAST <127> <128> <129> RAISE_VARARGS CALL_FUNCTION MAKE_FUNCTION BUILD_SLICE MAKE_CLOSURE LOAD_CLOSURE LOAD_DEREF STORE_DEREF <138> <139> CALL_FUNCTION_VAR CALL_FUNCTION_KW CALL_FUNCTION_VAR_KW EXTENDED_ARG <144> <145> <146> <147> <148> <149> <150> <151> <152> <153> <154> <155> <156> <157> <158> <159> <160> <161> <162> <163> <164> <165> <166> <167> <168> <169> <170> <171> <172> <173> <174> <175> <176> <177> <178> <179> <180> <181> <182> <183> <184> <185> <186> <187> <188> <189> <190> <191> <192> <193> <194> <195> <196> <197> <198> <199> <200> <201> <202> <203> <204> <205> <206> <207> <208> <209> <210> <211> <212> <213> <214> <215> <216> <217> <218> <219> <220> <221> <222> <223> <224> <225> <226> <227> <228> <229> <230> <231> <232> <233> <234> <235> <236> <237> <238> <239> <240> <241> <242> <243> <244> <245> <246> <247> <248> <249> <250> <251> <252> <253> <254> <255>".split(" ")
  diff_opname = []
  for i, a, b in zip(count(), py2x_opname, py3k_opname):
    if a != b: diff_opname.append([i, a, b])

  #	enum	py2x_opcode	py3k_opcode
  #	13	UNARY_CONVERT	<13>
  #	17	<17>	SET_ADD
  #	21	BINARY_DIVIDE	<21>
  #	30	SLICE+0	<30>
  #	31	SLICE+1	<31>
  #	32	SLICE+2	<32>
  #	33	SLICE+3	<33>
  #	40	STORE_SLICE+0	<40>
  #	41	STORE_SLICE+1	<41>
  #	42	STORE_SLICE+2	<42>
  #	43	STORE_SLICE+3	<43>
  #	50	DELETE_SLICE+0	<50>
  #	51	DELETE_SLICE+1	<51>
  #	52	DELETE_SLICE+2	<52>
  #	53	DELETE_SLICE+3	<53>
  #	58	INPLACE_DIVIDE	<58>
  #	69	<69>	STORE_LOCALS
  #	71	PRINT_ITEM	LOAD_BUILD_CLASS
  #	72	PRINT_NEWLINE	<72>
  #	73	PRINT_ITEM_TO	<73>
  #	74	PRINT_NEWLINE_TO	<74>
  #	82	LOAD_LOCALS	<82>
  #	85	EXEC_STMT	<85>
  #	89	BUILD_CLASS	POP_EXCEPT
  #	94	<94>	UNPACK_EX
  #	104	BUILD_MAP	BUILD_SET
  #	105	LOAD_ATTR	BUILD_MAP
  #	106	COMPARE_OP	LOAD_ATTR
  #	107	IMPORT_NAME	COMPARE_OP
  #	108	IMPORT_FROM	IMPORT_NAME
  #	109	<109>	IMPORT_FROM

  NOP = py2x_opname.index("NOP")
  opmap_new = {
    "SET_ADD":17,
    "STORE_LOCALS":69,
    "LOAD_BUILD_CLASS":34,
    ## "MAKE_BYTES":35,
    "POP_EXCEPT":NOP, ## 89
    "WITH_CLEANUP":37, ## 81
    ## "END_FINALLY":38, ## 88
    "UNPACK_EX":94,
    "BUILD_SET":192,
    "MAKE_FUNCTION":193,
    }

  for i, a, b in diff_opname:
    if b[0] != "<" and b not in opmap_new: opmap_new[b] = py2x_opname.index(b)
  opmap_3to2 = {}
  for x, i in opmap_new.items():
    j = py3k_opname.index(x) if x in py3k_opname else i
    if j != i: opmap_3to2[j] = i

  if ISPY3K:
    co_args = "co_argcount co_kwonlyargcount co_nlocals co_stacksize co_flags co_code co_consts co_names co_varnames co_filename co_name co_firstlineno co_lnotab co_freevars co_cellvars".split(" ")
    def op3to2(self):
      self = codetree(**self.__dict__) ## copy self
      # assert 0 <= self.co_argcount < 0x10000; assert 0 <= self.co_kwonlyargcount < 0x100
      # self.co_argcount |= (self.co_kwonlyargcount << 16) | 0x1000000 ## bitshift & then piggyback co_kwonlyargcount to co_argcount
      # self.co_argcount |= (self.co_kwonlyargcount << 16) ## bitshift & then piggyback co_kwonlyargcount to co_argcount

      s = bytearray(self.co_code); skip = 0; HAVE_ARGUMENT = opcode.HAVE_ARGUMENT; opmap_3to2 = self.opmap_3to2
      for i, x in enumerate(s): ## map opcodes from 3k to 2x
        if skip: skip -= 1; continue
        if x >= HAVE_ARGUMENT: skip = 2
        if x in opmap_3to2: s[i] = opmap_3to2[x]
      self.co_code = bytes(s)
      self.co_consts = tuple( x.op3to2() if isinstance(x, codetree) else x for x in self.co_consts ); return self ## recurse

  else:
    co_args = "co_argcount co_nlocals co_stacksize co_flags co_code co_consts co_names co_varnames co_filename co_name co_firstlineno co_lnotab co_freevars co_cellvars".split(" ")

    for x, i in opmap_new.items():
      if i is not NOP: py2x_opname[i] = x; setattr(opcode, x, i) ## update opname
    opcode.opname = py2x_opname; opcode.opmap.update(opmap_new); reload(dis) ## update dis
    for i, x in enumerate(opcode.opname): setattr(opcode, x, i) ## populate opcode module w/ opname

  co_constsi = co_args.index("co_consts") ## co_consts index pos

  def __init__(self, codeobj = None, depth = 0, **kwds):
    if codeobj: ## codeobj
      self.__dict__ = dict((x, getattr(codeobj, x)) for x in self.co_args)
      self.co_consts = tuple(codetree(x, depth = depth + 1) if isinstance(x, types.CodeType) else x for x in codeobj.co_consts) ## recurse
    self.depth = depth; self.__dict__.update(kwds)

  def __eq__(self, x): return type(self) == type(x) and self.__dict__ == x.__dict__

  ## serializable: codetree(codeobj) == eval( repr( codetree( codeobj ) ) )
  def __repr__(self): return "codetree(**%r)" % self.__dict__

  def __str__(self):
    _ =  " " * self.depth
    hsh = sorted(x for x in self.__dict__.items() if x[0] != "co_consts")
    hsh = "".join(_ + k + " =" + " " * (0x10 - len(k)) + repr(x) + ",\n" for k, x in hsh)
    consts = "".join(_ + " " + str(x) + ",\n" for x in self.co_consts)
    return "codetree(\n" + hsh + "%sco_consts = (\n" % _ + consts + "%s )" % _ + ")"

  def compile(self):
    "codeobj == codetree(codeobj).compile()"
    args = [getattr(self, x) for x in self.co_args] ## create list of args
    args[self.co_constsi] = tuple(x.compile() if isinstance(x, codetree) else x for x in self.co_consts)  ## recurse
    return types.CodeType(*args, **{"co_kwonlyargcount":getattr(self, "co_kwonlyargcount", 0)})

  ## recursive disassembler
  def dis(self):
    def recurse(x, _ = ""):
      if isinstance(x, types.CodeType):
        dis.dis(x); f.seek(0); yield _ + f.read().replace("\n", "\n" + _); f.seek(0); f.truncate()
        for x in x.co_consts:
          for x in recurse(x, _ + "    "): yield x
    sys.stdout = f = io.StringIO() if ISPY3K else io.BytesIO()
    try: s = "\n".join(recurse(self.compile()))
    finally: sys.stdout = sys.__stdout__; f.close()
    return s

  ## returns codetree obj from file
  @staticmethod
  def fromfile(fpath, compiler = None):
    s = open(fpath).read()
    c = (compiler if compiler else compile)(s, fpath, "exec")
    return codetree(c)

  ## returns codetree obj from str
  @staticmethod
  def fromstr(s, *args, **kwds):
    import tempfile; f = tempfile.NamedTemporaryFile(delete = None); f.write(s); f.close(); fpath = f.name
    return codetree.fromfile(fpath, *args, **kwds)



if ISPY3K:
  import ast
  ## pseudomethod parser
  class parser(ast.NodeTransformer):
    ## recursively print nodes in ast object for debugging
    @staticmethod
    def printnode(node, depth = ""):
      s = node.__dict__.items()
      s = "    ".join("%s %r" % x for x in sorted(node.__dict__.items()))
      print( "%s%s\t%s" % (depth, str(type(node)), s) )
      for x in ast.iter_child_nodes(node): parser.printnode(x, depth = depth + " ")

    ## hack node if it contains __pseudomethod__ attr
    def visit_Call(self, node):
      x = node.func
      if type(x) is ast.Attribute:
        x = x.value
        # if type(x) is ast.Attribute and x.attr in ("__pseudomethod__", self.keyword): ## a..b(...) -> b(a, ...)
        if type(x) is ast.Attribute and x.attr == "__pseudomethod__": ## a..b(...) -> b(a, ...)
          node.args.insert(0, node.func.value.value)
          node.func = ast.copy_location(
            ast.Name(node.func.attr, ast.Load()), ## new node
            node.func) ## old node
      for x in ast.iter_child_nodes(node): self.visit(x) ## recurse
      return node



if not ISPY3K:
  import re, tokenize
  ######## compiler tools
  class compiler(object):
    sreplace = tuple((x, chr(i)) for i, x in enumerate((
      '...', ## ellipsis
      "\\\\", ## backslash
      "\\'", '\\"', ## esc quote
      "'''", '"""', ## triple quotes
       ))); i = len(sreplace); quotes = "'\"" + sreplace[-2][1] + sreplace[-1][1]

    _ = chr(i); i += 1 ## txt placeholder
    assert i < 9

    def preparse(self, s):
      s = ("\n" + s + "\n").replace(MAGIC, "\nimport builtins; from builtins import *\n", 1) ## remove magic

      ## extract cmm & txt
      for x in self.sreplace: s = s.replace(*x)
      from collections import deque; code = deque(); txt = deque(); arr = code; i0 = iscmm = isnum = istxt = 0
      for i, x in enumerate(s):
        if iscmm:
          if x == "\n": arr = txt; iscmm = None
          else: continue
        elif isnum:
          if x not in  "0123456789": arr = txt; isnum = None
          else: continue
        elif istxt:
          if x == istxt: arr = txt; istxt = None; i += 1
          else: continue

        elif x == "#": arr = code; iscmm = True
        elif x in "0123456789": arr = code; isnum = True
        elif x in self.quotes:
          arr = code; istxt = x
          if s[i-1] in "BbUu": i -= 1

        else: continue
        arr.append(s[i0:i]); i0 = i
      code.append(s[i0:])
      if 1 and DEBUG: print(code); print(txt)
      code = self._.join(code); txt = list(txt)

      ## preparse code
      code = code.replace("..", ".__pseudomethod__.") ## parse pseudomethod syntax
      code = code.replace("from . ", ""); code = code.replace("from .", "from ") ## relative import
      code = code.replace("from __future__", "# from __future__") ## comment from __future__ statement

      ## preparse string
      for i, x in enumerate(txt):
        if x[0] in "Uu": txt[i] = x[1:] + ".decode('raw_unicode_escape')" ## preserve unicode literal

      ## recombine code & string
      s = io.StringIO() if ISPY3K else io.BytesIO()
      for a, b in zip_longest(code.split(self._), txt, fillvalue = ""): s.write(a); s.write(b)
      s = s.getvalue()
      for x in reversed(self.sreplace): s = s.replace(*x[::-1])
      return s[1: -1] ## restore lineno for debugging - recall extra "\n" from MAGIC

    def postparse(self, s):
      s = s.replace("'__next__'", "'next'") ## PEP3114  Renaming iterator.next() to .__next__()
      return s

    def compile(self, s, fpath, *args, **kwds):
      self.args = args; self.kwds = kwds
      try:
        if isinstance(s, basestring):
          if isinstance(s, str): s = s.decode("utf8")
          if isinstance(s, unicode): s = s.encode("raw_unicode_escape")
          assert isascii(s)
        else: raise Exception
      except: raise UnicodeError("py3to2 can't compile %s obj from file %r b/c it contains non-utf8 characters" % (type(s), fpath))

      s = self.preparse(s) ## preparse
      s = server_compile(s, fpath, *args, **kwds) ## compile s into py3k codeobj
      s = self.postparse(s) ## postparse
      t = __builtin__.eval(s)
      if isinstance(t, Exception): raise t
      return t.compile()
  __builtin__._compile = compiler().compile



  ######## 2to3
  class _py2to3(object):
    def __call__(self, fpath, reparse = None, verbose = True, fixer_pkg = "lib2to3.fixes", args = []):
      if reparse:
        if os.path.exists(fpath + ".orig"): system("cp -p %s.orig %s" % (fpath, fpath)) ## copy backup files for reparsing
      s = "\n" + open(fpath).read() + "\n"
      if MAGIC in s: ## already a py3k file
        if verbose: print( "%s is already in py3k format.  try py2to3(%r, reparse = True, ...) if u wish to reparse this file" % (fpath, fpath) )
        return

      if not os.path.exists(fpath + ".orig"): system("cp -p %s %s.orig" % (fpath, fpath) ) ## backup first
      from lib2to3 import main; main.main(fixer_pkg, args + ["--write", fpath]) ## run 2to3
      with open(fpath, "r+") as f:
        s = f.read()

        ## simple individual fixes
        if "py3k_Lib/decimal.py" in fpath: s = s.replace(" del s\n", " ## del s ## py3k\n")
        if "py3k_Lib/filecmp.py" in fpath: s = s.replace("from itertools import filterfalse,", "from itertools import filterfalse")
        if "py3k_Lib/tokenize.py" in fpath: s = s.replace("\ndel x\n", " ## del x ## py3k\n")
        if "py3k_Lib/uuid.py" in fpath: s = s.replace("int = int", "int = builtins.int")
        if "py3k_Lib/xdrlib.py" in fpath: s = s.replace("except struct.error, msg:", "except struct.error as msg:")

        f.seek(0); f.write(MAGIC); f.write(s) ## add py3to2 MAGIC to file

    ## automatically converts file using 2to3 (if not already done so) & then attempts to load it using py3to2
    def overwrite_and_load_module(self, mname, fpath, *args, **kwds): self(fpath, *args, **kwds); return py3to2_init.load_module(mname, fpath)

    stdlib = "_abcoll abc aifc anydbm ast asynchat asyncore atexit audiodev base64 BaseHTTPServer Bastion bdb binhex bisect calendar CGIHTTPServer cgi cgitb chunk cmd codecs codeop code collections colorsys commands compileall ConfigParser contextlib cookielib Cookie copy copy_reg cProfile csv dbhash decimal difflib dircache dis doctest DocXMLRPCServer dumbdbm dummy_threading dummy_thread filecmp fileinput fnmatch formatter fpformat fractions ftplib functools __future__ genericpath getopt getpass gettext glob gzip hashlib heapq hmac htmlentitydefs htmllib HTMLParser httplib ihooks imaplib imghdr imputil inspect io keyword linecache locale _LWPCookieJar macpath macurl2path mailbox mailcap markupbase md5 mhlib mimetools mimetypes MimeWriter mimify modulefinder _MozillaCookieJar multifile mutex netrc new nntplib ntpath nturl2path numbers opcode optparse os2emxpath os pdb __phello__.foo pickle pickletools pipes pkgutil platform plistlib popen2 poplib posixfile posixpath pprint profile pstats pty pyclbr py_compile pydoc pydoc_topics Queue quopri random repr re rexec rfc822 rlcompleter robotparser runpy sched sets sgmllib sha shelve shlex shutil SimpleHTTPServer SimpleXMLRPCServer site smtpd smtplib sndhdr socket SocketServer sre_compile sre_constants sre_parse sre ssl stat statvfs StringIO stringold stringprep string _strptime struct subprocess sunaudio sunau symbol symtable tabnanny tarfile telnetlib tempfile textwrap this _threading_local threading timeit toaiff tokenize token traceback trace tty types unittest urllib2 urllib urlparse UserDict UserList user UserString uuid uu warnings wave weakref webbrowser whichdb xdrlib xmllib xmlrpclib zipfile".split(" ")

    def test_stdlib(self, dirpath, stdlib = stdlib, skip = ()):
      def default(): failed.append(mname); import traceback; traceback.print_exc()
      stdlib = [x for x in stdlib if x not in skip]; failed = []; passed = []; missing = []; nonutf8 = []
      for i, mname in enumerate(stdlib):
        print( mname )
        fpath = os.path.join( dirpath, mname) + ".py"
        try: self.overwrite_and_load_module(mname, fpath, verbose = None); passed.append(mname)
        except UnicodeError as e:
          if "b/c it contains non-utf8 characters" in e.message: nonutf8.append(mname)
          else: default()
        except ImportError as e:
          if "No module named" in e.message: missing.append(mname)
          else: default()
        except: default()

      print( "\ntested %i 2to3 generated scripts from %s standard library" % (i, sys.version) )
      print( "\n%i skipped:\n%s" % (len(skip), " ".join(skip)) )
      print( "\n%i couldn't import required modules:\n%s" % (len(missing), " ".join(missing)) )
      print( "\n%i were non-utf8 compliant scripts:\n%s" % (len(nonutf8), " ".join(nonutf8)) )
      print( "\n%i failed import due to other reasons:\n%s" % (len(failed), " ".join(failed)) )
      print( "\n%i passed import:\n%s" % (len(passed), " ".join(passed)) )
      print( "" )
  py2to3 = _py2to3()



######## debugging...
def quicktest():
  if "py3to2_test" not in sys.modules: import py3to2_test
  else: reload(py3to2_test)

if ISPY3K:
  if 0 and DEBUG:
    self = compiler
    s = "ABC ..echo() ..foo()"
    s = self.pre_parse(s)
    n = ast.parse(s, "", "exec")
    self.ast_parse.printd(n)
    n = self.ast_parse().visit(n)
    self.ast_parse.printd(n)

else:
  if 0 and DEBUG:
    s = open("a00.py").read()
    c = py3k_compile(s, "", "exec")
    t = codetree(c)
    print( t.dis() )
    # pass
    # s = """
# class A:
  # def foo(self): pass
# class B(A):
  # def foo(self): return super().foo()
# B().foo()
# """
    # c = py3k_compile(s, "", "exec"); t = codetree(c)
    # print( t ); print( t.dis() ); print( s )
    # py3k_exec(c)
