diff -Naur src/Include/patchlevel.h patched/Include/patchlevel.h
--- src/Include/patchlevel.h	2008-10-01 14:46:40.000000000 -0700
+++ patched/Include/patchlevel.h	2008-11-17 19:01:08.108316000 -0800
@@ -27,7 +27,7 @@
 #define PY_RELEASE_SERIAL	0
 
 /* Version as a string */
-#define PY_VERSION      	"2.6"
+#define PY_VERSION      	"2.6.py3to2" // py3k
 /*--end constants--*/
 
 /* Subversion Revision number of this file (not of the repository) */
diff -Naur src/Lib/py3to2_init.py patched/Lib/py3to2_init.py
--- src/Lib/py3to2_init.py	1969-12-31 16:00:00.000000000 -0800
+++ patched/Lib/py3to2_init.py	2008-11-23 06:39:19.766631000 -0800
@@ -0,0 +1,54 @@
+import imp, os, sys
+if "DEBUG" not in globals(): DEBUG = 0 # True enables printing debug info
+
+######## import hook
+class importer(object):
+  py3to2 = None # identifier
+  magic = "\nfrom __future__ import py3k_syntax\n"
+
+  def __init__(self):
+    sys.meta_path[:] = [self] + [x for x in sys.meta_path if not hasattr(x, "py3to2")] # restore sys.meta_path
+    sys.path_importer_cache = {} # reset cache
+
+  def find_module(self, mname, path = None):
+    if DEBUG and 1: print( "py3k find_module(%s, path = %s)" % (mname, path) )
+
+    if path and len(path) is 1:
+      x = path[0] + "."
+      if mname[:len(x)] == x: mname = mname[len(x):] # import from package
+
+    try: file, fpath, desc = imp.find_module(mname, path if path else sys.path); tp = desc[2]
+    except ImportError: return
+
+    if tp is imp.PY_SOURCE: pass
+    elif tp is imp.PKG_DIRECTORY: fpath += "/__init__.py"; file = open(fpath)
+    else: return
+
+    s = "\n" + file.read() + "\n"; file.close()
+    if self.magic not in s: return # no py3k magic found in file
+    s = s.replace(self.magic, "\nimport builtins; from builtins import *\n", 1)
+    s = s[1:-1] # preserve lineno (for debugging)
+
+    self.found = s, fpath, desc, tp; return self
+
+  def load_module(self, mname):
+    import py3to2
+
+    s, fpath, desc, tp = self.found
+    if DEBUG and 1: print( "py3k load_module(%s, fpath = %s, desc = %s)" % (mname, fpath, desc) )
+
+    if mname in sys.modules: m = sys.modules[mname]; new = None # if exist: use existing module
+    else: m = sys.modules[mname] = imp.new_module(mname); new = True # else: new module
+    try:
+      c = py3to2.py3k_compile(s, fpath, "exec")
+      py3to2.py3k_exec(c, m.__dict__)
+
+      m.__file__ = fpath
+      if tp is imp.PKG_DIRECTORY: m.__path__ = [os.path.dirname(fpath)] # package.__path__
+      m.__loader__ = self.load_module
+      return m
+    except:
+      if new: del sys.modules[mname] # if new module fails loading, del from sys.modules
+      print( "\nFAILED py3to2 load_module(mname = %s, fpath = %s, desc = %s)\n" % (mname, fpath, desc) ) # notify user exception originated from failed py3to2 import
+      raise
+importer()
diff -Naur src/Lib/py3to2.py patched/Lib/py3to2.py
--- src/Lib/py3to2.py	1969-12-31 16:00:00.000000000 -0800
+++ patched/Lib/py3to2.py	2008-11-23 08:05:45.078792000 -0800
@@ -0,0 +1,639 @@
+"""
+################################################################################
+py3to2 is a python2.6 interpreter w/ extended python3.0 opcodes, allowing it to
+natively run python3.0 scripts. it should b fully backwards-compatible w/
+cpython2.6 & its extensions.
+
+the intended purpose is to allow developers to migrate python2.6 scripts to
+python3.0 while retaining backwards compatibility w/ existing extension modules.
+
+AUTHOR:
+  kai zhu
+  kaizhu@ugcs.caltech.edu
+
+REQUIREMENTS:
+  - posix/unix os (Windows currently unsupported)
+  - w/ python2.6 & python3.0 installed
+
+INSTALL
+  $ python2.6 setup.py build
+  $ python2.6 setup.py install
+  $ python2.6 setup.py dev --quicktest
+
+  the above will build & install 3 files:
+  - extended python2.6 interpreter: bin/py3to2
+  - initialization script:          lib/python2.6/site-packages/py3to2_init.py
+  - python3.0 bytecode compiler:    lib/python2.6/site-packages/py3to2.py
+
+MAGIC
+  simply add the MAGIC LINE:
+
+    from __future__ import py3k_syntax
+
+  to make py3to2 aware that a script is using python3.0 syntax
+
+PSEUDOMETHOD:
+  py3to2 supports ".." pseudomethod syntax notation
+  please goto: http://pypi.python.org/pypi/pseudomethod
+  for more details about this feature
+
+API:
+  try help(py3to2)  ^_-
+
+  py3to2 module:
+  - class codetree - mutable codeobj & disassembler/assembler/debugger
+  - class compiler - compiling tools
+  - python3.0 wrappers:
+    - py3k_compile() - compile python3.0 src
+    - py3k_eval() - eval py3thon3.0 src
+    - py3k_exec() - exec python3.0 src
+
+USAGE:
+  start up the py3to2 interpreter by typing "py3to2" in ur shell:
+    $ py3to2
+
+    Python 2.6.py3to2 (r26:66714, Nov 18 2008, 00:56:43)
+    [GCC 3.4.6 20060404 (Red Hat 3.4.6-10)] on linux2
+    Type "help", "copyright", "credits" or "license" for more information.
+    >>>
+
+  try out this simple python3.0 script:
+    ################################################################
+    # PEP3132  Extended Iterable Unpacking
+    # copy this to file test_pep3132.py
+
+    from __future__ import py3k_syntax
+
+    a,*b = 1,2,3
+    assert a == 1 and b == [2,3]
+    print(a,b)
+    ################################################################
+    >>>
+    >>> import test_pep3132
+    created...
+    py3k server starting...
+    ...py3k server started w/...
+
+    1 [2, 3]
+
+  here's another python3.0 script using scipy (python2.6) extension module:
+    ################################################################
+    # u must have scipy installed for this script to work
+    # copy this to file test_pep3132_scipy.py
+
+    from __future__ import py3k_syntax
+
+    import scipy
+    a,*b = scipy.array([1,2,3])
+    assert a == 1 and b == [2,3]
+    print(a,b)
+    ################################################################
+    >>>
+    >>> import test_pep3132_scipy
+    1 [2, 3]
+
+  another simple, but more thorough test script, test_py3k,
+  is included w/ this distribution:
+    >>>
+    >>> import test_py3k
+    testing PEP3102  Keyword-Only Arguments
+    testing PEP3104  Access to Names in Outer Scopes
+    testing PEP3105  Make print a function
+    testing PEP3107  Function Annotations
+    testing PEP3112  Bytes literals in Python 3000
+    testing PEP3113  Removal of Tuple Parameter Unpacking
+    testing PEP3114  Renaming iterator.next() to .__next__()
+    testing PEP3115  Metaclasses in Python 3000
+    testing PEP3127  Integer Literal Support and Syntax
+    testing PEP3129  Class Decorators
+    testing PEP3132  Extended Iterable Unpacking
+    testing PEP3135  New Super
+    testing pseudomethod example 0
+    testing pseudomethod example 1
+    testing pseudomethod example 2
+    testing pseudomethod example 3
+    testing numpy example
+
+FEATURES:
+  PEP3102  Keyword-Only Arguments
+  PEP3104  Access to Names in Outer Scopes
+  PEP3105  Make print a function
+  PEP3107  Function Annotations
+  PEP3111  Simple input built-in in Python 3000
+  PEP3112  Bytes literals in Python 3000
+  PEP3113  Removal of Tuple Parameter Unpacking
+  PEP3114  Renaming iterator.next() to .__next__()
+  PEP3115  Metaclasses in Python 3000
+  PEP3127  Integer Literal Support and Syntax
+  PEP3129  Class Decorators
+  PEP3132  Extended Iterable Unpacking
+  PEP3135  New Super
+
+LIMITATIONS (FEATURES NOT FULLY SUPPORTED):
+  from a migration standpoint, py3to2 is almost feature complete in terms of
+  python3.0's language syntax, except for:
+  - unicode support (str vs bytes). future support for utf8 is pending...
+
+  language issue aside, python3.0 scripts will still behave differently b/c of
+  internal differences between python2.6 & python3.0:
+  - exception handling.  py3to2 implements python3.0 syntax for raising &
+    catching exceptions.  but the underlying behavior is still python2.6
+  - builtin functions / types.  a few of these have become different beasts
+    under python3.0
+
+################################################################################
+MECHANISM
+
+py3to2 has 3 components:
+- py3to2
+  python interpreter. can evaluate python2.6 bytecode containing additional
+  python3.0 opcode instructions
+
+- py3to2_init.py
+  initialization script.  sets up import hook for recognizing python3.0 scripts
+
+- py3to2.py
+  bytecode compiler. the compile process takes 2 steps:
+  - a persistent python3.0 process is created for compiling scripts into
+    python3.0 code
+  - py3to2.py then converts the code from python3.0 to python2.6 format
+
+################################################################################
+MANIFEST
+  ./patch/ - patched files
+  ./py3to2.diff - summary of patches (maybe out-of-date)
+
+PYTHON2.6 COMPATIBILITY TEST
+  output from amd opteron x86_64 machine on redhat linux (3.4.6-10):
+    $ python setup.py dev --maketest
+    ...
+    324 tests OK.
+    36 tests skipped:
+        test_aepack test_al test_applesingle test_bsddb185 test_bsddb3
+        test_cd test_cl test_codecmaps_cn test_codecmaps_hk
+        test_codecmaps_jp test_codecmaps_kr test_codecmaps_tw test_curses
+        test_dl test_gdbm test_gl test_imageop test_imgfile test_kqueue
+        test_linuxaudiodev test_macos test_macostools test_normalization
+        test_ossaudiodev test_pep277 test_py3kwarn test_scriptpackages
+        test_socketserver test_startfile test_sunaudiodev test_timeout
+        test_urllib2net test_urllibnet test_winreg test_winsound
+        test_zipfile64
+    1 skip unexpected on linux2:
+        test_gdbm
+
+RECENT CHANGES:
+  moved pseudomethod syntax handling to py3k server
+  added more checks during setup
+  added more documentation
+  backported patch r67299 fixing an issue w/ super()
+  cleaned up py3to2.compiler class
+20081120
+  fixed package importing bug - py3to2 failed to import foo.bar
+20081119
+  created self-installing distutils distribution
+20081019
+  ported to python-2.6
+  consolidate & simplify patches to 1 file: ceval.c
+  created extension module builtins_py3k
+  revamped import hook again
+  removed unicode support & restrict source code to ascii-only
+20080727
+  revampled import hook
+20080911
+  consolidate patches to 2 files: bltinmodule.c & ceval.c
+20080828
+  add kwonlyargcount 'attr' to codeobj
+  add __annotations__ & __kwdefaults__ attr to funcobj
+  add __pseudomethod__ feature to baseobj
+20080819
+  pure python import hook - removed magic comment & use magic path instead
+  revamped str & bytes handling
+  revamped py3k .pyc file handling
+20080802
+  pep3135  New Super
+20080717
+  pep3107  Function Annotations
+  pep3120  Using UTF-8 as the default source encoding
+  pep3131  Supporting Non-ASCII Identifiers
+20080713
+  import / reload works transparently on py3k scripts using a magic comment
+  added pep3102  Keyword-Only Arguments
+20080709 added a py3k preparser
+20080702
+  rewrote py3k server's pipe io.  implemented partial bytearray & bytes class.
+  wrote a few simple tests
+20080630
+  __build_class__ function to bltmodule.c.  tested class decorators to b working.
+################################################################################
+"""
+
+from __future__ import print_function
+import io, imp, itertools, os, sys; from itertools import *
+__author__ =	"kai zhu"
+__author_email__ =	"kaizhu@ugcs.caltech.edu"
+__description__ =	"backport 3.0 opcodes to Python-2.6 so it can natively run 3.0 scripts w/ 2.6 extension modules"
+__download_url__ =	None
+__keywords__ =	None
+__license__ =	"BSD"
+__maintainer__ =	None
+__maintainer_email__ =	None
+__obsoletes__ =	None
+__platforms__ =	None
+__provides__ =	None
+__requires__ =	None
+__url__ = "http://www-rcf.usc.edu/~kaizhu/work/py3to2"
+__version__  = "2008.11.22"
+# end info
+
+ISPY3K = True if sys.version_info[0] == 3 else None
+if "DEBUG" not in globals(): DEBUG = 0 # set to 0 to suppress printing debug info
+def echo(x): return x # useful debug function
+
+
+
+######## builtins
+if ISPY3K:
+  import builtins; builtins.reload = imp.reload
+
+else: # emulate py3k builtins
+  import __builtin__, _py3to2, py3to2, py3to2_init; reload(py3to2_init)
+  sys.modules["builtins"] = builtins = _py3to2
+  __builtin__.__build_class__ = builtins.__build_class__
+  py3k_compile = builtins.compile
+  py3k_eval = builtins.eval
+  py3k_exec = builtins.__dict__["exec"]
+
+  builtins.filter = itertools.filter = ifilter
+  itertools.filterfalse = ifilterfalse
+  builtins.input = raw_input # PEP3111  Simple input built-in in Python 3000
+  builtins.range = xrange
+  builtins.map = itertools.map = imap
+  builtins.zip = itertools.zip = izip
+  itertools.zip_longest = izip_longest
+
+  def add2builtins(f):
+    fname = f.__name__.replace("py3k_", "")
+    f.__doc__ = getattr( getattr(__builtin__, fname, None), "__doc__", None )
+    setattr(builtins, fname, f); return f
+  @add2builtins
+  def py3k_oct(x): return __builtin__.oct(x).replace("0", "0o", 1)
+  @add2builtins
+  def printiter(*args, **kwds): print( *tuple(tuple(x) if hasattr(x, "next")  else x for x in args), **kwds )
+
+  from builtins import *; del compile, eval, globals()["exec"]
+
+
+
+######## py3k server
+if ISPY3K:
+  import parser
+  def server_compile(s, fpath, mode, flags, dont_inherit):
+    try:
+      node = parser().parse(s, fpath, mode)
+      c = builtins.compile(node, fpath, mode, flags, dont_inherit)
+      t = codetree(c)
+      s = ascii(t)
+    except Exception as e: s = ascii(e)
+    sys.stdout.write(s)
+
+else:
+  import atexit, signal, subprocess
+  def py3k_close():
+    "kill & cleanup py3k server process"
+    try: os.kill(SERVER.pid, signal.SIGTERM) # kill prev server
+    except: pass
+    try: map(os.close, SERVERIO) # close prev io pipe
+    except: pass
+    try: del py3to2.SERVER # prevent annoying error upon SystemExit
+    except: pass
+  if "SERVER" not in globals(): atexit.register(py3k_close) # close server @ exit
+  py3k_close() # close existing server if any
+
+  SERVERIO = os.pipe()[::-1]
+
+  try: # start up py3k server
+    print( "py3k server starting..." );
+    SERVER = subprocess.Popen(
+      "python3.0 -E -i %s" % py3to2.__file__.replace(".pyc", ".py"),
+      stdin = subprocess.PIPE,
+        stdout = SERVERIO[0],
+      stderr = subprocess.STDOUT,
+      shell = True)
+  except OSError: raise OSERROR("py3to2 could not find or run python3.0.  make sure python3.0 is properly installed & exists in $PATH env variable")
+
+  def py3k_input(s):
+    "input command to py3k server's stdin"
+    SERVER.stdin.write(s)
+  py3k_input("sys.ps1 = ''\n")
+
+  EOF = "%s\n" % id("eof")
+  def py3k_read():
+    "read from py3k server's stdout"
+    n = len(EOF)
+    py3k_input("\n" + EOF)
+    arr = io.BytesIO()
+    while True:
+      x = os.read(SERVERIO[1], 4096); arr.write(x)
+      if len(x) < len(EOF): x = arr.getvalue()
+      if x[-n:] == EOF: break
+    return arr.getvalue()[:-n]
+  py3k_input("print( '...py3k server started w/ <pid %i> & <i/o pipes %i/%i>' )\n" % (SERVER.pid, SERVERIO[0], SERVERIO[1])); print( py3k_read() )
+
+  def server_compile(*args, **kwds): # server compile
+    """
+    tell py3k server to compile(*args, **kwds) &
+    return the resultant py3k codeobj back to u
+    """
+    py3k_input("server_compile(*%s, **%s)" % (args, kwds))
+    s = py3k_read()
+    return s
+
+
+
+######## codetree
+import dis, opcode, types
+class codetree(object):
+  """
+  ################################################################
+  mutable, serializable pseudo-codeobj which u can edit,
+  disassemble, debug, & recompile into a real codeobj
+
+  >>> codeobj = compile( "def echo(x): return x", "", "exec" )
+  >>> tree = codetree( codeobj )
+  >>> print( tree )
+  codetree(
+  co_argcount =     0,
+  co_cellvars =     (),
+  co_code =         'd\\x00\\x00\\x84\\x00\\x00Z\\x00\\x00d\\x01\\x00S',
+  co_filename =     '',
+  co_firstlineno =  1,
+  co_flags =        64,
+  co_freevars =     (),
+  co_lnotab =       '',
+  co_name =         '<module>',
+  co_names =        ('echo',),
+  co_nlocals =      0,
+  co_stacksize =    1,
+  co_varnames =     (),
+  depth =           0,
+  co_consts = (
+   codetree(
+   co_argcount =     1,
+   co_cellvars =     (),
+   co_code =         '|\\x00\\x00S',
+   co_filename =     '',
+   co_firstlineno =  1,
+   co_flags =        67,
+   co_freevars =     (),
+   co_lnotab =       '',
+   co_name =         'echo',
+   co_names =        (),
+   co_nlocals =      1,
+   co_stacksize =    1,
+   co_varnames =     ('x',),
+   depth =           1,
+   co_consts = (
+    None,
+    )),
+   None,
+   ))
+
+  >>> print( tree.dis() )
+    1           0 LOAD_CONST               0 (<code object echo...
+                3 MAKE_FUNCTION            0
+                6 STORE_NAME               0 (echo)
+                9 LOAD_CONST               1 (None)
+               12 RETURN_VALUE
+
+        1           0 LOAD_FAST                0 (x)
+                    3 RETURN_VALUE
+
+  >>> exec( tree.compile() )
+  >>> echo( "hello world" )
+  hello world
+  
+  """
+  py2x_opname = "STOP_CODE POP_TOP ROT_TWO ROT_THREE DUP_TOP ROT_FOUR <6> <7> <8> NOP UNARY_POSITIVE UNARY_NEGATIVE UNARY_NOT UNARY_CONVERT <14> UNARY_INVERT <16> <17> LIST_APPEND BINARY_POWER BINARY_MULTIPLY BINARY_DIVIDE BINARY_MODULO BINARY_ADD BINARY_SUBTRACT BINARY_SUBSCR BINARY_FLOOR_DIVIDE BINARY_TRUE_DIVIDE INPLACE_FLOOR_DIVIDE INPLACE_TRUE_DIVIDE SLICE+0 SLICE+1 SLICE+2 SLICE+3 <34> <35> <36> <37> <38> <39> STORE_SLICE+0 STORE_SLICE+1 STORE_SLICE+2 STORE_SLICE+3 <44> <45> <46> <47> <48> <49> DELETE_SLICE+0 DELETE_SLICE+1 DELETE_SLICE+2 DELETE_SLICE+3 STORE_MAP INPLACE_ADD INPLACE_SUBTRACT INPLACE_MULTIPLY INPLACE_DIVIDE INPLACE_MODULO STORE_SUBSCR DELETE_SUBSCR BINARY_LSHIFT BINARY_RSHIFT BINARY_AND BINARY_XOR BINARY_OR INPLACE_POWER GET_ITER <69> PRINT_EXPR PRINT_ITEM PRINT_NEWLINE PRINT_ITEM_TO PRINT_NEWLINE_TO INPLACE_LSHIFT INPLACE_RSHIFT INPLACE_AND INPLACE_XOR INPLACE_OR BREAK_LOOP WITH_CLEANUP LOAD_LOCALS RETURN_VALUE IMPORT_STAR EXEC_STMT YIELD_VALUE POP_BLOCK END_FINALLY BUILD_CLASS STORE_NAME DELETE_NAME UNPACK_SEQUENCE FOR_ITER <94> STORE_ATTR DELETE_ATTR STORE_GLOBAL DELETE_GLOBAL DUP_TOPX LOAD_CONST LOAD_NAME BUILD_TUPLE BUILD_LIST BUILD_MAP LOAD_ATTR COMPARE_OP IMPORT_NAME IMPORT_FROM <109> JUMP_FORWARD JUMP_IF_FALSE JUMP_IF_TRUE JUMP_ABSOLUTE <114> <115> LOAD_GLOBAL <117> <118> CONTINUE_LOOP SETUP_LOOP SETUP_EXCEPT SETUP_FINALLY <123> LOAD_FAST STORE_FAST DELETE_FAST <127> <128> <129> RAISE_VARARGS CALL_FUNCTION MAKE_FUNCTION BUILD_SLICE MAKE_CLOSURE LOAD_CLOSURE LOAD_DEREF STORE_DEREF <138> <139> CALL_FUNCTION_VAR CALL_FUNCTION_KW CALL_FUNCTION_VAR_KW EXTENDED_ARG <144> <145> <146> <147> <148> <149> <150> <151> <152> <153> <154> <155> <156> <157> <158> <159> <160> <161> <162> <163> <164> <165> <166> <167> <168> <169> <170> <171> <172> <173> <174> <175> <176> <177> <178> <179> <180> <181> <182> <183> <184> <185> <186> <187> <188> <189> <190> <191> <192> <193> <194> <195> <196> <197> <198> <199> <200> <201> <202> <203> <204> <205> <206> <207> <208> <209> <210> <211> <212> <213> <214> <215> <216> <217> <218> <219> <220> <221> <222> <223> <224> <225> <226> <227> <228> <229> <230> <231> <232> <233> <234> <235> <236> <237> <238> <239> <240> <241> <242> <243> <244> <245> <246> <247> <248> <249> <250> <251> <252> <253> <254> <255>".split(" ")
+  py3k_opname = "STOP_CODE POP_TOP ROT_TWO ROT_THREE DUP_TOP ROT_FOUR <6> <7> <8> NOP UNARY_POSITIVE UNARY_NEGATIVE UNARY_NOT <13> <14> UNARY_INVERT <16> SET_ADD LIST_APPEND BINARY_POWER BINARY_MULTIPLY <21> BINARY_MODULO BINARY_ADD BINARY_SUBTRACT BINARY_SUBSCR BINARY_FLOOR_DIVIDE BINARY_TRUE_DIVIDE INPLACE_FLOOR_DIVIDE INPLACE_TRUE_DIVIDE <30> <31> <32> <33> <34> <35> <36> <37> <38> <39> <40> <41> <42> <43> <44> <45> <46> <47> <48> <49> <50> <51> <52> <53> STORE_MAP INPLACE_ADD INPLACE_SUBTRACT INPLACE_MULTIPLY <58> INPLACE_MODULO STORE_SUBSCR DELETE_SUBSCR BINARY_LSHIFT BINARY_RSHIFT BINARY_AND BINARY_XOR BINARY_OR INPLACE_POWER GET_ITER STORE_LOCALS PRINT_EXPR LOAD_BUILD_CLASS <72> <73> <74> INPLACE_LSHIFT INPLACE_RSHIFT INPLACE_AND INPLACE_XOR INPLACE_OR BREAK_LOOP WITH_CLEANUP <82> RETURN_VALUE IMPORT_STAR <85> YIELD_VALUE POP_BLOCK END_FINALLY POP_EXCEPT STORE_NAME DELETE_NAME UNPACK_SEQUENCE FOR_ITER UNPACK_EX STORE_ATTR DELETE_ATTR STORE_GLOBAL DELETE_GLOBAL DUP_TOPX LOAD_CONST LOAD_NAME BUILD_TUPLE BUILD_LIST BUILD_SET BUILD_MAP LOAD_ATTR COMPARE_OP IMPORT_NAME IMPORT_FROM JUMP_FORWARD JUMP_IF_FALSE JUMP_IF_TRUE JUMP_ABSOLUTE <114> <115> LOAD_GLOBAL <117> <118> CONTINUE_LOOP SETUP_LOOP SETUP_EXCEPT SETUP_FINALLY <123> LOAD_FAST STORE_FAST DELETE_FAST <127> <128> <129> RAISE_VARARGS CALL_FUNCTION MAKE_FUNCTION BUILD_SLICE MAKE_CLOSURE LOAD_CLOSURE LOAD_DEREF STORE_DEREF <138> <139> CALL_FUNCTION_VAR CALL_FUNCTION_KW CALL_FUNCTION_VAR_KW EXTENDED_ARG <144> <145> <146> <147> <148> <149> <150> <151> <152> <153> <154> <155> <156> <157> <158> <159> <160> <161> <162> <163> <164> <165> <166> <167> <168> <169> <170> <171> <172> <173> <174> <175> <176> <177> <178> <179> <180> <181> <182> <183> <184> <185> <186> <187> <188> <189> <190> <191> <192> <193> <194> <195> <196> <197> <198> <199> <200> <201> <202> <203> <204> <205> <206> <207> <208> <209> <210> <211> <212> <213> <214> <215> <216> <217> <218> <219> <220> <221> <222> <223> <224> <225> <226> <227> <228> <229> <230> <231> <232> <233> <234> <235> <236> <237> <238> <239> <240> <241> <242> <243> <244> <245> <246> <247> <248> <249> <250> <251> <252> <253> <254> <255>".split(" ")
+  diff_opname = []
+  for i, a, b in zip(count(), py2x_opname, py3k_opname):
+    if a != b: diff_opname.append([i, a, b])
+
+  #	enum	py2x_opcode	py3k_opcode
+  #	13	UNARY_CONVERT	<13>
+  #	17	<17>	SET_ADD
+  #	21	BINARY_DIVIDE	<21>
+  #	30	SLICE+0	<30>
+  #	31	SLICE+1	<31>
+  #	32	SLICE+2	<32>
+  #	33	SLICE+3	<33>
+  #	40	STORE_SLICE+0	<40>
+  #	41	STORE_SLICE+1	<41>
+  #	42	STORE_SLICE+2	<42>
+  #	43	STORE_SLICE+3	<43>
+  #	50	DELETE_SLICE+0	<50>
+  #	51	DELETE_SLICE+1	<51>
+  #	52	DELETE_SLICE+2	<52>
+  #	53	DELETE_SLICE+3	<53>
+  #	58	INPLACE_DIVIDE	<58>
+  #	69	<69>	STORE_LOCALS
+  #	71	PRINT_ITEM	LOAD_BUILD_CLASS
+  #	72	PRINT_NEWLINE	<72>
+  #	73	PRINT_ITEM_TO	<73>
+  #	74	PRINT_NEWLINE_TO	<74>
+  #	82	LOAD_LOCALS	<82>
+  #	85	EXEC_STMT	<85>
+  #	89	BUILD_CLASS	POP_EXCEPT
+  #	94	<94>	UNPACK_EX
+  #	104	BUILD_MAP	BUILD_SET
+  #	105	LOAD_ATTR	BUILD_MAP
+  #	106	COMPARE_OP	LOAD_ATTR
+  #	107	IMPORT_NAME	COMPARE_OP
+  #	108	IMPORT_FROM	IMPORT_NAME
+  #	109	<109>	IMPORT_FROM
+
+  NOP = py2x_opname.index("NOP")
+  opmap_new = {
+    "SET_ADD":17,
+    "STORE_LOCALS":69,
+    "LOAD_BUILD_CLASS":34,
+    # "MAKE_BYTES":35,
+    "POP_EXCEPT":NOP, # 36
+    "UNPACK_EX":94,
+    "BUILD_SET":192,
+    "MAKE_FUNCTION":193,
+    }
+
+  for i, a, b in diff_opname:
+    if b[0] != "<" and b not in opmap_new: opmap_new[b] = py2x_opname.index(b)
+  opmap_3to2 = {}
+  for x, i in opmap_new.items():
+    j = py3k_opname.index(x) if x in py3k_opname else i
+    if j != i: opmap_3to2[j] = i
+
+  if ISPY3K:
+    co_args = "co_argcount co_kwonlyargcount co_nlocals co_stacksize co_flags co_code co_consts co_names co_varnames co_filename co_name co_firstlineno co_lnotab co_freevars co_cellvars".split(" ")
+
+  else:
+    co_args = "co_argcount co_nlocals co_stacksize co_flags co_code co_consts co_names co_varnames co_filename co_name co_firstlineno co_lnotab co_freevars co_cellvars".split(" ")
+
+    for x, i in opmap_new.items():
+      if i is not NOP: py2x_opname[i] = x; setattr(opcode, x, i) # update opname
+    opcode.opname = py2x_opname; opcode.opmap.update(opmap_new); reload(dis) # update dis
+    for i, x in enumerate(opcode.opname): setattr(opcode, x, i) # populate opcode module w/ opname
+
+  co_constsi = co_args.index("co_consts") # co_consts index pos
+
+  def __init__(self, codeobj = None, depth = 0, **kwds):
+    if codeobj: # codeobj
+      self.__dict__ = dict((x, getattr(codeobj, x)) for x in self.co_args)
+      self.co_consts = tuple(codetree(x, depth = depth + 1) if isinstance(x, types.CodeType) else x for x in codeobj.co_consts) # recurse
+    self.depth = depth; self.__dict__.update(kwds)
+
+  def __eq__(self, x): return type(self) == type(x) and self.__dict__ == x.__dict__
+
+  # serializable: codetree(codeobj) == eval( repr( codetree( codeobj ) ) )
+  def __repr__(self): return "codetree(**%r)" % self.__dict__
+
+  def __str__(self):
+    _ =  " " * self.depth
+    hsh = sorted(x for x in self.__dict__.items() if x[0] != "co_consts")
+    hsh = "".join(_ + k + " =" + " " * (0x10 - len(k)) + repr(x) + ",\n" for k, x in hsh)
+    consts = "".join(_ + " " + str(x) + ",\n" for x in self.co_consts)
+    return "codetree(\n" + hsh + "%sco_consts = (\n" % _ + consts + "%s )" % _ + ")"
+
+  def compile(self):
+    "codeobj == codetree(codeobj).compile()"
+    args = [getattr(self, x) for x in self.co_args] # create list of args
+    args[self.co_constsi] = tuple(x.compile() if isinstance(x, codetree) else x for x in self.co_consts)  # recurse
+    return types.CodeType(*args)
+
+  # recursive disassembler
+  def dis(self):
+    def recurse(x, _ = ""):
+      if isinstance(x, types.CodeType):
+        dis.dis(x); f.seek(0); yield _ + f.read().replace("\n", "\n" + _); f.seek(0); f.truncate()
+        for x in x.co_consts:
+          for x in recurse(x, _ + "    "): yield x
+    sys.stdout = f = io.StringIO() if ISPY3K else io.BytesIO()
+    try: s = "\n".join(recurse(self.compile()))
+    finally: sys.stdout = sys.__stdout__; f.close()
+    return s
+
+
+
+if ISPY3K:
+  import ast
+  # pseudomethod parser
+  class parser(ast.NodeTransformer):
+    alphanum = "_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+
+    # parse str -> ast node w/ pseudomethod support
+    def parse(self, s, fpath, mode):
+      keyword = "qjzx" # least common alphabets
+      for i, x in enumerate(s): # create a unique keyword guaranteed not to occur in s
+        if keyword not in s: break
+        keyword += alphanum[i % len(alphanum)]
+      self.keyword = keyword; self.bkeyword = keyword.encode("ascii")
+      s = s.replace("__pseudomethod__", keyword) # temporarily remove "__pseudomethod__" string to prevent collision
+      s = s.replace("..", ".__pseudomethod__.").replace("__pseudomethod__..", "..").replace("..__pseudomethod__", "..") # parse pseudomethod syntax
+      n = ast.parse(s, fpath, mode)
+      n = self.visit(n) # parse pseudomethod node
+      return n
+
+    # recursively print nodes in ast object for debugging
+    @staticmethod
+    def printnode(node, depth = ""):
+      s = node.__dict__.items()
+      s = "    ".join("%s %r" % x for x in sorted(node.__dict__.items()))
+      print( "%s%s\t%s" % (depth, str(type(node)), s) )
+      for x in ast.iter_child_nodes(node): parser.printnode(x, depth = depth + " ")
+
+    # hack node if it contains __pseudomethod__ attr
+    def visit_Call(self, node):
+      x = node.func
+      if type(x) is ast.Attribute:
+        x = x.value
+        if type(x) is ast.Attribute and x.attr in ("__pseudomethod__", self.keyword): # a..b(...) -> b(a, ...)
+          node.args.insert(0, node.func.value.value)
+          node.func = ast.copy_location(
+            ast.Name(node.func.attr, ast.Load()), # new node
+            node.func) # old node
+      for x in ast.iter_child_nodes(node): self.visit(x) # recurse
+      return node
+
+    # tie up loose ends from string replace
+    def visit_Str(self, node):
+      node.s = node.s.replace(".__pseudomethod__.", "..").replace(self.keyword, "__pseudomethod__")
+      return node
+    def visit_Bytes(self, node):
+      node.s = node.s.replace(b".__pseudomethod__.", b"..").replace(self.bkeyword, b"__pseudomethod__")
+      return node
+
+
+
+if not ISPY3K:
+  ######## compiler tools
+  class compiler(object):
+    magic = py3to2_init.importer.magic
+
+    def pre_parse(self, s, _ = "\x00"):
+      s = "\n" + s + "\n"; s = s.replace(self.magic, "\n\n", 1)
+      return s[1:-1] # preserve lineno (for debugging)
+
+    def tree_parse(self, tree):
+      tree = codetree(**tree.__dict__) # copy tree
+      assert 0 <= tree.co_argcount < 0x10000; assert 0 <= tree.co_kwonlyargcount < 0x100
+      tree.co_argcount |= (tree.co_kwonlyargcount << 16) | 0x1000000 # bitshift & then piggyback co_kwonlyargcount to co_argcount
+
+      s = bytearray(tree.co_code); skip = 0; HAVE_ARGUMENT = opcode.HAVE_ARGUMENT; opmap_3to2 = tree.opmap_3to2
+      for i, x in enumerate(s): # map opcodes from 3k to 2x
+        if skip: skip -= 1; continue
+        if x >= HAVE_ARGUMENT: skip = 2
+        if x in opmap_3to2: s[i] = opmap_3to2[x]
+      tree.co_code = bytes(s)
+      tree.co_consts = tuple( self.tree_parse(x) if isinstance(x, codetree) else x for x in tree.co_consts ) # recurse
+      return tree
+
+    def post_parse(self, s):
+      s = s.replace("'__next__'", "'next'") # PEP3114  Renaming iterator.next() to .__next__()
+      return s
+
+    def compile(self, s, fpath, mode, flags = 0, dont_inherit = 0):
+      if not isinstance(s, str): raise TypeError("py3to2 can only compile <str obj> not <%s obj>" % type(s))
+      s = self.pre_parse(s)
+      s = server_compile(s, fpath, mode, flags, dont_inherit)
+      s = self.post_parse(s)
+      self.t = t = __builtin__.eval(s)
+      if isinstance(t, Exception): raise t
+      t = self.tree_parse(t); c = t.compile(); return c
+  __builtin__._compile = compiler().compile
+
+
+
+######## debugging...
+def quicktest():
+  if "py3to2_test" not in sys.modules: import py3to2_test
+  else: reload(py3to2_test)
+
+if 0 and DEBUG and ISPY3K:
+  self = compiler
+  s = "ABC ..echo() ..foo()"
+  s = self.pre_parse(s)
+  n = ast.parse(s, "", "exec")
+  self.ast_parse.printd(n)
+  n = self.ast_parse().visit(n)
+  self.ast_parse.printd(n)
+
+elif 1 and DEBUG and not ISPY3K:
+  pass
+  s = """
+class A:
+  def foo(self): pass
+class B(A):
+  def foo(self): return super().foo()
+B().foo()
+"""
+  c = py3k_compile(s, "", "exec"); t = codetree(c)
+  print( t ); print( t.dis() ); print( s )
+  py3k_exec(c)
diff -Naur src/Modules/_py3to2module.c patched/Modules/_py3to2module.c
--- src/Modules/_py3to2module.c	1969-12-31 16:00:00.000000000 -0800
+++ patched/Modules/_py3to2module.c	2008-11-18 17:16:49.331821000 -0800
@@ -0,0 +1,485 @@
+#include "Python.h"
+#include "Python-ast.h"
+
+#include "node.h"
+#include "code.h"
+#include "eval.h"
+
+#include <ctype.h>
+
+//////////////////////////////////////////////////////////////// py3k beg - header
+#define py3k_PyUnicode_Check(x) PyString_Check(x)
+#define py3k_PyUnicode_AS_UNICODE PyString_AS_STRING
+
+static char *
+source_as_string(PyObject *cmd, char *funcname, char *what)
+{
+	char *str;
+	Py_ssize_t size;
+
+	if (PyUnicode_Check(cmd)) {
+		cmd = _PyUnicode_AsDefaultEncodedString(cmd, NULL);
+		if (cmd == NULL)
+			return NULL;
+	}
+	else if (!PyObject_CheckReadBuffer(cmd)) {
+		PyErr_Format(PyExc_TypeError,
+		  "%s() arg 1 must be a %s object",
+		  funcname, what);
+		return NULL;
+	}
+	if (PyObject_AsReadBuffer(cmd, (const void **)&str, &size) < 0) {
+		return NULL;
+	}
+	if (strlen(str) != size) {
+		PyErr_SetString(PyExc_TypeError,
+				"source code string cannot contain null bytes");
+		return NULL;
+	}
+	return str;
+}
+
+static PyObject *compile(char *str, char *filename, char *mode, int flags, int dont_inherit) {
+	PyObject *func = PyDict_GetItemString(PyEval_GetBuiltins(), "_compile"); // get function
+	if (!(func && PyCallable_Check(func))) {PyErr_SetString(PyExc_NotImplementedError, "py3k_compile"); return NULL;}
+	return PyObject_CallFunction(func, "sssii", str, filename, mode, flags, dont_inherit);
+}
+//////////////////////////////////////////////////////////////// py3k end
+
+static PyObject *
+builtin___build_class__(PyObject *self, PyObject *args, PyObject *kwds)
+{
+	PyObject *func, *name, *bases, *mkw, *meta, *prep, *ns, *cell;
+	PyObject *cls = NULL;
+	Py_ssize_t nargs, nbases;
+
+	assert(args != NULL);
+	if (!PyTuple_Check(args)) {
+		PyErr_SetString(PyExc_TypeError,
+				"__build_class__: args is not a tuple");
+		return NULL;
+	}
+	nargs = PyTuple_GET_SIZE(args);
+	if (nargs < 2) {
+		PyErr_SetString(PyExc_TypeError,
+				"__build_class__: not enough arguments");
+		return NULL;
+	}
+	func = PyTuple_GET_ITEM(args, 0); /* Better be callable */
+	name = PyTuple_GET_ITEM(args, 1);
+	if (!py3k_PyUnicode_Check(name)) {
+		PyErr_SetString(PyExc_TypeError,
+				"__build_class__: name is not a string");
+		return NULL;
+	}
+	bases = PyTuple_GetSlice(args, 2, nargs);
+	if (bases == NULL)
+		return NULL;
+	nbases = nargs - 2;
+
+	if (kwds == NULL) {
+		meta = NULL;
+                mkw = NULL;
+        }
+	else {
+		mkw = PyDict_Copy(kwds); /* Don't modify kwds passed in! */
+		if (mkw == NULL) {
+			Py_DECREF(bases);
+			return NULL;
+		}
+		meta = PyDict_GetItemString(mkw, "metaclass");
+		if (meta != NULL) {
+			Py_INCREF(meta);
+			if (PyDict_DelItemString(mkw, "metaclass") < 0) {
+				Py_DECREF(meta);
+				Py_DECREF(mkw);
+				Py_DECREF(bases);
+				return NULL;
+			}
+		}
+	}
+	if (meta == NULL) {
+		if (PyTuple_GET_SIZE(bases) == 0)
+			meta = (PyObject *) (&PyType_Type);
+		else {
+			PyObject *base0 = PyTuple_GET_ITEM(bases, 0);
+			meta = (PyObject *) (base0->ob_type);
+		}
+		Py_INCREF(meta);
+	}
+	prep = PyObject_GetAttrString(meta, "__prepare__");
+	if (prep == NULL) {
+		PyErr_Clear();
+		ns = PyDict_New();
+	}
+	else {
+		PyObject *pargs = Py_BuildValue("OO", name, bases);
+		if (pargs == NULL) {
+			Py_DECREF(prep);
+			Py_DECREF(meta);
+			Py_XDECREF(mkw);
+			Py_DECREF(bases);
+			return NULL;
+		}
+		ns = PyEval_CallObjectWithKeywords(prep, pargs, mkw);
+		Py_DECREF(pargs);
+		Py_DECREF(prep);
+		if (ns == NULL) {
+			Py_DECREF(meta);
+			Py_XDECREF(mkw);
+			Py_DECREF(bases);
+			return NULL;
+		}
+	}
+	cell = PyObject_CallFunctionObjArgs(func, ns, NULL);
+	if (cell != NULL) {
+		PyObject *margs;
+		margs = Py_BuildValue("OOO", name, bases, ns);
+		if (margs != NULL) {
+			cls = PyEval_CallObjectWithKeywords(meta, margs, mkw);
+			Py_DECREF(margs);
+		}
+		if (cls != NULL && PyCell_Check(cell)) {
+			Py_INCREF(cls);
+			PyCell_SET(cell, cls);
+		}
+		Py_DECREF(cell);
+	}
+	Py_DECREF(ns);
+	Py_DECREF(meta);
+	Py_XDECREF(mkw);
+	Py_DECREF(bases);
+	return cls;
+}
+
+PyDoc_STRVAR(build_class_doc,
+"__build_class__(func, name, *bases, metaclass=None, **kwds) -> class\n\
+\n\
+Internal helper function used by the class statement.");
+
+static PyObject *
+builtin_compile(PyObject *self, PyObject *args, PyObject *kwds)
+{
+	char *str;
+	char *filename;
+	char *startstr;
+	int mode = -1;
+	int dont_inherit = 0;
+	int supplied_flags = 0;
+	PyCompilerFlags cf;
+	PyObject *cmd;
+	static char *kwlist[] = {"source", "filename", "mode", "flags",
+				 "dont_inherit", NULL};
+	// int start[] = {Py_file_input, Py_eval_input, Py_single_input};
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oss|ii:compile",
+					 kwlist, &cmd, &filename, &startstr,
+					 &supplied_flags, &dont_inherit))
+		return NULL;
+
+	cf.cf_flags = supplied_flags | PyCF_SOURCE_IS_UTF8;
+
+	if (supplied_flags &
+	    ~(PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST))
+	{
+		PyErr_SetString(PyExc_ValueError,
+				"compile(): unrecognised flags");
+		return NULL;
+	}
+	/* XXX Warn if (supplied_flags & PyCF_MASK_OBSOLETE) != 0? */
+
+	if (!dont_inherit) {
+		PyEval_MergeCompilerFlags(&cf);
+	}
+
+	if (strcmp(startstr, "exec") == 0)
+		mode = 0;
+	else if (strcmp(startstr, "eval") == 0)
+		mode = 1;
+	else if (strcmp(startstr, "single") == 0)
+		mode = 2;
+	else {
+		PyErr_SetString(PyExc_ValueError,
+				"compile() arg 3 must be 'exec', 'eval' or 'single'");
+		return NULL;
+	}
+
+	if (PyAST_Check(cmd)) {
+		PyObject *result;
+		if (supplied_flags & PyCF_ONLY_AST) {
+			Py_INCREF(cmd);
+			result = cmd;
+		}
+		else {
+			PyArena *arena;
+			mod_ty mod;
+
+			arena = PyArena_New();
+			mod = PyAST_obj2mod(cmd, arena, mode);
+			if (mod == NULL) {
+				PyArena_Free(arena);
+				return NULL;
+			}
+			result = (PyObject*)PyAST_Compile(mod, filename,
+							  &cf, arena);
+			PyArena_Free(arena);
+		}
+		return result;
+	}
+
+	str = source_as_string(cmd, "compile", "string, bytes, AST or code");
+	if (str == NULL)
+		return NULL;
+
+	return compile(str, filename, startstr, supplied_flags, dont_inherit); // py3k
+	// return Py_CompileStringFlags(str, filename, start[mode], &cf);
+}
+
+PyDoc_STRVAR(compile_doc,
+"compile(source, filename, mode[, flags[, dont_inherit]]) -> code object\n\
+\n\
+Compile the source string (a Python module, statement or expression)\n\
+into a code object that can be executed by exec() or eval().\n\
+The filename will be used for run-time error messages.\n\
+The mode must be 'exec' to compile a module, 'single' to compile a\n\
+single (interactive) statement, or 'eval' to compile an expression.\n\
+The flags argument, if present, controls which future statements influence\n\
+the compilation of the code.\n\
+The dont_inherit argument, if non-zero, stops the compilation inheriting\n\
+the effects of any future statements in effect in the code calling\n\
+compile; if absent or zero these statements do influence the compilation,\n\
+in addition to any features explicitly specified.");
+
+static PyObject *
+builtin_eval(PyObject *self, PyObject *args)
+{
+	PyObject *cmd;
+	// PyObject *cmd, *result, *tmp = NULL;
+	PyObject *globals = Py_None, *locals = Py_None;
+	// char *str;
+	// PyCompilerFlags cf;
+
+	if (!PyArg_UnpackTuple(args, "eval", 1, 3, &cmd, &globals, &locals))
+		return NULL;
+	if (locals != Py_None && !PyMapping_Check(locals)) {
+		PyErr_SetString(PyExc_TypeError, "locals must be a mapping");
+		return NULL;
+	}
+	if (globals != Py_None && !PyDict_Check(globals)) {
+		PyErr_SetString(PyExc_TypeError, PyMapping_Check(globals) ?
+			"globals must be a real dict; try eval(expr, {}, mapping)"
+			: "globals must be a dict");
+		return NULL;
+	}
+	if (globals == Py_None) {
+		globals = PyEval_GetGlobals();
+		if (locals == Py_None)
+			locals = PyEval_GetLocals();
+	}
+	else if (locals == Py_None)
+		locals = globals;
+
+	if (globals == NULL || locals == NULL) {
+		PyErr_SetString(PyExc_TypeError, 
+			"eval must be given globals and locals "
+			"when called without a frame");
+		return NULL;
+	}
+
+	if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
+		if (PyDict_SetItemString(globals, "__builtins__",
+					 PyEval_GetBuiltins()) != 0)
+			return NULL;
+	}
+
+	if (!PyCode_Check(cmd)) { // py3k
+		char *str = source_as_string(cmd, "eval", "string, bytes or code"); // py3k
+		if((cmd = compile(str, "", "eval", 0, 0)) == NULL) return NULL; // py3k
+	} // py3k
+
+	// if (PyCode_Check(cmd)) {
+		if (PyCode_GetNumFree((PyCodeObject *)cmd) > 0) {
+			PyErr_SetString(PyExc_TypeError,
+		"code object passed to eval() may not contain free variables");
+			return NULL;
+		}
+		return PyEval_EvalCode((PyCodeObject *) cmd, globals, locals);
+	// }
+
+	// str = source_as_string(cmd, "eval", "string, bytes or code");
+	// if (str == NULL)
+		// return NULL;
+
+	// while (*str == ' ' || *str == '\t')
+		// str++;
+
+	// cf.cf_flags = PyCF_SOURCE_IS_UTF8;
+	// (void)PyEval_MergeCompilerFlags(&cf);
+	// result = PyRun_StringFlags(str, Py_eval_input, globals, locals, &cf);
+	// Py_XDECREF(tmp);
+	// return result;
+}
+
+PyDoc_STRVAR(eval_doc,
+"eval(source[, globals[, locals]]) -> value\n\
+\n\
+Evaluate the source in the context of globals and locals.\n\
+The source may be a string representing a Python expression\n\
+or a code object as returned by compile().\n\
+The globals must be a dictionary and locals can be any mapping,\n\
+defaulting to the current globals and locals.\n\
+If only globals is given, locals defaults to it.\n");
+
+static PyObject *
+builtin_exec(PyObject *self, PyObject *args)
+{
+	PyObject *v;
+	PyObject *prog, *globals = Py_None, *locals = Py_None;
+	int plain = 0;
+
+	if (!PyArg_ParseTuple(args, "O|OO:exec", &prog, &globals, &locals))
+		return NULL;
+	
+	if (globals == Py_None) {
+		globals = PyEval_GetGlobals();
+		if (locals == Py_None) {
+			locals = PyEval_GetLocals();
+			plain = 1;
+		}
+		if (!globals || !locals) {
+			PyErr_SetString(PyExc_SystemError,
+					"globals and locals cannot be NULL");
+			return NULL;
+		}
+	}
+	else if (locals == Py_None)
+		locals = globals;
+
+	if (!PyDict_Check(globals)) {
+		PyErr_Format(PyExc_TypeError, "exec() arg 2 must be a dict, not %.100s",
+			     globals->ob_type->tp_name);
+		return NULL;
+	}
+	if (!PyMapping_Check(locals)) {
+		PyErr_Format(PyExc_TypeError,
+		    "arg 3 must be a mapping or None, not %.100s",
+		    locals->ob_type->tp_name);
+		return NULL;
+	}
+	if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
+		if (PyDict_SetItemString(globals, "__builtins__",
+					 PyEval_GetBuiltins()) != 0)
+			return NULL;
+	}
+
+	if (!PyCode_Check(prog)) { // py3k
+		char *str = source_as_string(prog, "exec", "string, bytes or code"); // py3k
+		if((prog = compile(str, "", "exec", 0, 0)) == NULL) return NULL; // py3k
+	} // py3k
+
+	// if (PyCode_Check(prog)) {
+		if (PyCode_GetNumFree((PyCodeObject *)prog) > 0) {
+			PyErr_SetString(PyExc_TypeError,
+				"code object passed to exec() may not "
+				"contain free variables");
+			return NULL;
+		}
+		v = PyEval_EvalCode((PyCodeObject *) prog, globals, locals);
+	// }
+	// else {
+		// char *str = source_as_string(prog, "exec",
+					     // "string, bytes or code");
+		// PyCompilerFlags cf;
+		// if (str == NULL)
+			// return NULL;
+		// cf.cf_flags = PyCF_SOURCE_IS_UTF8;
+		// if (PyEval_MergeCompilerFlags(&cf))
+			// v = PyRun_StringFlags(str, Py_file_input, globals,
+					      // locals, &cf);
+		// else
+			// v = PyRun_String(str, Py_file_input, globals, locals);
+	// }
+	if (v == NULL)
+		return NULL;
+	Py_DECREF(v);
+	Py_RETURN_NONE;
+}
+
+PyDoc_STRVAR(exec_doc,
+"exec(object[, globals[, locals]])\n\
+\n\
+Read and execute code from a object, which can be a string, a code\n\
+object or a file object.\n\
+The globals and locals are dictionaries, defaulting to the current\n\
+globals and locals.  If only globals is given, locals defaults to it.");
+
+static PyMethodDef builtin_methods[] = {
+ 	{"__build_class__", (PyCFunction)builtin___build_class__,
+         METH_VARARGS | METH_KEYWORDS, build_class_doc},
+ 	// {"__import__",	(PyCFunction)builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc},
+ 	// {"abs",		builtin_abs,        METH_O, abs_doc},
+ 	// {"all",		builtin_all,        METH_O, all_doc},
+ 	// {"any",		builtin_any,        METH_O, any_doc},
+ 	// {"ascii",	builtin_ascii,      METH_O, ascii_doc},
+	// {"bin",		builtin_bin,	    METH_O, bin_doc},
+ 	// {"chr",		builtin_chr,        METH_VARARGS, chr_doc},
+ 	// {"cmp",		builtin_cmp,        METH_VARARGS, cmp_doc},
+ 	{"compile",	(PyCFunction)builtin_compile,    METH_VARARGS | METH_KEYWORDS, compile_doc},
+ 	// {"delattr",	builtin_delattr,    METH_VARARGS, delattr_doc},
+ 	// {"dir",		builtin_dir,        METH_VARARGS, dir_doc},
+ 	// {"divmod",	builtin_divmod,     METH_VARARGS, divmod_doc},
+ 	{"eval",	builtin_eval,       METH_VARARGS, eval_doc},
+	{"exec",        builtin_exec,       METH_VARARGS, exec_doc},
+ 	// {"format",	builtin_format,     METH_VARARGS, format_doc},
+ 	// {"getattr",	builtin_getattr,    METH_VARARGS, getattr_doc},
+ 	// {"globals",	(PyCFunction)builtin_globals,    METH_NOARGS, globals_doc},
+ 	// {"hasattr",	builtin_hasattr,    METH_VARARGS, hasattr_doc},
+ 	// {"hash",	builtin_hash,       METH_O, hash_doc},
+ 	// {"hex",		builtin_hex,        METH_O, hex_doc},
+ 	// {"id",		builtin_id,         METH_O, id_doc},
+ 	// {"input",	builtin_input,      METH_VARARGS, input_doc},
+ 	// {"isinstance",  builtin_isinstance, METH_VARARGS, isinstance_doc},
+ 	// {"issubclass",  builtin_issubclass, METH_VARARGS, issubclass_doc},
+ 	// {"iter",	builtin_iter,       METH_VARARGS, iter_doc},
+ 	// {"len",		builtin_len,        METH_O, len_doc},
+ 	// {"locals",	(PyCFunction)builtin_locals,     METH_NOARGS, locals_doc},
+ 	// {"max",		(PyCFunction)builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc},
+ 	// {"min",		(PyCFunction)builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc},
+	// {"next",	(PyCFunction)builtin_next,       METH_VARARGS, next_doc},
+ 	// {"oct",		builtin_oct,        METH_O, oct_doc},
+ 	// {"ord",		builtin_ord,        METH_O, ord_doc},
+ 	// {"pow",		builtin_pow,        METH_VARARGS, pow_doc},
+ 	// {"print",	(PyCFunction)builtin_print,      METH_VARARGS | METH_KEYWORDS, print_doc},
+ 	// {"repr",	builtin_repr,       METH_O, repr_doc},
+ 	// {"round",	(PyCFunction)builtin_round,      METH_VARARGS | METH_KEYWORDS, round_doc},
+ 	// {"setattr",	builtin_setattr,    METH_VARARGS, setattr_doc},
+ 	// {"sorted",	(PyCFunction)builtin_sorted,     METH_VARARGS | METH_KEYWORDS, sorted_doc},
+ 	// {"sum",		builtin_sum,        METH_VARARGS, sum_doc},
+ 	// {"vars",	builtin_vars,       METH_VARARGS, vars_doc},
+	{NULL,		NULL},
+};
+
+PyDoc_STRVAR(builtin_doc,
+"py3to2 Built-in functions, exceptions, and other objects");
+
+// PyObject *initpy3k_builtins(void) {
+				// return Py_InitModule("py3k_builtins", builtin_methods);
+// }
+// PyMODINIT_FUNC inittiming(void)
+// {
+    // if (PyErr_WarnPy3k("the timing module has been removed in "
+                        // "Python 3.0; use time.clock() instead", 2) < 0)
+        // return;
+   //  
+	// (void)Py_InitModule("timing", timing_methods);
+// }
+
+PyMODINIT_FUNC init_py3to2(void)
+{
+	PyObject *mod;
+	mod = Py_InitModule4("_py3to2", builtin_methods,
+			     builtin_doc, (PyObject *)NULL,
+			     PYTHON_API_VERSION);
+	if (mod == NULL)
+		return NULL;
+}
diff -Naur src/Modules/Setup.local patched/Modules/Setup.local
--- src/Modules/Setup.local	1969-12-31 16:00:00.000000000 -0800
+++ patched/Modules/Setup.local	2008-11-17 19:01:38.788807000 -0800
@@ -0,0 +1,2 @@
+# Edit this file for local setup changes
+_py3to2 _py3to2module.o
diff -Naur src/Objects/funcobject.c patched/Objects/funcobject.c
--- src/Objects/funcobject.c	2008-06-08 21:58:54.000000000 -0700
+++ patched/Objects/funcobject.c	2008-11-17 19:01:13.840722000 -0800
@@ -526,7 +526,7 @@
 		PyFunction_GET_GLOBALS(func), (PyObject *)NULL,
 		&PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
 		k, nk, d, nd,
-		PyFunction_GET_CLOSURE(func));
+		func); // py3k - replace func->closure w/ func
 
 	if (k != NULL)
 		PyMem_DEL(k);
diff -Naur src/Objects/typeobject.c patched/Objects/typeobject.c
--- src/Objects/typeobject.c	2008-08-26 15:42:08.000000000 -0700
+++ patched/Objects/typeobject.c	2008-11-20 18:46:56.539657000 -0800
@@ -6553,18 +6553,85 @@
 	}
 }
 
+//////////////////////////////////////////////////////////////// py3k beg - PEP3135  New Super
+#include "frameobject.h" // py3k
+#define PyCode_GETARGCOUNT(co) ((co)->co_argcount & 0xffff) // py3k - retrieve co_argcount w/ metaflag removed
+
 static int
 super_init(PyObject *self, PyObject *args, PyObject *kwds)
 {
 	superobject *su = (superobject *)self;
-	PyTypeObject *type;
+	PyTypeObject *type = NULL; // py3k
 	PyObject *obj = NULL;
 	PyTypeObject *obj_type = NULL;
 
 	if (!_PyArg_NoKeywords("super", kwds))
 		return -1;
-	if (!PyArg_ParseTuple(args, "O!|O:super", &PyType_Type, &type, &obj))
+	if (!PyArg_ParseTuple(args, "|O!O:super", &PyType_Type, &type, &obj)) // py3k
 		return -1;
+
+        if (type == NULL) {
+		/* Call super(), without args -- fill in from __class__
+		   and first local variable on the stack. */
+		PyFrameObject *f = PyThreadState_GET()->frame;
+		PyCodeObject *co = f->f_code;
+		int i, n;
+		if (co == NULL) {
+			PyErr_SetString(PyExc_SystemError,
+					"super(): no code object");
+			return -1;
+		}
+		if (PyCode_GETARGCOUNT(co) == 0) { // py3k
+			PyErr_SetString(PyExc_SystemError,
+					"super(): no arguments");
+			return -1;
+		}
+		obj = f->f_localsplus[0];
+		if (obj == NULL) {
+			PyErr_SetString(PyExc_SystemError,
+					"super(): arg[0] deleted");
+			return -1;
+		}
+		if (co->co_freevars == NULL)
+			n = 0;
+		else {
+			assert(PyTuple_Check(co->co_freevars));
+			n = PyTuple_GET_SIZE(co->co_freevars);
+		}
+		for (i = 0; i < n; i++) {
+			PyObject *name = PyTuple_GET_ITEM(co->co_freevars, i);
+			assert(PyString_Check(name)); // py3k
+                        if (!strcmp(PyString_AS_STRING(name), "__class__")) { // py3k
+				Py_ssize_t index = co->co_nlocals + // py3k
+					PyTuple_GET_SIZE(co->co_cellvars) + i; // py3k
+				PyObject *cell = f->f_localsplus[index]; // py3k
+				if (cell == NULL || !PyCell_Check(cell)) {
+					PyErr_SetString(PyExc_SystemError,
+					  "super(): bad __class__ cell");
+					return -1;
+				}
+				type = (PyTypeObject *) PyCell_GET(cell);
+				if (type == NULL) {
+					PyErr_SetString(PyExc_SystemError,
+					  "super(): empty __class__ cell");
+					return -1;
+				}
+				if (!PyType_Check(type)) {
+				    PyErr_Format(PyExc_SystemError,
+				      "super(): __class__ is not a type (%s)",
+				      Py_TYPE(type)->tp_name);
+				    return -1;
+				}
+				break;
+			}
+		}
+		if (type == NULL) {
+			PyErr_SetString(PyExc_SystemError,
+					"super(): __class__ cell not found");
+			return -1;
+		}
+        }
+
 	if (obj == Py_None)
 		obj = NULL;
 	if (obj != NULL) {
@@ -6581,13 +6648,20 @@
 }
 
 PyDoc_STRVAR(super_doc,
+"super() -> same as super(__class__, <first argument>)\n"
 "super(type) -> unbound super object\n"
 "super(type, obj) -> bound super object; requires isinstance(obj, type)\n"
 "super(type, type2) -> bound super object; requires issubclass(type2, type)\n"
 "Typical use to call a cooperative superclass method:\n"
 "class C(B):\n"
 "    def meth(self, arg):\n"
-"	 super(C, self).meth(arg)");
+"	 super().meth(arg)\n"
+"This works for class methods too:\n"
+"class C(B):\n"
+"    @classmethod\n"
+"    def cmeth(cls, arg):\n"
+"	 super().cmeth(arg)\n");
+//////////////////////////////////////////////////////////////// py3k end
 
 static int
 super_traverse(PyObject *self, visitproc visit, void *arg)
diff -Naur src/Python/ceval.c patched/Python/ceval.c
--- src/Python/ceval.c	2008-07-25 15:13:52.000000000 -0700
+++ patched/Python/ceval.c	2008-11-22 11:06:37.402459000 -0800
@@ -19,6 +19,138 @@
 
 #include <ctype.h>
 
+//////////////////////////////////////////////////////////////// py3k beg - header
+// new opcodes
+#define py3k_SET_ADD 17 // 17 in py3k
+#define py3k_STORE_LOCALS 69 // 69 in py3k
+#define py3k_LOAD_BUILD_CLASS 34 // 71 in py3k
+#define py3k_MAKE_BYTES 35 // 85 in py3k
+#define py3k_POP_EXCEPT 36 // 89 in py3k
+#define py3k_UNPACK_EX 94 // 94 in py3k
+#define py3k_BUILD_SET 192 // 104 in py3k
+#define py3k_MAKE_FUNCTION 193 // 132 in py2x - replace MAKE_FUNCTION
+
+// macros
+#define PyCode_ISPY3K(co) ((co)->co_argcount & 0xffff0000) // check if py3k codeobj
+#define PyCode_GETARGCOUNT(co) ((co)->co_argcount & 0xffff) // retrieve co_argcount w/ metaflag removed
+#define PyCode_GETKWONLYARGCOUNT(co) (((co)->co_argcount >> 16) & 0xff) // get kwonlyargcount from metaflag
+#define PyFunction_SetAnnotations(x, v) PyObject_SetAttrString(x, "__annotations__", v)
+#define PyFunction_SetKwDefaults(x, v) PyObject_SetAttrString(x, "__kwdefaults__", v)
+
+// helper functions
+PyObject *PyFunction_GET_KW_DEFAULTS(PyObject *obj) { // body derived from PyObject_GenericGetAttr
+	PyTypeObject *tp = Py_TYPE(obj);
+	PyObject *descr = NULL;
+	PyObject *res = NULL;
+	Py_ssize_t dictoffset;
+	PyObject **dictptr;
+
+	/* Inline _PyObject_GetDictPtr */
+	dictoffset = tp->tp_dictoffset;
+	if (dictoffset != 0) {
+		PyObject *dict;
+		if (dictoffset < 0) {
+			Py_ssize_t tsize;
+			size_t size;
+
+			tsize = ((PyVarObject *)obj)->ob_size;
+			if (tsize < 0)
+				tsize = -tsize;
+			size = _PyObject_VAR_SIZE(tp, tsize);
+
+			dictoffset += (long)size;
+			assert(dictoffset > 0);
+			assert(dictoffset % SIZEOF_VOID_P == 0);
+		}
+		dictptr = (PyObject **) ((char *)obj + dictoffset);
+		dict = *dictptr;
+		if (dict != NULL) {
+			Py_INCREF(dict);
+			res = PyDict_GetItemString(dict, "__kwdefaults__");
+			if (res != NULL) {
+				// Py_INCREF(res); // py3k
+				Py_XDECREF(descr);
+                                Py_DECREF(dict);
+			}
+                        Py_DECREF(dict);
+		}
+	}
+	return res;
+}
+
+static int // py3k - patched w/ PEP3132  Extended Iterable Unpacking
+py3k_unpack_iterable(PyObject *v, int argcnt, int argcntafter, PyObject **sp)
+{
+	int i = 0, j = 0;
+	Py_ssize_t ll = 0;
+	PyObject *it;  /* iter(v) */
+	PyObject *w;
+	PyObject *l = NULL; /* variable list */
+
+	assert(v != NULL);
+
+	it = PyObject_GetIter(v);
+	if (it == NULL)
+		goto Error;
+
+	for (; i < argcnt; i++) {
+		w = PyIter_Next(it);
+		if (w == NULL) {
+			/* Iterator done, via error or exhaustion. */
+			if (!PyErr_Occurred()) {
+				PyErr_Format(PyExc_ValueError,
+					"need more than %d value%s to unpack",
+					i, i == 1 ? "" : "s");
+			}
+			goto Error;
+		}
+		*--sp = w;
+	}
+
+	if (argcntafter == -1) {
+		/* We better have exhausted the iterator now. */
+		w = PyIter_Next(it);
+		if (w == NULL) {
+			if (PyErr_Occurred())
+				goto Error;
+			Py_DECREF(it);
+			return 1;
+		}
+		Py_DECREF(w);
+		PyErr_SetString(PyExc_ValueError, "too many values to unpack");
+		goto Error;
+	}
+
+	l = PySequence_List(it);
+	if (l == NULL)
+		goto Error;
+	*--sp = l;
+	i++;
+
+	ll = PyList_GET_SIZE(l);
+	if (ll < argcntafter) {
+		PyErr_Format(PyExc_ValueError, "need more than %zd values to unpack",
+			     argcnt + ll);
+		goto Error;
+	}
+
+	/* Pop the "after-variable" args off the list. */
+	for (j = argcntafter; j > 0; j--, i++) {
+		*--sp = PyList_GET_ITEM(l, ll - j);
+	}
+	/* Resize the list. */
+	Py_SIZE(l) = ll - argcntafter;
+	Py_DECREF(it);
+	return 1;
+
+Error:
+	for (; i > 0; i--, sp++)
+		Py_DECREF(*sp);
+	Py_XDECREF(it);
+	return 0;
+}
+//////////////////////////////////////////////////////////////// py3k end
+
 #ifndef WITH_TSC
 
 #define READ_TIMESTAMP(var)
@@ -2492,6 +2624,156 @@
 			oparg = oparg<<16 | NEXTARG();
 			goto dispatch_opcode;
 
+		//////////////////////////////////////////////////////////////// py3k beg - add new opcodes here
+		if PyCode_ISPY3K(co) { // only run these opcodes if py3k flag bit is set
+		case py3k_SET_ADD:
+			w = POP();
+			v = POP();
+			err = PySet_Add(v, w);
+			Py_DECREF(v);
+			Py_DECREF(w);
+			if (err == 0) {
+				PREDICT(JUMP_ABSOLUTE);
+				continue;
+			}
+			break;
+
+		case py3k_STORE_LOCALS:
+			x = POP();
+			v = f->f_locals;
+			Py_XDECREF(v);
+			f->f_locals = x;
+			continue;
+
+		case py3k_LOAD_BUILD_CLASS:
+			x = PyDict_GetItemString(f->f_builtins,
+						 "__build_class__");
+			if (x == NULL) {
+				PyErr_SetString(PyExc_ImportError,
+						"__build_class__ not found");
+				break;
+			}
+			Py_INCREF(x);
+			PUSH(x);
+			break;
+
+		// case py3k_MAKE_BYTES - unused
+
+		// case py3k_POP_EXCEPT - unused
+
+		case py3k_UNPACK_EX:
+		{
+			int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);
+			v = POP();
+
+			if (py3k_unpack_iterable(v, oparg & 0xFF, oparg >> 8,
+					    stack_pointer + totalargs)) {
+				stack_pointer += totalargs;
+			} else {
+				why = WHY_EXCEPTION;
+			}
+			Py_DECREF(v);
+			break;
+		}
+
+		case py3k_BUILD_SET:
+			x = PySet_New(NULL);
+			if (x != NULL) {
+				for (; --oparg >= 0;) {
+					w = POP();
+					if (err == 0)
+						err = PySet_Add(x, w);
+					Py_DECREF(w);
+				}
+				if (err != 0) {
+					Py_DECREF(x);
+					break;
+				}
+				PUSH(x);
+				continue;
+			}
+			break;
+
+		case py3k_MAKE_FUNCTION:
+		{
+		    int posdefaults = oparg & 0xff;
+		    int kwdefaults = (oparg>>8) & 0xff;
+		    int num_annotations = (oparg >> 16) & 0x7fff;
+
+			v = POP(); /* code object */
+			x = PyFunction_New(v, f->f_globals);
+			Py_DECREF(v);
+
+			if (x != NULL && opcode == MAKE_CLOSURE) {
+				v = POP();
+				err = PyFunction_SetClosure(x, v);
+				Py_DECREF(v);
+			}
+
+			if (x != NULL && num_annotations > 0) {
+				Py_ssize_t name_ix;
+				u = POP(); /* names of args with annotations */
+				v = PyDict_New();
+				if (v == NULL) {
+					Py_DECREF(x);
+					x = NULL;
+					break;
+				}
+				name_ix = PyTuple_Size(u);
+				assert(num_annotations == name_ix+1);
+				while (name_ix > 0) {
+					--name_ix;
+					t = PyTuple_GET_ITEM(u, name_ix);
+					w = POP();
+					/* XXX(nnorwitz): check for errors */
+					PyDict_SetItem(v, t, w);
+					Py_DECREF(w);
+				}
+
+				err = PyFunction_SetAnnotations(x, v);
+				Py_DECREF(v);
+				Py_DECREF(u);
+			}
+
+			/* XXX Maybe this should be a separate opcode? */
+			if (x != NULL && posdefaults > 0) {
+				v = PyTuple_New(posdefaults);
+				if (v == NULL) {
+					Py_DECREF(x);
+					x = NULL;
+					break;
+				}
+				while (--posdefaults >= 0) {
+					w = POP();
+					PyTuple_SET_ITEM(v, posdefaults, w);
+				}
+				err = PyFunction_SetDefaults(x, v);
+				Py_DECREF(v);
+			}
+			if (x != NULL && kwdefaults > 0) {
+				v = PyDict_New();
+				if (v == NULL) {
+					Py_DECREF(x);
+					x = NULL;
+					break;
+				}
+				while (--kwdefaults >= 0) {
+					w = POP(); /* default value */
+					u = POP(); /* kw only arg name */
+					/* XXX(nnorwitz): check for errors */
+					PyDict_SetItem(v, u, w);
+					Py_DECREF(w);
+					Py_DECREF(u);
+				}
+				err = PyFunction_SetKwDefaults(x, v);
+				Py_DECREF(v);
+			}
+			PUSH(x);
+			break;
+		}
+		}
+		//////////////////////////////////////////////////////////////// py3k end
+
 		default:
 			fprintf(stderr,
 				"XXX lineno: %d, opcode: %d\n",
@@ -2712,6 +2994,13 @@
 	   PyObject **args, int argcount, PyObject **kws, int kwcount,
 	   PyObject **defs, int defcount, PyObject *closure)
 {
+	// py3k beg
+	int co_argcount = PyCode_GETARGCOUNT(co);
+	int co_kwonlyargcount = PyCode_GETKWONLYARGCOUNT(co);
+	int co_argcount_all = co_argcount + co_kwonlyargcount;
+	PyObject *kwdefs = closure; // recall fast_function passed func instead of func->closure
+	if (closure != NULL && PyFunction_Check(closure)) closure = PyFunction_GET_CLOSURE(closure);
+	// py3k end
 	register PyFrameObject *f;
 	register PyObject *retval = NULL;
 	register PyObject **fastlocals, **freevars;
@@ -2733,7 +3022,7 @@
 	fastlocals = f->f_localsplus;
 	freevars = f->f_localsplus + co->co_nlocals;
 
-	if (co->co_argcount > 0 ||
+	if (co_argcount_all > 0 ||
 	    co->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) {
 		int i;
 		int n = argcount;
@@ -2742,25 +3031,25 @@
 			kwdict = PyDict_New();
 			if (kwdict == NULL)
 				goto fail;
-			i = co->co_argcount;
+			i = co_argcount_all; // py3k
 			if (co->co_flags & CO_VARARGS)
 				i++;
 			SETLOCAL(i, kwdict);
 		}
-		if (argcount > co->co_argcount) {
+		if (argcount > co_argcount) {
 			if (!(co->co_flags & CO_VARARGS)) {
 				PyErr_Format(PyExc_TypeError,
 				    "%.200s() takes %s %d "
 				    "%sargument%s (%d given)",
 				    PyString_AsString(co->co_name),
 				    defcount ? "at most" : "exactly",
-				    co->co_argcount,
+				    co_argcount,
 				    kwcount ? "non-keyword " : "",
-				    co->co_argcount == 1 ? "" : "s",
+				    co_argcount == 1 ? "" : "s",
 				    argcount);
 				goto fail;
 			}
-			n = co->co_argcount;
+			n = co_argcount;
 		}
 		for (i = 0; i < n; i++) {
 			x = args[i];
@@ -2771,7 +3060,7 @@
 			u = PyTuple_New(argcount - n);
 			if (u == NULL)
 				goto fail;
-			SETLOCAL(co->co_argcount, u);
+			SETLOCAL(co_argcount_all, u); // py3k
 			for (i = n; i < argcount; i++) {
 				x = args[i];
 				Py_INCREF(x);
@@ -2792,13 +3081,13 @@
 			/* Speed hack: do raw pointer compares. As names are
 			   normally interned this should almost always hit. */
 			co_varnames = PySequence_Fast_ITEMS(co->co_varnames);
-			for (j = 0; j < co->co_argcount; j++) {
+			for (j = 0; j < co_argcount_all; j++) { // py3k
 				PyObject *nm = co_varnames[j];
 				if (nm == keyword)
 					goto kw_found;
 			}
 			/* Slow fallback, just in case */
-			for (j = 0; j < co->co_argcount; j++) {
+			for (j = 0; j < co_argcount_all; j++) { // py3k
 				PyObject *nm = co_varnames[j];
 				int cmp = PyObject_RichCompareBool(
 					keyword, nm, Py_EQ);
@@ -2810,7 +3099,7 @@
 			/* Check errors from Compare */
 			if (PyErr_Occurred())
 				goto fail;
-			if (j >= co->co_argcount) {
+			if (j >= co_argcount_all) { // py3k
 				if (kwdict == NULL) {
 					PyErr_Format(PyExc_TypeError,
 					    "%.200s() got an unexpected "
@@ -2835,8 +3124,33 @@
 			Py_INCREF(value);
 			SETLOCAL(j, value);
 		}
-		if (argcount < co->co_argcount) {
-			int m = co->co_argcount - defcount;
+		// py3k beg - PEP3102  Keyword-Only Arguments
+		if (co_kwonlyargcount > 0) {
+			if (kwdefs != NULL) kwdefs = PyFunction_GET_KW_DEFAULTS(kwdefs); // py3k - deferred this expensive operation
+			for (i = co_argcount;
+			     i < co_argcount_all; // py3k
+			     i++) {
+				PyObject *name, *def;
+				if (GETLOCAL(i) != NULL)
+					continue;
+				name = PyTuple_GET_ITEM(co->co_varnames, i);
+				def = NULL;
+				if (kwdefs != NULL)
+					def = PyDict_GetItem(kwdefs, name);
+				if (def != NULL) {
+					Py_INCREF(def);
+					SETLOCAL(i, def);
+					continue;
+				}
+				PyErr_Format(PyExc_TypeError,
+					"%.200s() needs keyword-only argument %s", // py3k
+					PyString_AsString(co->co_name), PyString_AsString(name)); // py3k
+				goto fail;
+			}
+		}
+		// py3k end
+		if (argcount < co_argcount) {
+			int m = co_argcount - defcount;
 			for (i = argcount; i < m; i++) {
 				if (GETLOCAL(i) == NULL) {
 					PyErr_Format(PyExc_TypeError,
@@ -2880,7 +3194,7 @@
 		char *cellname, *argname;
 		PyObject *c;
 
-		nargs = co->co_argcount;
+		nargs = co_argcount_all; // py3k
 		if (co->co_flags & CO_VARARGS)
 			nargs++;
 		if (co->co_flags & CO_VARKEYWORDS)
@@ -3736,7 +4050,7 @@
 
 	PCALL(PCALL_FUNCTION);
 	PCALL(PCALL_FAST_FUNCTION);
-	if (argdefs == NULL && co->co_argcount == n && nk==0 &&
+	if (argdefs == NULL && PyCode_GETARGCOUNT(co) == n && PyCode_GETKWONLYARGCOUNT(co) == 0 && nk==0 && // py3k
 	    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
 		PyFrameObject *f;
 		PyObject *retval = NULL;
@@ -3775,7 +4089,7 @@
 	return PyEval_EvalCodeEx(co, globals,
 				 (PyObject *)NULL, (*pp_stack)-n, na,
 				 (*pp_stack)-2*nk, nk, d, nd,
-				 PyFunction_GET_CLOSURE(func));
+				 func); // py3k - replace func->closure w/ func
 }
 
 static PyObject *
diff -Naur src/Python/pythonrun.c patched/Python/pythonrun.c
--- src/Python/pythonrun.c	2008-08-23 22:04:52.000000000 -0700
+++ patched/Python/pythonrun.c	2008-11-17 23:28:09.731330000 -0800
@@ -353,6 +353,7 @@
 Py_Initialize(void)
 {
 	Py_InitializeEx(1);
+	PyRun_SimpleString("import py3to2_init"); // py3k
 }
 
 
