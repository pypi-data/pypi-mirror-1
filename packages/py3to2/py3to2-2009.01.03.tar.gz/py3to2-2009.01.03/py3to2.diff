diff -Naur src/Include/code.h patched/Include/code.h
--- src/Include/code.h	2008-03-26 15:01:37.000000000 -0700
+++ patched/Include/code.h	2009-01-04 00:41:44.000000000 -0800
@@ -10,6 +10,7 @@
 typedef struct {
     PyObject_HEAD
     int co_argcount;		/* #arguments, except *args */
+    int co_kwonlyargcount;	/* #keyword only arguments */ // py3k
     int co_nlocals;		/* #local variables */
     int co_stacksize;		/* #entries needed for evaluation stack */
     int co_flags;		/* CO_..., see below */
diff -Naur src/Include/funcobject.h patched/Include/funcobject.h
--- src/Include/funcobject.h	2007-12-18 18:37:44.000000000 -0800
+++ patched/Include/funcobject.h	2009-01-04 00:41:44.000000000 -0800
@@ -10,7 +10,7 @@
 /* Function objects and code objects should not be confused with each other:
  *
  * Function objects are created by the execution of the 'def' statement.
- * They reference a code object in their func_code attribute, which is a
+ * They reference a code object in their __code__ attribute, which is a
  * purely syntactic object, i.e. nothing more than a compiled version of some
  * source code lines.  There is one code object per source code "fragment",
  * but each code object can be referenced by zero or many function objects
@@ -20,15 +20,17 @@
 
 typedef struct {
     PyObject_HEAD
-    PyObject *func_code;	/* A code object */
+    PyObject *func_code;	/* A code object, the __code__ attribute */
     PyObject *func_globals;	/* A dictionary (other mappings won't do) */
     PyObject *func_defaults;	/* NULL or a tuple */
+    PyObject *func_kwdefaults;	/* NULL or a dict */
     PyObject *func_closure;	/* NULL or a tuple of cell objects */
     PyObject *func_doc;		/* The __doc__ attribute, can be anything */
     PyObject *func_name;	/* The __name__ attribute, a string object */
     PyObject *func_dict;	/* The __dict__ attribute, a dict or NULL */
     PyObject *func_weakreflist;	/* List of weak references */
     PyObject *func_module;	/* The __module__ attribute, can be anything */
+    PyObject *func_annotations;	/* Annotations, a dict or NULL */
 
     /* Invariant:
      *     func_closure contains the bindings for func_code->co_freevars, so
@@ -47,8 +49,12 @@
 PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
 PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetKwDefaults(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetKwDefaults(PyObject *, PyObject *);
 PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetAnnotations(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetAnnotations(PyObject *, PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
    done, so use with care. */
@@ -60,8 +66,12 @@
 	(((PyFunctionObject *)func) -> func_module)
 #define PyFunction_GET_DEFAULTS(func) \
 	(((PyFunctionObject *)func) -> func_defaults)
+#define PyFunction_GET_KW_DEFAULTS(func) \
+	(((PyFunctionObject *)func) -> func_kwdefaults)
 #define PyFunction_GET_CLOSURE(func) \
 	(((PyFunctionObject *)func) -> func_closure)
+#define PyFunction_GET_ANNOTATIONS(func) \
+	(((PyFunctionObject *)func) -> func_annotations)
 
 /* The classmethod and staticmethod types lives here, too */
 PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
diff -Naur src/Include/patchlevel.h patched/Include/patchlevel.h
--- src/Include/patchlevel.h	2008-12-03 18:59:51.000000000 -0800
+++ patched/Include/patchlevel.h	2009-01-04 01:09:52.000000000 -0800
@@ -27,7 +27,7 @@
 #define PY_RELEASE_SERIAL	0
 
 /* Version as a string */
-#define PY_VERSION      	"2.6.1"
+#define PY_VERSION      	"2.6.1.py3to2" // py3k
 /*--end constants--*/
 
 /* Subversion Revision number of this file (not of the repository) */
