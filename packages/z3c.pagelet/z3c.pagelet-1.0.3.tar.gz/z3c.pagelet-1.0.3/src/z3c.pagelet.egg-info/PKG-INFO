Metadata-Version: 1.0
Name: z3c.pagelet
Version: 1.0.3
Summary: Pagelets are way to specify a template without the O-wrap.
Home-page: http://pypi.python.org/pypi/z3c.pagelet
Author: Roger Ineichen and the Zope Community
Author-email: zope-dev@zope.org
License: ZPL 2.1
Description: Pagelets are Zope 3 UI components. In particular they allow the developer to
        specify content templates without worrying about the UI O-wrap.
        
        Detailed Documentation
        **********************
        
        ========
        Pagelets
        ========
        
        .. contents::
        
        This package provides a very flexible base implementation that can be used
        to write view components which can be higly customized later in custom projects.
        This is needed if you have to write reusable components like those needed
        in a framework. Pagelets are BrowserPages made differently and can be used
        to replace them.
        
        What does this mean?
        
        We separate the python view code from the template implementation. And we also
        separate the template in at least two different templates - the content
        template and the layout template.
        
        This package uses z3c.template and offers an implementaton for this
        template pattern. Additionaly this package offers a ``pagelet`` directive
        wich can be used to register pagelets.
        
        Pagelets are views which can be called and support the update and render
        pattern.
        
        
        How do they work
        ----------------
        
        A pagelet returns the rendered content without layout in the render method and
        returns the layout code if we call it. See also z3c.template which shows
        how the template works. These samples will only show how the base implementation
        located in the z3c.pagelet.browser module get used.
        
        
        BrowserPagelet
        --------------
        
        The base implementation called BrowserPagelet offers builtin __call__ and
        render methods which provide the different template lookups. Take a look at the
        BrowserPagelet class located in z3c.pagelet.browser and you can see that the render
        method returns a IContentTemplate and the __call__ method a ILayoutTemplate
        defined in the z3c.layout package.
        
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; temp_dir = tempfile.mkdtemp()
        
        &gt;&gt;&gt; import zope.interface
        &gt;&gt;&gt; import zope.component
        &gt;&gt;&gt; from z3c.pagelet import interfaces
        &gt;&gt;&gt; from z3c.pagelet import browser
        
        We start by defining a page template rendering the pagelet content.
        
        &gt;&gt;&gt; contentTemplate = os.path.join(temp_dir, 'contentTemplate.pt')
        &gt;&gt;&gt; open(contentTemplate, 'w').write('''
        ...   &lt;div class="content"&gt;
        ...     my template content
        ...   &lt;/div&gt;
        ... ''')
        
        And we also define a layout template rendering the layout for a pagelet.
        This template will call the render method from a pagelet:
        
        &gt;&gt;&gt; layoutTemplate = os.path.join(temp_dir, 'layoutTemplate.pt')
        &gt;&gt;&gt; open(layoutTemplate, 'w').write('''
        ...   &lt;html&gt;
        ...     &lt;body&gt;
        ...       &lt;div class="layout" tal:content="structure view/render"&gt;
        ...         here comes the content
        ...       &lt;/div&gt;
        ...     &lt;/body&gt;
        ...   &lt;/html&gt;
        ... ''')
        
        Let's now register the template for the view and the request. We use the
        TemplateFactory directly from the z3c.template package. This is commonly done
        using the ZCML directive called ``z3c:template``. Note that we do use the
        generic Interface as the view base interface to register the template. This
        allows us to register a more specific template in the next sample:
        
        &gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer
        &gt;&gt;&gt; from z3c.template.interfaces import IContentTemplate
        &gt;&gt;&gt; from z3c.template.template import TemplateFactory
        &gt;&gt;&gt; factory = TemplateFactory(contentTemplate, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(
        ...     factory, (zope.interface.Interface, IDefaultBrowserLayer),
        ...     IContentTemplate)
        
        And register the layout template using the ``Interface`` as registration base:
        
        &gt;&gt;&gt; from z3c.template.interfaces import ILayoutTemplate
        &gt;&gt;&gt; factory = TemplateFactory(layoutTemplate, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(factory,
        ...     (zope.interface.Interface, IDefaultBrowserLayer), ILayoutTemplate)
        
        Now define a view marker interface. Such a marker interface is used to let
        us register our templates:
        
        &gt;&gt;&gt; class IMyView(zope.interface.Interface):
        ...     pass
        
        And we define a view class inherited from BrowserPagelet and implementing the
        view marker interface:
        
        &gt;&gt;&gt; class MyView(browser.BrowserPagelet):
        ...     zope.interface.implements(IMyView)
        
        Now test the view class providing the view and check the output:
        
        &gt;&gt;&gt; from zope.publisher.browser import TestRequest
        &gt;&gt;&gt; request = TestRequest()
        &gt;&gt;&gt; myView = MyView(root, request)
        &gt;&gt;&gt; print myView()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;div class="content"&gt;
        my template content
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        You can see the render method generates only the content:
        
        &gt;&gt;&gt; print myView.render()
        &lt;div class="content"&gt;
        my template content
        &lt;/div&gt;
        
        
        Redirection
        -----------
        
        The pagelet doesn't bother rendering itself and its layout when request is a
        redirection as the rendering doesn't make any sense with browser requests in
        that case. Let's create a view that does a redirection in its update method.
        
        &gt;&gt;&gt; class RedirectingView(MyView):
        ...     def update(self):
        ...         self.request.response.redirect('http://www.google.com/')
        
        It will return an empty string when called as a browser page.
        
        &gt;&gt;&gt; redirectRequest = TestRequest()
        &gt;&gt;&gt; redirectView = RedirectingView(root, redirectRequest)
        &gt;&gt;&gt; redirectView() == ''
        True
        
        However, the ``render`` method will render pagelet's template as usual:
        
        &gt;&gt;&gt; print redirectView.render()
        &lt;div class="content"&gt;
        my template content
        &lt;/div&gt;
        
        
        PageletRenderer
        ---------------
        
        There is also a standard pattern for calling the render method on pagelet.
        Using the pagelet renderer which is a IContentProvider makes it possible to
        reuse existing layout template without the pagelet. If you want to reuse a
        layout template without a pagelet you simply have to provide another content
        provider. It's flexible isn't it? As next let's show a sample using the
        pagelet renderer.
        
        We define a new layout template using the content provider called ```pagelet``
        
        
        &gt;&gt;&gt; providerLayout = os.path.join(temp_dir, 'providerLayout.pt')
        &gt;&gt;&gt; open(providerLayout, 'w').write('''
        ...   &lt;html&gt;
        ...     &lt;body&gt;
        ...       &lt;div class="layout" tal:content="structure provider:pagelet"&gt;
        ...         here comes the content
        ...       &lt;/div&gt;
        ...     &lt;/body&gt;
        ...   &lt;/html&gt;
        ... ''')
        
        and register them. Now we use the specific interface defined in the view:
        
        &gt;&gt;&gt; factory = TemplateFactory(providerLayout, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(factory,
        ...     (zope.interface.Interface, IDefaultBrowserLayer), ILayoutTemplate)
        
        Now let's call the view:
        
        &gt;&gt;&gt; print myView()
        Traceback (most recent call last):
        ...
        ContentProviderLookupError: pagelet
        
        That's right, we need to register the content provider ``pagelet`` before we
        can use it.
        
        &gt;&gt;&gt; from zope.contentprovider.interfaces import IContentProvider
        &gt;&gt;&gt; from z3c.pagelet import provider
        &gt;&gt;&gt; zope.component.provideAdapter(provider.PageletRenderer,
        ...     provides=IContentProvider, name='pagelet')
        
        Now let's call the view again:
        
        &gt;&gt;&gt; print myView()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;div class="content"&gt;
        my template content
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        
        Context-specific templates
        --------------------------
        
        Pagelets are also able to lookup templates using their context object
        as an additional discriminator, via (self, self.request, self.context)
        lookup. It's useful when you want to provide a custom template for
        some specific content objects. Let's check that out.
        
        First, let's define a custom content type and make an object to work with:
        
        &gt;&gt;&gt; class IContent(zope.interface.Interface):
        ...     pass
        &gt;&gt;&gt; class Content(object):
        ...     zope.interface.implements(IContent)
        
        &gt;&gt;&gt; content = Content()
        
        Let's use our view class we defined earlier. Currently, it will use
        the layout and content templates we defined for (view, request) before:
        
        &gt;&gt;&gt; myView = MyView(content, request)
        &gt;&gt;&gt; print myView()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;div class="content"&gt;
        my template content
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        Let's create context-specific layout and content templates and register
        them for our IContent interface:
        
        &gt;&gt;&gt; contextLayoutTemplate = os.path.join(temp_dir, 'contextLayoutTemplate.pt')
        &gt;&gt;&gt; open(contextLayoutTemplate, 'w').write('''
        ...   &lt;html&gt;
        ...     &lt;body&gt;
        ...       &lt;div class="context-layout" tal:content="structure provider:pagelet"&gt;
        ...         here comes the context-specific content
        ...       &lt;/div&gt;
        ...     &lt;/body&gt;
        ...   &lt;/html&gt;
        ... ''')
        &gt;&gt;&gt; factory = TemplateFactory(contextLayoutTemplate, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(
        ...     factory, (zope.interface.Interface, IDefaultBrowserLayer, IContent),
        ...     ILayoutTemplate)
        
        &gt;&gt;&gt; contextContentTemplate = os.path.join(temp_dir, 'contextContentTemplate.pt')
        &gt;&gt;&gt; open(contextContentTemplate, 'w').write('''
        ...   &lt;div class="context-content"&gt;
        ...     my context-specific template content
        ...   &lt;/div&gt;
        ... ''')
        &gt;&gt;&gt; factory = TemplateFactory(contextContentTemplate, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(
        ...     factory, (zope.interface.Interface, IDefaultBrowserLayer, IContent),
        ...     IContentTemplate)
        
        Now, our view should use context-specific templates for rendering:
        
        &gt;&gt;&gt; print myView()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="context-layout"&gt;
        &lt;div class="context-content"&gt;
        my context-specific template content
        &lt;/div&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        
        Add, Edit and Display forms (formlib)
        -------------------------------------
        
        What would the pagelet be without any formlib based implementations?
        We offer base implementations for add, edit and display forms
        based on the formlib.
        
        For the next tests we provide a generic form template
        like those used in formlib. This template is registered within this package
        as a default for the formlib based mixin classes:
        
        &gt;&gt;&gt; from z3c import pagelet
        &gt;&gt;&gt; baseDir = os.path.split(pagelet.__file__)[0]
        &gt;&gt;&gt; formTemplate = os.path.join(baseDir, 'form.pt')
        &gt;&gt;&gt; factory = TemplateFactory(formTemplate, 'text/html')
        &gt;&gt;&gt; zope.component.provideAdapter(
        ...     factory,
        ...     (interfaces.IPageletForm, IDefaultBrowserLayer), IContentTemplate)
        
        And we define a new interface including a text attribute:
        
        &gt;&gt;&gt; import zope.schema
        &gt;&gt;&gt; class IDocument(zope.interface.Interface):
        ...     """A document."""
        ...     text = zope.schema.TextLine(title=u'Text', description=u'Text attr.')
        
        Also define a content object which implements the interface:
        
        &gt;&gt;&gt; class Document(object):
        ...     zope.interface.implements(IDocument)
        ...     text = None
        &gt;&gt;&gt; document = Document()
        
        PageletAddForm
        ~~~~~~~~~~~~~~
        
        Now let's define an add from based on the PageletAddForm class:
        
        &gt;&gt;&gt; from zope.formlib import form
        &gt;&gt;&gt; class MyAddForm(browser.PageletAddForm):
        ...     form_fields = form.Fields(IDocument)
        ...     def createAndAdd(self, data):
        ...         title = data.get('title', u'')
        ...         doc = Document()
        ...         doc.title = title
        ...         root['document'] = doc
        ...         return doc
        
        Now render the form:
        
        &gt;&gt;&gt; from z3c.ptcompat.testing import render
        
        &gt;&gt;&gt; addForm = MyAddForm(root, request)
        &gt;&gt;&gt; print addForm()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;form action="http://127.0.0.1" method="post"
        enctype="multipart/form-data" class="edit-form"
        id="zc.page.browser_form"&gt;
        &lt;table class="form-fields"&gt;
        &lt;tr&gt;
        &lt;td class="label"&gt;
        &lt;label for="form.text"&gt;
        &lt;span class="required"&gt;*&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;
        &lt;/label&gt;
        &lt;/td&gt;
        &lt;td class="field"&gt;
        &lt;div class="form-fields-help"
        id="field-help-for-form.text"&gt;Text attr.&lt;/div&gt;
        &lt;div class="widget"&gt;&lt;input class="textType" id="form.text"
        name="form.text" size="20" type="text" value=""  /&gt;&lt;/div&gt;
        &lt;/td&gt;
        &lt;/tr&gt;
        &lt;/table&gt;
        &lt;div class="form-controls"&gt;
        &lt;input type="submit" id="form.actions.add" name="form.actions.add"
        value="Add" class="button" /&gt;
        &lt;/div&gt;
        &lt;/form&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        
        PageletEditForm
        ~~~~~~~~~~~~~~~
        
        Now let's define an edit form based on the PageletEditForm class:
        
        &gt;&gt;&gt; class MyEditForm(browser.PageletEditForm):
        ...     form_fields = form.Fields(IDocument)
        
        and render the form:
        
        &gt;&gt;&gt; document.text = u'foo'
        &gt;&gt;&gt; editForm = MyEditForm(document, request)
        &gt;&gt;&gt; print editForm()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;form action="http://127.0.0.1" method="post"
        enctype="multipart/form-data" class="edit-form"
        id="zc.page.browser_form"&gt;
        &lt;table class="form-fields"&gt;
        &lt;tr&gt;
        &lt;td class="label"&gt;
        &lt;label for="form.text"&gt;
        &lt;span class="required"&gt;*&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;
        &lt;/label&gt;
        &lt;/td&gt;
        &lt;td class="field"&gt;
        &lt;div class="form-fields-help"
        id="field-help-for-form.text"&gt;Text attr.&lt;/div&gt;
        &lt;div class="widget"&gt;&lt;input class="textType" id="form.text"
        name="form.text" size="20" type="text" value="foo"
        /&gt;&lt;/div&gt;
        &lt;/td&gt;
        &lt;/tr&gt;
        &lt;/table&gt;
        &lt;div class="form-controls"&gt;
        &lt;input type="submit" id="form.actions.apply"
        name="form.actions.apply" value="Apply" class="button" /&gt;
        &lt;/div&gt;
        &lt;/form&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        
        PageletDisplayForm
        ~~~~~~~~~~~~~~~~~~
        
        Now let's define a display form based on the PageletDisplayForm class...
        
        &gt;&gt;&gt; class MyDisplayForm(browser.PageletDisplayForm):
        ...     form_fields = form.Fields(IDocument)
        
        and render the form:
        
        &gt;&gt;&gt; document.text = u'foo'
        &gt;&gt;&gt; displayForm = MyDisplayForm(document, request)
        &gt;&gt;&gt; print displayForm()
        &lt;html&gt;
        &lt;body&gt;
        &lt;div class="layout"&gt;
        &lt;form action="http://127.0.0.1" method="post"
        enctype="multipart/form-data" class="edit-form"
        id="zc.page.browser_form"&gt;
        &lt;table class="form-fields"&gt;
        &lt;tr&gt;
        &lt;td class="label"&gt;
        &lt;label for="form.text"&gt;
        &lt;span&gt;Text&lt;/span&gt;
        &lt;/label&gt;
        &lt;/td&gt;
        &lt;td class="field"&gt;
        &lt;div class="form-fields-help"
        id="field-help-for-form.text"&gt;Text attr.&lt;/div&gt;
        &lt;div class="widget"&gt;foo&lt;/div&gt;
        &lt;/td&gt;
        &lt;/tr&gt;
        &lt;/table&gt;
        &lt;/form&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        
        
        Cleanup
        -------
        
        &gt;&gt;&gt; import shutil
        &gt;&gt;&gt; shutil.rmtree(temp_dir)
        
        =======
        CHANGES
        =======
        
        1.0.3 (2009-02-27)
        ------------------
        
        * Allow use of ``z3c.pt`` using ``z3c.ptcompat`` compatibility layer.
        
        * Add support for context-specific layout and content template lookup,
        using (view, request, context) discriminator. This is compatible with
        context-specific templates introduced in z3c.template 1.2.0.
        
        * Don't do rendering in pagelet's __call__ method when request is a redirection.
        
        * Add sphinx-based HTML documentation building part to the buildout.
        
        
        1.0.2 (2008-01-21)
        ------------------
        
        * Added a `form.zcml` which can be included to have a template for
        ``PageletAddForm``, ``PageletEditForm`` and ``PageletDisplayForm``.
        
        
        1.0.1 (2007-10-08)
        ------------------
        
        * Added ``update()`` and ``render()`` method to ``IPagelet`` which was
        not specified but used.
        
        * Fixed a infinite recursion bug when a layout template was registered for "*"
        but no content template was registered for a pagelet.
        
Keywords: zope3 template pagelet layout zpt pagetemplate
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Zope Public License
Classifier: Programming Language :: Python
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Framework :: Zope3
