<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The png Module &mdash; PyPNG v0.0.2 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="PyPNG v0.0.2 documentation" href="index.html" />
    <link rel="prev" title="PyPNG Code Examples" href="ex.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="ex.html" title="PyPNG Code Examples"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyPNG v0.0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-png">
<h1>The png Module<a class="headerlink" href="#module-png" title="Permalink to this headline">¶</a></h1>
<p>Pure Python PNG Reader/Writer</p>
<p>This Python module implements support for PNG images (see PNG
specification at <a class="reference external" href="http://www.w3.org/TR/2003/REC-PNG-20031110/">http://www.w3.org/TR/2003/REC-PNG-20031110/</a> ). It reads
and writes PNG files with all allowable bit depths (1/2/4/8/16/24/32/48/64
bits per pixel) and color combinations: greyscale (1/2/4/8/16 bit); RGB,
RGBA, KA (greyscale with alpha) with 8/16 bits per channel; colormapped
images (1/2/4/8 bit).  Adam7 interlacing is supported for reading and
writing.  A number of optional chunks can be specified (when writing)
and understood (when reading): tRNS, bKGD, gAMA.</p>
<p>For help, type <tt class="docutils literal"><span class="pre">import</span> <span class="pre">png;</span> <span class="pre">help(png)</span></tt> in your python interpreter.</p>
<p>A good place to start is the <a title="png.Reader" class="reference internal" href="#png.Reader"><tt class="xref docutils literal"><span class="pre">Reader</span></tt></a> and <a title="png.Writer" class="reference internal" href="#png.Writer"><tt class="xref docutils literal"><span class="pre">Writer</span></tt></a> classes.</p>
<p>This file can also be used as a command-line utility to convert
<a class="reference external" href="http://netpbm.sourceforge.net/">Netpbm</a> PNM files to PNG, and the reverse conversion from PNG to
PNM. The interface is similar to that of the <tt class="docutils literal"><span class="pre">pnmtopng</span></tt> program from
Netpbm.  Type <tt class="docutils literal"><span class="pre">python</span> <span class="pre">png.py</span> <span class="pre">--help</span></tt> at the shell prompt
for usage and a list of options.</p>
<div class="section" id="a-note-on-spelling">
<h2>A note on spelling<a class="headerlink" href="#a-note-on-spelling" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>greyscale (British English);</li>
<li>color (North American English).</li>
</ul>
</div>
<div class="section" id="a-note-on-formats">
<h2>A note on formats<a class="headerlink" href="#a-note-on-formats" title="Permalink to this headline">¶</a></h2>
<p>When getting pixel data out of this module (reading) and presenting
data to this module (writing) there are a number of ways the data could
be represented as a Python value.  Generally this module uses one of
three formats called &#8220;flat row flat pixel&#8221;, &#8220;boxed row flat pixel&#8221;, and
&#8220;boxed row boxed pixel&#8221;.  Basically the concern is whether each pixel
and each row comes in its own little tuple (box), or not.</p>
<p>Consider an image that is 3 pixels wide by 2 pixels high, and each pixel
has RGB components:</p>
<p>Boxed row flat pixel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">list</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">],</span>
     <span class="p">[</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
</pre></div>
</div>
<p>Each row appears as its own list, but the pixels are flattened so that
three values for one pixel simply follow the three values for the previous
pixel.  This is the most common format used, because it provides a good
compromise between space and convenience.  The module regards itself as
at liberty to replace any sequence type with any sufficiently compatible
other sequence type; in practice each row is an array (from the array
module), and the outer list is sometimes an iterator rather than an
explicit list (so that streaming is possible).</p>
<p>Flat row flat pixel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span>
 <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">]</span>
</pre></div>
</div>
<p>The entire image is one single giant sequence of colour values.
Generally an array will be used (to save space), not a list.</p>
<p>Boxed row boxed pixel:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">list</span><span class="p">([</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="p">],</span>
     <span class="p">[</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="p">])</span>
</pre></div>
</div>
<p>Each row appears in its own list, but each pixel also appears in its own
tuple.  A serious memory burn in Python.</p>
<p>In all cases the top row comes first, and for each row the pixels are
ordered from left-to-right.  Within a pixel the values appear in the
order, R-G-B-A (or K-A for greyscale&#8211;alpha).</p>
<p>There is a fourth format, mentioned because it is used internally, is
close to what lies inside a PNG file itself, and may one day have a
public API exposed for it.  This format is called serialised.  When
serialised an image is a sequence of bytes (integers from 0 to 255).
Each row is packed into bytes (if bit depth &lt; 8) or decomposed into
bytes (big-endian, if bit depth is 16).  This isn&#8217;t a particularly
convenient format, but it is produced (in part) as a necessary step for
decoding and encoding PNG files.  There are some sorts of PNG to PNG
recoding where this might be the most efficient format to use.</p>
</div>
<div class="section" id="and-now-my-famous-members">
<h2>And now, my famous members<a class="headerlink" href="#and-now-my-famous-members" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="png.Reader">
<!--[png.Reader]-->class <tt class="descclassname">png.</tt><tt class="descname">Reader</tt><big>(</big><em>_guess=None</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#png.Reader" title="Permalink to this definition">¶</a></dt>
<dd><p>PNG decoder in pure Python.</p>
<p>Create a PNG decoder object.</p>
<p>The constructor expects exactly one keyword argument. If you
supply a positional argument instead, it will guess the input
type. You can choose among the following arguments:
filename - name of PNG input file
file - object with a read() method
bytes - array or string with PNG data</p>
<dl class="method">
<dt id="png.Reader.asRGB8">
<!--[png.Reader.asRGB8]--><tt class="descname">asRGB8</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.asRGB8" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image data as an RGB image with 8-bits per
sample.  Greyscales are expanded into RGB triplets; bit depths
less than 8 are scaled up to 8-bits; bit depths greater than
8 are scaled down to 8 (note: no dithering is performed).
An alpha channel will raise an exception.</p>
<p>This function returns a 4-tuple:
(<em>width</em>, <em>height</em>, <em>pixels</em>, <em>metadata</em>).
<em>width</em>, <em>height</em>, <em>metadata</em> are as per the <a title="png.Reader.read" class="reference internal" href="#png.Reader.read"><tt class="xref docutils literal"><span class="pre">read()</span></tt></a> method.</p>
<p><em>pixels</em> is the pixel data in boxed row boxed pixel format.  It is
an iterator that yields each row.  A row is a
sequence of pixels; each pixel is an (R,G,B) triple with each
channel being from 0 to 255.</p>
</dd></dl>

<dl class="method">
<dt id="png.Reader.asRGB8Aopt">
<!--[png.Reader.asRGB8Aopt]--><tt class="descname">asRGB8Aopt</tt><big>(</big><em>n</em>, <em>dropalpha=False</em><big>)</big><a class="headerlink" href="#png.Reader.asRGB8Aopt" title="Permalink to this definition">¶</a></dt>
<dd><em>n</em> is the number of channels in the target.</dd></dl>

<dl class="method">
<dt id="png.Reader.asRGBA8">
<!--[png.Reader.asRGBA8]--><tt class="descname">asRGBA8</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.asRGBA8" title="Permalink to this definition">¶</a></dt>
<dd>Return the image data as an RGBA image with 8-bits per
sample.  Greyscales are expanded into RGB triplets; an alpha
channel is synthesized if necessary.  Otherwise performs same as
<a title="png.Reader.asRGB8" class="reference internal" href="#png.Reader.asRGB8"><tt class="xref docutils literal"><span class="pre">asRGB8()</span></tt></a>.</dd></dl>

<dl class="method">
<dt id="png.Reader.chunk">
<!--[png.Reader.chunk]--><tt class="descname">chunk</tt><big>(</big><em>seek=None</em><big>)</big><a class="headerlink" href="#png.Reader.chunk" title="Permalink to this definition">¶</a></dt>
<dd>Read the next PNG chunk from the input file; returns type (as a 4
character string) and data.  If the optional <cite>seek</cite> argument is
specified then it will keep reading chunks until it either runs
out of file or finds the type specified by the argument.  Note
that in general the order of chunks in PNGs is unspecified, so
using <cite>seek</cite> can cause you to miss chunks.</dd></dl>

<dl class="method">
<dt id="png.Reader.deinterlace">
<!--[png.Reader.deinterlace]--><tt class="descname">deinterlace</tt><big>(</big><em>raw</em><big>)</big><a class="headerlink" href="#png.Reader.deinterlace" title="Permalink to this definition">¶</a></dt>
<dd>Read raw pixel data, undo filters, deinterlace, and flatten.
Return in flat row flat pixel format.</dd></dl>

<dl class="method">
<dt id="png.Reader.iterboxed">
<!--[png.Reader.iterboxed]--><tt class="descname">iterboxed</tt><big>(</big><em>rows</em><big>)</big><a class="headerlink" href="#png.Reader.iterboxed" title="Permalink to this definition">¶</a></dt>
<dd>Iterator that yields each scanline in boxed row flat pixel
format.  <cite>rows</cite> should be an iterator that yields the bytes of
each row in turn.</dd></dl>

<dl class="method">
<dt id="png.Reader.iterstraight">
<!--[png.Reader.iterstraight]--><tt class="descname">iterstraight</tt><big>(</big><em>raw</em><big>)</big><a class="headerlink" href="#png.Reader.iterstraight" title="Permalink to this definition">¶</a></dt>
<dd>Iterator that undoes the effect of filtering, and yields each
row in serialised format (as a sequence of bytes).  Assumes input
is straightlaced.  <cite>raw</cite> should be an iterable that yields the
raw bytes in chunks of arbitrary size.</dd></dl>

<dl class="method">
<dt id="png.Reader.preamble">
<!--[png.Reader.preamble]--><tt class="descname">preamble</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.preamble" title="Permalink to this definition">¶</a></dt>
<dd>Extract the image metadata by reading the initial part of the PNG
file up to the start of the <tt class="docutils literal"><span class="pre">IDAT</span></tt> chunk.  All the chunks that
precede the <tt class="docutils literal"><span class="pre">IDAT</span></tt> chunk are read and either processed for
metadata or discarded.</dd></dl>

<dl class="method">
<dt id="png.Reader.process_chunk">
<!--[png.Reader.process_chunk]--><tt class="descname">process_chunk</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.process_chunk" title="Permalink to this definition">¶</a></dt>
<dd>Process the next chunk and its data.  This only processes the
following chunk types, all others are ignored: <tt class="docutils literal"><span class="pre">IHDR</span></tt>,
<tt class="docutils literal"><span class="pre">PLTE</span></tt>, <tt class="docutils literal"><span class="pre">bKGD</span></tt>, <tt class="docutils literal"><span class="pre">tRNS</span></tt>, <tt class="docutils literal"><span class="pre">gAMA</span></tt>.</dd></dl>

<dl class="method">
<dt id="png.Reader.read">
<!--[png.Reader.read]--><tt class="descname">read</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the PNG file and decode it.  Returns (<cite>width</cite>, <cite>height</cite>,
<cite>pixels</cite>, <cite>metadata</cite>).</p>
<p>May use excessive memory.</p>
<p>pixels are returned in boxed row flat pixel format.</p>
</dd></dl>

<dl class="method">
<dt id="png.Reader.read_flat">
<!--[png.Reader.read_flat]--><tt class="descname">read_flat</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.read_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a simple PNG file; return width, height, pixels and image
metadata.</p>
<p>This function is a very early prototype with limited flexibility
and excessive use of memory.</p>
<p>pixels are returned in flat row flat pixel format.</p>
</dd></dl>

<dl class="method">
<dt id="png.Reader.serialtoflat">
<!--[png.Reader.serialtoflat]--><tt class="descname">serialtoflat</tt><big>(</big><em>bytes</em>, <em>width=None</em><big>)</big><a class="headerlink" href="#png.Reader.serialtoflat" title="Permalink to this definition">¶</a></dt>
<dd>Convert serial format (byte stream) pixel data to flat row
flat pixel.</dd></dl>

<dl class="method">
<dt id="png.Reader.undo_filter">
<!--[png.Reader.undo_filter]--><tt class="descname">undo_filter</tt><big>(</big><em>filter_type</em>, <em>scanline</em>, <em>previous</em><big>)</big><a class="headerlink" href="#png.Reader.undo_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Undo the filter for a scanline.  <cite>scanline</cite> is a sequence of
bytes that does not include the initial filter type byte.
<cite>previous</cite> is decoded previous scanline (for straightlaced
images this is the previous pixel row, but for interlaced
images, it is the previous scanline in the reduced image, which
in general is not the previous pixel row in the final image).
When there is no previous scanline (the first row of a
straightlaced image, or the first row in one of the passes in an
interlaced image), then this argument should be <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p>The scanline will have the effects of filtering removed, and the
result will be returned as a fresh sequence of bytes.</p>
</dd></dl>

<dl class="method">
<dt id="png.Reader.validate_signature">
<!--[png.Reader.validate_signature]--><tt class="descname">validate_signature</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Reader.validate_signature" title="Permalink to this definition">¶</a></dt>
<dd>If signature (header) has not been read then read and
validate it; otherwise do nothing.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="png.Writer">
<!--[png.Writer]-->class <tt class="descclassname">png.</tt><tt class="descname">Writer</tt><big>(</big><em>width</em>, <em>height</em>, <em>greyscale=False</em>, <em>alpha=False</em>, <em>bitdepth=8</em>, <em>palette=None</em>, <em>transparent=None</em>, <em>background=None</em>, <em>gamma=None</em>, <em>compression=None</em>, <em>interlace=False</em>, <em>bytes_per_sample=None</em>, <em>chunk_limit=1048576</em><big>)</big><a class="headerlink" href="#png.Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>PNG encoder in pure Python.</p>
<p>Create a PNG encoder object.</p>
<p>Arguments:
width, height - size of the image in pixels
greyscale - input data is greyscale, not RGB
alpha - input data has alpha channel (RGBA or KA)
bitdepth - 1, 2, 4, 8, or 16
palette - create a palettized image (color type 3)
transparent - create a tRNS chunk
background - create a bKGD chunk
gamma - create a gAMA chunk
compression - zlib compression level (1-9)
interlace - create an interlaced image
chunk_limit - write multiple IDAT chunks to save memory</p>
<p><cite>greyscale</cite> and <cite>alpha</cite> are booleans that specify whether
an image is greyscale (or color), and whether it has an
alpha channel (or not).</p>
<p><cite>bitdepth</cite> specifies the bit depth of the PNG image.  This is the
number of bits used to specify the value of each color channel
(or index, in the case of a palette).  PNG allows this to be
1,2,4,8, or 16, but there are some restrictions on some values.</p>
<p>For greyscale and palette images the PNG specification allows
the bit depth to be less than 8.  For other types, bit depths
less than 8 are rejected.</p>
<p>The palette option, when specified, causes a palettized
(colour-mapped) image to be created: the PNG color type is set
to 3; greyscale must not be set; alpha must not be set;
transparent must not be set; the bit depth must be 1,2,4, or 8.</p>
<p>The palette argument value should be a sequence of 3- or
4-tuples.  3-tuples specify RGB palette entries; 4-tuples
specify RGBA palette entries.  If both 4-tuples and 3-tuples
appear in the sequence then all the 4-tuples must come
before all the 3-tuples.  A PLTE chunk is created; if there
are 4-tuples then a tRNS chunk is created as well.  The
PLTE chunk will contain all the RGB triples in the same
sequence; the tRNS chunk will contain the alpha channel for
all the 4-tuples, in the same sequence.  Palette entries
are always 8-bit.</p>
<p>If specified, the <cite>transparent</cite> and <cite>background</cite> parameters must
be a tuple with three integer values for red, green, blue, or
a simple integer (or singleton tuple) for a greyscale image.</p>
<p>If specified, the gamma parameter must be a positive number
(generally, a float).  A gAMA chunk will be created.  Note that
this will not change the values of the pixels as they appear in
the PNG file, they are assumed to have already been converted
appropriately for the gamma specified.</p>
<p>The default for the compression argument is None; this does not
mean no compression, rather it means that the default from the zlib
module is used (which is generally acceptable).</p>
<p>If <cite>interlace</cite> is true then an interlaced image is created
(using PNG&#8217;s so far only interace method, Adam7).  This does not
affect how the pixels should be presented to the encoder, rather
it changes how they are arranged into the PNG file.  On slow
connexions interlaced images can be partially decoded by the
browser to give a rough view of the image that is successively
refined as more image data appears.  Caution: enabling this
option requires the entire image to be processed in working
memory.</p>
<p><cite>chunk_limit</cite> is used to limit the amount of memory used whilst
compressing the image.  In order to avoid using large amounts of
memory, multiple IDAT chunks may be created.</p>
<dl class="method">
<dt id="png.Writer.array_scanlines">
<!--[png.Writer.array_scanlines]--><tt class="descname">array_scanlines</tt><big>(</big><em>pixels</em><big>)</big><a class="headerlink" href="#png.Writer.array_scanlines" title="Permalink to this definition">¶</a></dt>
<dd>Generates boxed rows (flat pixels) from flat rows (flat pixels)
in an array.</dd></dl>

<dl class="method">
<dt id="png.Writer.array_scanlines_interlace">
<!--[png.Writer.array_scanlines_interlace]--><tt class="descname">array_scanlines_interlace</tt><big>(</big><em>pixels</em><big>)</big><a class="headerlink" href="#png.Writer.array_scanlines_interlace" title="Permalink to this definition">¶</a></dt>
<dd>Generator for interlaced scanlines from an array.  <cite>pixels</cite> is
the full source image in flat row flat pixel format.  The
generator yields each scanline of the reduced passes in turn, in
boxed row flat pixel format.</dd></dl>

<dl class="method">
<dt id="png.Writer.convert_pnm">
<!--[png.Writer.convert_pnm]--><tt class="descname">convert_pnm</tt><big>(</big><em>infile</em>, <em>outfile</em><big>)</big><a class="headerlink" href="#png.Writer.convert_pnm" title="Permalink to this definition">¶</a></dt>
<dd>Convert a PNM file containing raw pixel data into a PNG file
with the parameters set in the writer object.  Works for PGM and
PPM formats.</dd></dl>

<dl class="method">
<dt id="png.Writer.convert_ppm_and_pgm">
<!--[png.Writer.convert_ppm_and_pgm]--><tt class="descname">convert_ppm_and_pgm</tt><big>(</big><em>ppmfile</em>, <em>pgmfile</em>, <em>outfile</em><big>)</big><a class="headerlink" href="#png.Writer.convert_ppm_and_pgm" title="Permalink to this definition">¶</a></dt>
<dd>Convert a PPM and PGM file containing raw pixel data into a
PNG outfile with the parameters set in the writer object.</dd></dl>

<dl class="method">
<dt id="png.Writer.file_scanlines">
<!--[png.Writer.file_scanlines]--><tt class="descname">file_scanlines</tt><big>(</big><em>infile</em><big>)</big><a class="headerlink" href="#png.Writer.file_scanlines" title="Permalink to this definition">¶</a></dt>
<dd>Generates boxed rows in flat pixel format, from the input file
<cite>infile</cite>.</dd></dl>

<dl class="method">
<dt id="png.Writer.make_palette">
<!--[png.Writer.make_palette]--><tt class="descname">make_palette</tt><big>(</big><big>)</big><a class="headerlink" href="#png.Writer.make_palette" title="Permalink to this definition">¶</a></dt>
<dd>Create the byte sequences for a PLTE and if necessary a tRNS
chunk.  Returned as a pair (p, t).  t will be None if no tRNS
chunk is necessary.</dd></dl>

<dl class="method">
<dt id="png.Writer.write">
<!--[png.Writer.write]--><tt class="descname">write</tt><big>(</big><em>outfile</em>, <em>rows</em><big>)</big><a class="headerlink" href="#png.Writer.write" title="Permalink to this definition">¶</a></dt>
<dd>Write a PNG image to the output file.  <cite>rows</cite> should be
an iterable that yields each row in boxed row flat pixel format.
The rows should be the rows of the original image, so there
should be self.height rows of self.width * self.planes values.
If <cite>interlace</cite> is specified (when creating the instance), then
the interlacing is carried out internally.  This will require
the entire image to be in working memory.</dd></dl>

<dl class="method">
<dt id="png.Writer.write_array">
<!--[png.Writer.write_array]--><tt class="descname">write_array</tt><big>(</big><em>outfile</em>, <em>pixels</em><big>)</big><a class="headerlink" href="#png.Writer.write_array" title="Permalink to this definition">¶</a></dt>
<dd>Write an array in flat row flat pixel format as a PNG file on
the output file.</dd></dl>

<dl class="method">
<dt id="png.Writer.write_chunk">
<!--[png.Writer.write_chunk]--><tt class="descname">write_chunk</tt><big>(</big><em>outfile</em>, <em>tag</em>, <em>data=''</em><big>)</big><a class="headerlink" href="#png.Writer.write_chunk" title="Permalink to this definition">¶</a></dt>
<dd>Write a PNG chunk to the output file, including length and
checksum.</dd></dl>

<dl class="method">
<dt id="png.Writer.write_passes">
<!--[png.Writer.write_passes]--><tt class="descname">write_passes</tt><big>(</big><em>outfile</em>, <em>rows</em><big>)</big><a class="headerlink" href="#png.Writer.write_passes" title="Permalink to this definition">¶</a></dt>
<dd>Write a PNG image to the output file.  The rows should be given
to this method in the order that they appear in the output file.
For straightlaced images, this is the usual top to bottom
ordering, but for interlaced images the rows should have already
been interlaced before passing them to this function.  Most
users are expected to find the write() or write_array() method
more convenient.  <cite>rows</cite> should be an iterable that yields
each row in boxed row flat pixel format.</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">The png Module</a><ul>
<li><a class="reference external" href="#a-note-on-spelling">A note on spelling</a></li>
<li><a class="reference external" href="#a-note-on-formats">A note on formats</a></li>
<li><a class="reference external" href="#and-now-my-famous-members">And now, my famous members</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="ex.html" title="previous chapter">PyPNG Code Examples</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/png.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="ex.html" title="PyPNG Code Examples"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyPNG v0.0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, David Jones.
      Last updated on 2009-03-18T09:27:03.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.1.
    </div>
  </body>
</html>