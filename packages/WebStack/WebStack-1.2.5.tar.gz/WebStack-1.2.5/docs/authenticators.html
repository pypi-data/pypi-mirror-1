<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Application-Wide Authenticators</title>
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<h1>Application-Wide Authenticators</h1>
<p>Authenticators are special classes which can, in conjunction with
mechanisms in the server environment, judge whether a user of an
application
is recognised or not. The process of using authenticators is as follows:</p>
<ol>
  <li>Set up authentication in the server environment or framework in
which the application is to be deployed.</li>
  <li>Introduce an authenticator class in the application.</li>
</ol>
<h2>Setting Up Authentication</h2>
<p>The exact details of configuring authentication mechanisms in each
server
environment may vary substantially. For example, Apache environments
require
that <code>Auth</code> directives be specified in the Apache
configuration
files (see <code>docs/ModPython/NOTES.txt</code>); in Zope
environments,
protected folders can be defined to hold the application when deployed
(see
<code>docs/Zope/NOTES.txt</code>).</p>
<h2>Defining an Authenticator</h2>
<p>An authenticator must be defined within your application in order to
make
decisions about users who have presented their credentials; this
authenticator will respond with a decision when prompted by the server
or
underlying framework, either allowing or denying access for the user
whose
identity has been presented to the server/framework.</p>
<p>The code for an authenticator usually looks like this:</p>
<pre>class MyAuthenticator:<br /><br />    "This is an authenticator - something which decides whether a user is known to the application."<br /><br />    def authenticate(self, trans):<br />        user = trans.get_user()<br />        [Make a decision about the validity of the user.]<br />        [Return a true value if the user is allowed to access the application.]<br />        [Return a false value if the user is not recognised or allowed to access the application.]<br /><br />    def get_auth_type(self):<br />        "This method returns 'Basic' in most deployments."<br />        return "Basic"<br /><br />    def get_realm(self):<br />        "This method returns something to distinguish this authentication mechanism from others."<br />        return "MyRealm"</pre>
<p>In this mechanism, authenticators rely on authentication information
from
the server environment and have a "global" effect on access to the
application.
However, it is always possible to test the user identity later on and
to
change the way an application behaves accordingly - see <a
 href="users.html">"Users and Authentication"</a> for more information.</p>
<h2>Introducing an Authenticator</h2>
<p>Authenticator objects are created in the adapter code - see <a
 href="writing-adapters.html">"Writing Adapters"</a> for more
information.</p>
<h2>Anonymous Access</h2>
<p>With application-wide authenticators, anonymous access to resources
and
applications can be difficult to permit alongside access by specific
users,
mostly because servers and frameworks which employ HTTP authentication
schemes do so globally for a given application.</p>
<h2>Logout Functions</h2>
<p>With application-wide authenticators, a logout function may not be
available if the server/framework has been configured to use HTTP
authentication schemes, mainly because no logout mechanism generally
exists
for such schemes.</p>
</body>
</html>
