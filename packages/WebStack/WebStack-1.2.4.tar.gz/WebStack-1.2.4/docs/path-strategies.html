<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head> <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" /><title>Path Processing Strategies</title>
<meta name="generator" content="amaya 8.1a, see http://www.w3.org/Amaya/" /> <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body><h1>Path Processing Strategies</h1>
<p>In the development of most Web applications, the structure of the
application - also known as the "site map" -&nbsp;needs to be defined
at a very early stage. We might decide that if a user requests a
certain path, a particular part of the application will be invoked, and
we might define the site map in a number of different ways:</p><p>As a set of acceptable paths...</p><ul><li><code>/</code>&nbsp;is the main page</li><li><code>/services/finance/salaries/</code>&nbsp;is the salary report page</li><li><code>/services/customer/complaints/</code>&nbsp;is the complaints page</li></ul><p>As a tree of resources...</p><ul><li><code>/</code>&nbsp;is the main page</li><ul><li><code>.../services/</code>&nbsp;refers to services (which may not be defined as anything viewable)</li><ul><li><code>.../finance/</code>&nbsp;is the finance department</li><ul><li><code>.../salaries/</code>&nbsp;is the salary report page</li></ul><li><code>.../customer/</code>&nbsp;is the customer service department</li><ul><li><code>.../complaints/</code>&nbsp;is the complaints page</li></ul></ul></ul></ul><p>Since
all of the action in WebStack applications takes place inside
resources, the challenge is to define resources in such a way which
makes processing paths relatively easy.</p><h2>Chaining Resources</h2><p>Whilst the classic resource, as described in <a href="resources.html">"Applications and Resources"</a>, might resemble a simple class whose&nbsp;<code>respond</code>
method performs most of the necessary work, it is useful to reconsider
such a resource as doing such work only for a particular narrow part of
a larger Web application. Moreover, resources are not restricted in
their usage of other objects to carry out their purpose, provided they
are initialised with references to those objects.Consequently, it makes sense to consider defining a resource which, if it alone cannot process a request, invokes the  <code>respond</code> method on another resource in order to get that resource to continue with the act of processing.</p><p>We
can apply this insight to the above path processing scenario. If we
first employ a resource to examine details of the path, and if that
resource then invokes other resources to produce certain pages, we can
separate the path processing from the rest of the application's
functionality. So, for the first site map strategy, we could define a
path processing resource as follows:</p><pre>from WebStack.Generic import EndOfResponse<br /><br />class PathProcessor:<br /><br />    "A path processing resource."<br /><br />    def __init__(self, main_page, salary_report_page, complaints_page):<br /><br />        # Supplied resources are chained to this resource.<br /><br />        self.main_page = main_page<br />        self.salary_report_page = salary_report_page<br />       &nbsp;self.complaints_page = complaints_page<br /><br />   &nbsp;def respond(self, trans):<br /><br />        # This is where the resources are invoked...<br /><br />        path = trans.get_path_without_query() # should really use an encoding here<br />        if path == "/":<br />            self.main_page.respond(trans)<br />        elif path == "/services/finance/salaries/":<br />            self.main_page.respond(trans)<br />        elif path == "/services/finance/salaries/":<br />            self.main_page.respond(trans)<br /><br />        # Administrative details...<br /><br />        else:<br />            trans.set_response_code(404) # not found!<br />            raise EndOfResponse</pre><p>Of
course, more elegant methods of mapping paths to resources could be
employed - a dictionary might be an acceptable solution, if defined in
the initialiser method. The above class might be initialised as follows:</p><pre>main_page = MainResource()<br />salary_report_page = SalaryReportResource()<br />complaints_page = ComplaintsResource()<br />path_processor = PathProcessor(main_page, salary_report_page, complaints_page)</pre><p>For
the second site map strategy, we retain the basic parts of the above
strategy, focusing only on one level in the path as opposed to the
complete path. However, this means that our path processing resources
need to know exactly which part of the path they should&nbsp;be
considering, and perhaps which part of the path has already been
processed.</p><p>As described in <a href="path-info.html">"Paths To and Within Applications"</a>,&nbsp;special path information of the nature required is provided by two methods: <code>get_virtual_path_info</code> and&nbsp;<code>get_processed_virtual_path_info</code>. Such information can thus be obtained and updated at each level in the processing chain.</p><pre>class MainPathProcessor:<br /><br />    "A path processor for the top of the application."<br /><br />    def __init__(self, main_page, services_processor):<br />        self.main_page = main_page<br />        self.services_processor = services_processor<br /><br />    def respond(self, trans):<br /><br />        # This is where the resources are invoked...<br /><br />        path = trans.get_virtual_path_info() # should really use an encoding here<br />        if path == "/":<br />            self.main_page.respond(trans)<br />        elif path.startswith("/services/"):<br />            trans.set_virtual_path_info(path[len("/services"):]) # cut off "/services"<br />            self.services_processor.respond(trans)<br /><br />        # Administrative details...<br /><br />        else:<br />            trans.set_response_code(404) # not found!<br />            raise EndOfResponse</pre><p>A suite of similar classes can be defined and might be initialised as follows:</p><pre>main_page = MainResource()<br />salary_report_page = SalaryReportResource()<br />complaints_page = ComplaintsResource()<br />finance_processor = FinancePathProcessor(salary_report_page)<br />customer_processor = CustomerPathProcessor(complaints_page)<br />services_processor = ServicesPathProcessor(finance_processor, customer_processor)<br />main_processor = MainPathProcessor(main_page, services_processor)</pre><p>Fortunately, this latter strategy is supported by WebStack in the form of the&nbsp;<code>ResourceMap</code> module. See <a href="paths-filesystem.html">"Treating the Path Like a Filesystem"</a> and <a href="resource-map.html">"ResourceMap - Simple Mappings from Names to Resources"</a> for details.</p></body></html>