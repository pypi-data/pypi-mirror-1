<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <title>Treating the Path Like a Filesystem</title>
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>
<h1>Treating the Path Like a Filesystem</h1>
<p>...or as a reference into deeply categorized resources. In this approach,
we take a path like this...</p>
<pre>/documents/news/2005/article.html</pre>
<p>...and we consider <code>documents</code>, <code>news</code>, and
<code>2005</code> as directories, and <code>article.html</code> as a
file-like resource. If we ask for the following path...</p>
<pre>/documents/news/2005</pre>
<p>...we may decide to provide a listing of files within that directory, or
we may decide to refuse such a request. Indeed some kinds of applications insist
that such a listing may only be produced with the following path instead:</p>
<pre>/documents/news/2005/</pre>
<p>Applications of this kind are quite common since the publishing of files
on a Web server often just involves exposing parts of a real filesystem to
requests through the server.</p>
<h2>Resource Hierarchies in WebStack</h2>
<p>There are a number of different ways that paths can be interpreted and handled in WebStack
applications, including...</p>
<ul>
  <li>Using predefined hierarchies of resources.</li>
  <li>By inspecting the path in a top-level resource and then creating resources to deal with different
cases.</li>
  <li>By handling all kinds of paths in the same resource.</li>
</ul>
<h3>Predefining Resource Hierarchies</h3>
<p>We might decide to represent components in these kinds of paths using
different resource classes; for example:</p>
<ul>
  <li>Folders or directories are represented by a special resource class which contains other
folders and possibly some files.</li>
  <li>Files or documents are represented by special resource classes which provide access
to the content of such files.</li>
</ul>
<p>We might then predefine a hierarchy of resources
so that when a request arrives for a resource, we can check it against the
hierarchy and process the request according to whichever type of resource is
being accessed. For example:</p>
<ul>
  <li><code>documents</code>
    <ul>
      <li><code>news</code>
        <ul>
          <li><code>2005</code>
            <ul>
              <li><code>article.html</code></li>
              <li><code>another.html</code></li>
            </ul>
          </li>
          <li><code>2004</code>
            <ul>
              <li><code>document.html</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>Consider the above hierarchy; we would implement such a hierarchy with a
resource object mapped to <code>documents</code>, and that resource object
would contain a mapping of years to other resources. Eventually, at the
bottom of the hierarchy, individual resources would represent articles
and be mapped to names such as <code>article.html</code>.</p>
<div class="WebStack">
<h3>WebStack API - Predefining Resource Hierarchies in Adapter Code</h3>

<p>WebStack provides the <code>MapResource</code>
class (in the <code>WebStack.Resources.ResourceMap</code> module) for convenient mapping of path
components to resource objects<code></code>.
See the <a href="resource-map.html">"ResourceMap - Simple Mappings from Names to Resources"</a>
document for a more detailed description of the <code>MapResource</code> class.</p>

<p>This class can be used in <a href="deploying.html">adapter code</a>
to initialise an application as follows:</p>
<pre>from WebStack.Resources.ResourceMap import MapResource<br />from MyApplication import FileResource                                  # import some resource class<br /><br />article_resource = FileResource(...)                                    # make a resource representing the article<br />document_resource = FileResource(...)                                   # make a resource representing the document<br />year_2004_resource = MapResource({"document.html" : document_resource})<br />year_2005_resource = MapResource({"article.html" : article_resource})<br />news_resource = MapResource({"2005" : year_2005_resource, "2004" : year_2004_resource})<br />documents_resource = MapResource({"news" : news_resource})<br />top_resource = MapResource({"documents" : documents_resource})</pre>
</div>
<p>Of course, predefining resource
objects is not the only way to support such
hierarchies. We could inspect paths and act dynamically on the supplied
information, either choosing to create resources or choosing to handle
such paths in the same resource.</p>
</body></html>
