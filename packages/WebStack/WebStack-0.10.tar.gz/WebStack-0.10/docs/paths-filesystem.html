<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Treating the Path Like a Filesystem</title>
  <meta name="generator"
 content="amaya 8.1a, see http://www.w3.org/Amaya/" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<h1>Treating the Path Like a
Filesystem</h1>
<p>...or as a reference into
deeply categorized resources. In this approach,
we take a path like this...</p>
<pre>/documents/news/2005/article.html</pre>
<p>...and we consider <code>documents</code>,
<code>news</code>,
and
<code>2005</code>
as directories, and <code>article.html</code>
as a
file-like resource. If we ask for the following path...</p>
<pre>/documents/news/2005</pre>
<p>...we may decide to provide a
listing of files within that directory, or
we may decide to refuse such a request. Indeed some kinds of
applications&nbsp;insist
that such a listing may only be produced with the following path
instead:</p>
<pre>/documents/news/2005/</pre>
<p>Applications of this kind are
quite common since the publishing of files
on a Web server often just involves exposing parts of a real filesystem
to
requests through the server.</p>
<h2>Resource Hierarchies in
WebStack</h2>
<p>There are a number of different
ways that paths can be interpreted and handled in WebStack
applications, including...</p>
<ul>
  <li>Using predefined hierarchies
of resources.</li>
  <li>By inspecting the path in a
top-level resource and then creating resources to deal with different
cases.</li>
  <li>By handling all kinds of
paths in the same resource.</li>
</ul>
<h3>Predefining Resource
Hierarchies</h3>
<p>We might decide to represent
components in these kinds of paths using
different resource classes; for example:</p>
<ul>
  <li>Folders or directories are
represented by&nbsp;a special resource class which contains other
folders and possibly some files.</li>
  <li>Files or documents are
represented by special&nbsp;resource classes which provide access
to the content of such files.</li>
</ul>
We might then predefine a hierarchy of resources
so that when a request arrives for a resource, we can check it against
the
hierarchy and process the request according to whichever type of
resource is
being accessed. For example:<br />
<ul>
  <li><code>documents</code>
    <ul>
      <li><code>news</code>
        <ul>
          <li><code>2005</code>
            <ul>
              <li><code>article.html</code></li>
              <li><code>another.html</code></li>
            </ul>
          </li>
          <li><code>2004</code>
            <ul>
              <li><code>document.html</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>Consider the above hierarchy;
we would implement such a hierarchy with a
resource object mapped to <code>documents</code>,
and that resource object
would contain a mapping of years to other resources. Eventually, at the
bottom of the hierarchy, individual resources would represent articles
and be
mapped to names such as <code>article.html</code>.</p>
<div class="WebStack">
<h3>WebStack API - Predefining
Resource Hierarchies in Adapter Code</h3>
<p>WebStack provides a resource
class for convenient mapping of path
components (ie. names) to resource objects:
<code>WebStack.Resources.ResourceMap.MapResource</code></p>
<p>This class can be used in <a href="deploying.html">adapter code</a>
to initialise an
application as follows:</p>
<pre>from WebStack.Resources.ResourceMap import MapResource<br />from MyApplication import FileResource                                  # import some resource class<br /><br />article_resource = FileResource(...)                                    # make a resource representing the article<br />document_resource = FileResource(...)                                   # make a resource representing the document<br />year_2004_resource = MapResource({"document.html" : document_resource})<br />year_2005_resource = MapResource({"article.html" : article_resource})<br />news_resource = MapResource({"2005" : year_2005_resource, "2004" : year_2004_resource})<br />documents_resource = MapResource({"news" : news_resource})<br />top_resource = MapResource({"documents" : documents_resource})</pre>
</div>
<p>Of course, predefining resource
objects is not the only way to support such
hierarchies. We could inspect paths and act dynamically on the supplied
information, either choosing to create resources or choosing to handle
such paths in the same resource. See <a href="path-info.html">"Paths
To and Within Applications"</a> for some other strategies.</p>
</body>
</html>
