--------------------------------
bitstring module version history
--------------------------------

----------------------------------------------------
May 25th 2009: version 0.4.2 for Python 2.x released
----------------------------------------------------

This is a minor update, and almost doesn't break compatibility with version
0.4.0, but with the slight exception of findall() returning a generator,
detailed below.

Changes in version 0.4.2

* Stepping in slices

The use of the step parameter (also known as the stride) in slices has been
added. Its use is a little non-standard as it effectively gives a multiplicative
factor to apply to the start and stop parameters, rather than skipping over
bits.

For example this makes it much more convenient if you want to give slices in
terms of bytes instead of bits. Instead of writing s[a*8:b*8] you can use
s[a:b:8].

When using a step the BitString is effectively truncated to a multiple of the
step, so s[::8] is equal to s if s is an integer number of bytes, otherwise it
is truncated by up to 7 bits. So the final seven complete 16-bit words could be
written as s[-7::16]

Negative slices are also allowed, and should do what you'd expect. So for
example s[::-1] returns a bit-reversed copy of s (which is similar to
s.reversebits(), which does the same operation on s in-place). As another
example, to get the first 10 bytes in reverse byte order you could use
s_bytereversed = s[0:10:-8].

* Removed restrictions on offset

You can now specify an offset of greater than 7 bits when creating a BitString,
and the use of offset is also now permitted when using the filename initialiser.
This is useful when you want to create a BitString from the middle of a file
without having to read the file into memory.

>>> f = BitString(filename='reallybigfile', offset=8000000, length=32)

* Integers can be assigned to slices

You can now assign an integer to a slice of a BitString. If the integer doesn't
fit in the size of slice given then a ValueError exception is raised. So this
is now allowed and works as expected:

>>> s[8:16] = 106

and is equivalent to

>>> s[8:16] = BitString(uint=106, length=8)

* Less exceptions raised

Some changes have been made to slicing so that less exceptions are raised,
bringing the interface closer to that for lists. So for example trying to delete
past the end of the BitString will now just delete to the end, rather than
raising a ValueError.

* Initialisation from lists and tuples

A new option for the auto initialiser is to pass it a list or tuple. The items
in the list or tuple are evaluated as booleans and the bits in the BitString are
set to 1 for True items and 0 for False items. This can be used anywhere the
auto initialiser can currently be used. For example:

>>> a = BitString([True, 7, False, 0, ()])     # 0b11000
>>> b = a + ['Yes', '']                        # Adds '0b10'
>>> (True, True, False) in a
True

* Miscellany

reversebits() now has optional startbit and endbit parameters.

As an optimisation findall() will return a generator, rather than a list. If you
still want the whole list then of course you can just call list() on the
generator.

Improved efficiency of rfind().

A couple of minor bugs were fixed. See the issue tracker for details. 

---------------------------------------
April 11th 2009: version 0.4.0 released
---------------------------------------
Changes in version 0.4.0

* New functions

Added rfind(), findall(), replace(). These do pretty much what you'd expect -
see the docstrings or the wiki for more information.

* More special functions

Some missing functions were added: __repr__, __contains__, __rand__,
__ror__, _rxor__ and __delitem__.

* Miscellany

A couple of small bugs were fixed (see the issue tracker).

----

There are some small backward incompatibilities relative to version 0.3.2:

* Combined find() and findbytealigned()

findbytealigned() has been removed, and becomes part of find(). The default
start position has changed on both find() and split() to be the start of the
BitString. You may need to recode:

>>> s1.find(bs)
>>> s2.findbytealigned(bs)
>>> s2.split(bs)

becomes

>>> s1.find(bs, bytealigned=False, startbit=s1.bitpos)
>>> s2.find(bs, startbit=s1.bitpos)  # bytealigned defaults to True
>>> s2.split(bs, startbit=s2.bitpos)

* Reading off end of BitString no longer raises exception.

Previously a read or peek function that encountered the end of the BitString
would raise a ValueError. It will now instead return the remainder of the
BitString, which could be an empty BitString. This is closer to the file
object interface.

* Removed visibility of offset.

The offset property was previously read-only, and has now been removed from
public view altogether. As it is used internally for efficiency reasons you
shouldn't really have needed to use it. If you do then use the _offset parameter
instead (with caution).

---------------------------------------
March 11th 2009: version 0.3.2 released
---------------------------------------
Changes in version 0.3.2

* Better performance

A number of functions (especially find() and findbytealigned()) have been sped
up considerably.

* Bit-wise operations

Added support for bit-wise AND (&), OR (|) and XOR (^). For example:

>>> a = BitString('0b00111')
>>> print a & '0b10101'
0b00101

* Miscellany

Added seekbit() and seekbyte() functions. These complement the 'advance' and
'retreat' functions, although you can still just use bitpos and bytepos
properties directly.

>>> a.seekbit(100)                   # Equivalent to a.bitpos = 100

Allowed comparisons between BitString objects and strings. For example this
will now work:

>>> a = BitString('0b00001111')
>>> a == '0x0f'
True

------------------------------------------
February 26th 2009: version 0.3.1 released
------------------------------------------
Changes in version 0.3.1

This version only adds features and fixes bugs relative to 0.3.0, and doesn't
break backwards compatibility.

* Octal interpretation and initialisation

The oct property now joins bin and hex. Just prefix octal numbers with '0o'.

>>> a = BitString('0o755')
>>> print a.bin
0b111101101

* Simpler copying

Rather than using b = copy.copy(a) to create a copy of a BitString, now you
can just use b = BitString(a).

* More special methods

Lots of new special methods added, for example bit-shifting via << and >>,
equality testing via == and !=, bit inversion (~) and concatenation using *.

Also __setitem__ is now supported so BitString objects can be modified using
standard index notation.

* Proper installer

Finally got round to writing the distutils script. To install just
python setup.py install.

------------------------------------------
February 15th 2009: version 0.3.0 released
------------------------------------------
Changes in version 0.3.0

* Simpler initialisation from binary and hexadecimal

The first argument in the BitString constructor is now called auto and will
attempt to interpret the type of a string. Prefix binary numbers with '0b'
and hexadecimals with '0x'.

>>> a = BitString('0b0')         # single zero bit
>>> b = BitString('0xffff')      # two bytes

Previously the first argument was data, so if you relied on this then you
will need to recode:

>>> a = BitString('\x00\x00\x01\xb3')   # Don't do this any more!

becomes

>>> a = BitString(data='\x00\x00\x01\xb3')

or just

>>> a = BitString('0x000001b3')

This new notation can also be used in functions that take a BitString as an
argument. For example:

>>> a = BitString('0x0011') + '0xff'
>>> a.insert('0b001', 6)
>>> a.find('0b1111')

* BitString made more mutable

The functions append, deletebits, insert, overwrite, truncatestart and
truncateend now modify the BitString that they act upon. This allows for
cleaner and more efficient code, but you may need to rewrite slightly if you
depended upon the old behaviour:

>>> a = BitString(hex='0xffff')
>>> a = a.append(BitString(hex='0x00'))
>>> b = a.deletebits(10, 10)

becomes:

>>> a = BitString('0xffff')
>>> a.append('0x00')
>>> b = copy.copy(a)
>>> b.deletebits(10, 10)

Thanks to Frank Aune for suggestions in this and other areas.

* Changes to printing

The binary interpretation of a BitString is now prepended with '0b'. This is
in keeping with the Python 2.6 (and 3.0) bin function. The prefix is optional
when initialising using 'bin='.

Also, if you just print a BitString with no interpretation it will pick
something appropriate - hex if it is an integer number of bytes, otherwise
binary. If the BitString representation is very long it will be truncated
by '...' so it is only an approximate interpretation.

>>> a = BitString('0b0011111')
>>> print a
0b0011111
>>> a += '0b0'
>>> print a
0x3e

* More convenience functions

Some missing functions such as advancebit and deletebytes have been added. Also
a number of peek functions make an appearance as have prepend and reversebits.
See the Tutorial for more details.

-----------------------------------------
January 13th 2009: version 0.2.0 released
-----------------------------------------
Some fairly minor updates, not really deserving of a whole version point update.
------------------------------------------
December 29th 2008: version 0.1.0 released
------------------------------------------
First release!