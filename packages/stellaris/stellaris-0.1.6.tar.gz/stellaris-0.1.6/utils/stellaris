#!/usr/bin/env python

import sys, optparse, threading, stellaris, os
from stellaris.service.serve import ServeStellaris

log = stellaris._logger

def start(cfgpath, curdir):
    server = ServeStellaris(cfgpath, curdir)

    try:
        server.start()
    except KeyboardInterrupt, e:
        log.debug("Received a keyboard interrupt, stopping server.")
        server.stop()
    except SystemExit, e:
        log.debug("Received system exit, stopping server.")
        server.stop()

def daemonize():
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    # adapted from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/278731
    try:
        pid = os.fork()
    except OSError, e:
        print >>sys.stderr, "Daemon could not be started: %d (%s)" % (e.errno, e.strerror)
        sys.exit(1)

    if pid == 0:
        os.setsid()
            
        try:
            pid = os.fork()
        except OSError, e:
            print >>sys.stderr, "Daemon could not be started: %d (%s)" % (e.errno, e.strerror)
            sys.exit(1)

        if pid == 0:               
            os.chdir("/")   #don't prevent unmounting....
            os.umask(0)
        else:
            os._exit(0) # see comments in the recipe
    else:
        os._exit(0)

    import resource
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = 1024
      
    for fd in range(0, maxfd):
        try:
            os.close(fd)
        except OSError:
            pass
            
    os.open(os.devnull, os.O_RDWR)	# standard input (0)

    # Duplicate standard input to standard output and standard error.
    os.dup2(0, 1)			# standard output (1)
    os.dup2(0, 2)			# standard error (2)

if __name__ == "__main__":
    p = optparse.OptionParser(version="Stellaris " + stellaris.__version__, usage="%prog [options] <config file>")
    p.add_option("-d", "--daemon", action="store_const", const=True, dest="daemon",
                 default=False, help="Runs the program in the background.")
    p.add_option("-s", "--setup", action="store", type="string", dest="setup",
                 help="Create the files necessary to run a default stellaris instance.")
#    p.add_option("-i", "--install", action="store", type="string", dest="install_path",
#                 hepl="")

    (opts, args) = p.parse_args()

    if opts.setup:
        import shutil
        from pkg_resources import Requirement, resource_filename
        
        try:
            if not os.path.exists(opts.setup):
                os.mkdir(opts.setup)
        except:
            sys.exit("Could not create directory %s\n" % opts.setup)
            
        # create the necessary directories
        try:
            if not os.path.exists(os.path.join(opts.setup, 'logs')):
                os.mkdir(os.path.join(opts.setup, 'logs'))
        except Exception, e:
            print e
            sys.exit("Could write in directory %s\n" % opts.setup)
            
        # find out where the files necessary for installation are located
        static_dir = resource_filename(Requirement.parse("stellaris"),"static")
        etc_dir = resource_filename(Requirement.parse("stellaris"),"etc")
        templates_dir = resource_filename(Requirement.parse("stellaris"),"templates")
        
        # copy the directories
        try:
            shutil.copytree(static_dir, os.path.join(opts.setup, 'static'))
            shutil.copytree(etc_dir, os.path.join(opts.setup, 'etc'))
            shutil.copytree(templates_dir, os.path.join(opts.setup, 'templates'))
            print "Created the files necessary to run Stellaris in %s." % opts.setup
            print "Start Stellaris with stellaris %s/etc/stellaris.cfg" % opts.setup
        except Exception, e:
            print e
            sys.exit('Could not copy the files to directory %s\n' % opts.setup)
    else:

        if len(args) < 1: # and not os.path.exists(sys.argv[1]):
            p.print_version()
            p.print_help()
            sys.exit(-1)
        
        cfgpath = os.path.abspath(args[0])
        curdir = os.getcwd()
    
        if opts.daemon:
            daemonize()
        
        start(cfgpath, curdir)
