
                     PURE PYTHON XPATH EVALUATOR

                  http://pdis.hiit.fi/pdis/download/

INTRODUCTION

You can try this out like this:

    >>> from pdis.xpath import evaluate
    >>> evaluate("/*/bar/text()",
    	         "<foo><baz>apple</baz><bar>orange</bar></foo>")
    ['orange']

Realistic usage is as follows:

    >>> from elementtree.ElementTree import XML
    >>> from pdis.xpath import compile
    >>> path = compile("/*/bar")
    >>> element1 = XML("<foo><baz>apple</baz><bar>orange</bar></foo>")
    >>> element2 = XML("<foo><hunos>pear</hunos></foo>")
    >>> path.evaluate(element1)
    [<Element bar at 91f08>]
    >>> path.evaluate(element2)
    []

The idea is that a preparsed xpath can be used to filter a large set
of documents (in this case according to whether the xpath evaluates to
a non-empty node set).

FILES

  __init__.py -- package-level definitions for API illustrated above.
  parser.py -- XPath parser.
  lexer.py -- XPath lexical analyzer.
  syntax.py -- XPath syntax tree node types.
  atoms.py -- XPath syntax tree node types for atoms.
  context.py -- XPath evaluation context.
  data_model.py -- XML data model based on elementtree.
  evaluate.py -- subroutines used by evaluate() methods in syntax.py.
  xpath_exceptions.py -- Exception classes.

LIMITATIONS

This package implements a subset of the XPath specification, in part
to simplify the implementation, and in part due to the nature of the
elementtree XML representation.

- Only the self, child and attribute axes are supported.  I am
  considering adding support for the descendant-or-self axis.

- The only node tests allowed with the attribute axis are non-wildcard
  name tests.

- A self::text() step, which should match just text nodes, also
  matches attribute nodes.  For example, "/*/@color/self::text()"
  has the same value as "/*/@color".

- Node sets resulting from union ('|') expressions (or location paths
  using the descendant-or-self axis, when support for it is added) are
  not normalized in the sense of sorting the nodes into document order
  or removing duplicates.  The count(), local-name(), namespace-uri(),
  name(), and sum() functions may return incorrect results when passed
  such unnormalized node sets.

- In a filter expression with one or more predicates (e.g., "(...)[...]"),
  the context size and position are always 1 during the evaluation of the
  predicates.  In particular, the parser transforms "<PrimaryExpr><Predicate>*"
  to "<PrimaryExpr>/self:node()<Predicate>*".  (If this were not done, the
  values would be incorrect anyway for unnormalized node sets.)

- The local-name(), namespace-uri(), and name() functions do not work
  for attribute nodes.

- The name() function only works for unqualified names.

- The id() and lang() functions are unimplemented.

TO DO

- Add support for "//".

