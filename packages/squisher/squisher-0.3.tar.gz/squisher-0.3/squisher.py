#!/usr/bin/env python

'''
Squisher 0.3 - turn Python packages into single hybrid files
               usable as Python bytecode or as ZIP archives.
Copyright (C) 2007 Adam Atlas.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
  * Neither the name of the author nor the names of any contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''

import marshal, imp, sys, zipfile, os, os.path

std_code = '''
# this generated code is placed in the public domain

# an explanation in case anyone opens up a squished file

"""

GENERATED BY SQUISHER 0.3
(by Adam Atlas -- cheeseshop.python.org/pypi/squisher)

Give this file a name ending in .pyc, and you
will be able to import it as a Python module as
usual. Unzip it to access the package contents.%s

"""

import zipimport, os.path, sys, imp, tempfile, binascii, zipfile, cStringIO

modname = __name__
modpath = os.path.abspath(__file__)
primarymod = %r

newname = '_%%s_squish_importer' %% __name__
sys.modules[newname] = sys.modules[__name__]
del sys.modules[__name__]

class Squisher(zipimport.zipimporter):
    data_cache = {}
    resource_names = {}
    
    def __init__(self, path):
        if path.startswith(modpath):
            zipimport.zipimporter.__init__(self, path)
        else:
            raise ImportError
    
    def find_module(self, fullname, path=None):
        localpath = fullname.replace('.', '/')
        if '.' in fullname:
            tailname = fullname[:fullname.rfind('.')]
        else:
            tailname = fullname
        try:
            if __name__ == '__main__' and fullname != primarymod:
                d = self.get_data(primarymod + '/' + localpath + '.so')
            else:
                d = self.get_data(localpath + '.so')
            self.data_cache[fullname] = d
            self.resource_names[fullname] = tailname + '.so'
            return self
        except IOError: pass
        
        try:
            # importing a squished-package-within-a-squished-package
            d = self.get_data(localpath + '.pyc')
            zipfile.ZipFile(cStringIO.StringIO(d), 'r').close()
            self.data_cache[fullname] = d
            self.resource_names[fullname] = tailname + '.pyc'
            return self
        except IOError: pass
        except zipfile.error: pass
        
        return zipimport.zipimporter.find_module(self, fullname, path)
    
    def load_module(self, fullname):
        if fullname in sys.modules:
            return sys.modules[fullname]
        elif fullname in self.data_cache:
            # it's a resource that must be extracted to a physical file
            crc = binascii.crc32(self.data_cache[fullname])
            path = '%%s/squisher_%%s_%%s' %% (tempfile.gettempdir(), crc, self.resource_names[fullname])
            if not os.path.exists(path):
                f = open(path, 'wb')
                f.write(self.data_cache[fullname])
                f.close()
            suffixes = imp.get_suffixes()
            for s in suffixes:
                if path.endswith(s[0]):
                    mod = imp.load_module(fullname, open(path, 'rb'), path, s)
                    mod.__loader__ = self
                    return mod
            raise ImportError
        elif __name__ == '__main__' and fullname == primarymod:
            # we're being invoked on the command line
            code = self.get_code(fullname)
            mod = imp.new_module('__main__')
            sys.modules['__main__'] = sys.modules[fullname] = mod
            mod.__loader__ = self
            modpath = '%%s/%%s' %% (__file__, primarymod)
            if self.is_package(fullname):
                mod.__file__ = modpath + '/__init__.py'
                mod.__path__ = modpath
            else:
                mod.__file__ = modpath
            exec code in mod.__dict__
            return mod
        else:
            # load a typical module from the containing zip archive
            mod = zipimport.zipimporter.load_module(self, fullname)
            if fullname == primarymod and modname != primarymod:
                sys.modules[modname] = mod
            return mod

sys.path_hooks.insert(0, Squisher)
sys.path.insert(0, modpath)

__import__(primarymod)
'''

egg_explanation = '''

This file can also be used as a setuptools egg.
Rename it to:
  %s
and you will be able to use it with easy_install.'''

zipmagic = '\x50\x4B\x03\x04'
pymagic = imp.get_magic() + '\000\000\000\000'

def squisher(zipdata, primary_module, extra_info=''):
    code = compile(std_code % (extra_info, primary_module), '<standard squisher script>', 'exec')
    return pymagic + marshal.dumps(code) + zipdata

def zipdir(path):
    '''takes a directory and makes a zip file containing any
    files therein that are (normally) loadable by Python
    '''
    path = os.path.normpath(path)
    prefix = os.path.basename(path)
    b = cStringIO.StringIO()
    z = zipfile.ZipFile(b, 'w', zipfile.ZIP_DEFLATED)
    for root, dirs, files in os.walk(path):
        for f in files:
            if [x for x in ('.py', '.pyc', '.pyo', '.so') if f.endswith(x)]:
                z.write('%s/%s' % (root, f), '%s/%s' % (prefix, f))
    z.close()
    return b.getvalue()

if __name__ == '__main__':
    import optparse, cStringIO
    
    p = optparse.OptionParser(usage='usage: %prog [options] zipfile')
    p.add_option('-o', '--output', dest='outfile', default='', metavar='FILE')
    p.add_option('-m', '--module', dest='module', default='', metavar='NAME')
    (options, args) = p.parse_args()
    if len(args) == 0:
        p.print_usage()
        sys.exit(2)
    
    zipfn = args.pop(0)
    if os.path.isdir(zipfn):
        zipdata = zipdir(zipfn)
    else:
        if not zipfile.is_zipfile(zipfn):
            sys.exit('%s is not a valid zip file.' % zipfn)
        zipf = file(zipfn)
        zipdata = zipf.read()
        zipf.close()
        if 'GENERATED BY SQUISHER' in zipdata:
            # it's already a squished file; let's update its squisher bytecode
            zipdata = zipdata[zipdata.index(zipmagic):]
    zipbasename = os.path.basename(os.path.normpath(zipfn)).split('.', 1)[0]

    if options.outfile:
        outfn = options.outfile
    else:
        outfn = '%s.pyc' % zipbasename
    outfile = file(outfn, 'w')

    outfile.write(squisher(zipdata, options.module or zipbasename))
    outfile.close()

elif 'setuptools.command' in sys.modules:
    import setuptools.command.bdist_egg as bdist_egg
    from pkg_resources import Distribution
    from distutils import log
    from distutils.dir_util import mkpath
    def mz_decorator(func):
        def make_zipfile(fn, base, verbose=0, dry_run=0, compress=None, mode='w'):
            if mode == 'w':
                dist = Distribution.from_filename(fn)
                n = dist.project_name
                mkpath(os.path.dirname(fn), dry_run=dry_run)
                if not dry_run:
                    f = open(fn, 'w')
                    f.write(squisher('', n, egg_explanation % os.path.basename(fn)))
                    f.close()
                mode = 'a'
            return func(fn, base, verbose, dry_run, compress, mode)
        return make_zipfile
    bdist_egg.make_zipfile = mz_decorator(bdist_egg.make_zipfile)
