% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{palatino}
\definecolor{TitleColor}{rgb}{0.7,0,0}
\definecolor{InnerLinkColor}{rgb}{0.7,0,0}
\definecolor{OuterLinkColor}{rgb}{0.8,0,0}
\definecolor{VerbatimColor}{rgb}{0.985,0.985,0.985}
\definecolor{VerbatimBorderColor}{rgb}{0.8,0.8,0.8}


\title{Routes Documentation}
\date{September 28, 2009}
\release{1.11}
\author{Ben Bangert}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaH[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaI[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaM[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbh[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\begin{document}

\maketitle
\tableofcontents



\resetcurrentobjects
\hypertarget{--doc-manual}{}

\chapter{Routes Manual}

\emph{Updated 2009-09-04 for Routes 1.11}


\section{Introduction}

{\includegraphics{routes-logo.png}\hfill}

Routes tackles an interesting problem that comes up frequently in web
development, \emph{how do you map URLs to your application's actions}? That is, how
do you say that \emph{this} should be accessed as ``/blog/2008/01/08'', and ``/login''
should do \emph{that}? Many web frameworks have a fixed dispatching system; e.g.,
``/A/B/C'' means to read file ``C'' in directory ``B'', or to call method ``C'' of
class ``B'' in module ``A.B''. These work fine until you need to refactor your code
and realize that moving a method changes its public URL and invalidates users'
bookmarks.  Likewise, if you want to reorganize your URLs and make a section
into a subsection, you have to change your carefully-tested logic code.

Routes takes a different approach. You determine your URL hierarchy and and
actions separately, and then link them together in whichever ways you decide.
If you change your mind about a particular URL, just change one line in your
route map and never touch your action logic. You can even have multiple URLs
pointing to the same action; e.g., to support legacy bookmarks.  Routes was
originally inspired by the dispatcher in Ruby on Rails but has since diverged.

Routes is the primary dispatching system in the Pylons web framework, and an
optional choice in CherryPy. It can be added to any
framework without much fuss, and used for an entire site or a URL subtree.
It can also forward subtrees to other dispatching systems, which is how
TurboGears 2 is implemented on top of Pylons.

Current features:
\begin{itemize}
\item {} 
Sophisticated route lookup and URL generation

\item {} 
Named routes

\item {} 
Redirect routes

\item {} 
Wildcard paths before and after static parts

\item {} 
Sub-domain support built-in

\item {} 
Conditional matching based on domain, cookies, HTTP method (RESTful), and more

\item {} 
Easily extensible utilizing custom condition functions and route generation
functions

\item {} 
Extensive unit tests

\end{itemize}

Buzzword compliance:  REST, DRY.

If you're new to Routes or have not read the Routes 1.11 manual before, we
recommend reading the Glossary before continuing.

This manual is written from the user's perspective: how to use Routes in a
framework that already supports it. The Porting
manual describes how to add Routes support to a new framework.

You may have heard about a development version called ``Routes 2''.  Routes 2 is
now called ``Routes-experimental''.  It was originally intended to be a
refactoring with a new API.  Instead its features are being incorporated into
Routes 1 in a compatible manner.  There may be another Routes 2 in the future
that drops deprecated features, but it's too early to say when/if that might
happen.


\section{Setting up routes}

It is assumed that you are using a framework that has preconfigured Routes for
you.  In Pylons, you define your routes in the \code{make\_map} function in your
\emph{myapp/config/routing.py} module.  Here is a typical configuration:

\begin{Verbatim}[commandchars=@\[\]]
1   from routes import Mapper
2   map = Mapper()
3   map.minimization = False
4   map.connect(None, "/error/{action}/{id}, controller="error")
5   map.connect("home", "/", controller="main", action="index")
6   @# ADD CUSTOM ROUTES HERE
7   map.connect(None, "/{controller}/{action}")
8   map.connect(None, "/{controller}/{action}/{id}")
\end{Verbatim}

Lines 1 and 2 create a mapper.  Line 3 is backward compatibility code that
disables an earlier misfeature.

Line 4 matches any three-component route that starts with ``/error'', and sets
the ``controller'' variable to a constant, so that a URL
``/error/images/arrow.jpg'' would produce:

\begin{Verbatim}[commandchars=@\[\]]
{@PYGaB["]@PYGaB[controller]@PYGaB["]: @PYGaB["]@PYGaB[error]@PYGaB["], @PYGaB["]@PYGaB[action]@PYGaB["]: @PYGaB["]@PYGaB[images]@PYGaB["], @PYGaB["]@PYGaB[id]@PYGaB["]: @PYGaB["]@PYGaB[arrow.jpg]@PYGaB["]}
\end{Verbatim}

Line 5 matches the single URL ``/'', and sets both the controller and action to
constants.  It also has a route name ``home'', which can be used in generation.
(The other routes have \code{None} instead of a name, so they don't have names.
It's recommended to name all routes that may be used in generation, but it's
not necessary to name other routes.)

Line 7 matches any two-component URL, and line 8 matches any 3-component URL.
These are used as catchall routes if we're too lazy to define a separate route
for every action.  If you \emph{have} defined a route for every action, you can
delete these two routes.

Note that a URL ``/error/images/arrow.jpg'' could match both line 4 and line 8.
The mapper resolves this by trying routes in the order defined, so this URL
would match line 4.

If no routes match the URL, the mapper returns a ``match failed'' condition,
which is seen in Pylons as HTTP 404 ``Not Found''.

Here are some more examples of valid routes:

\begin{Verbatim}[commandchars=@\[\]]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[/feeds/{category}/atom.xml]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[feeds]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[atom]@PYGaB["])
m@PYGbe[.]connect(@PYGaB["]@PYGaB[history]@PYGaB["], @PYGaB["]@PYGaB[/archives/by@_eon/{century}]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[archives]@PYGaB["],
          action@PYGbe[=]@PYGaB["]@PYGaB[aggregate]@PYGaB["])
m@PYGbe[.]connect(@PYGaB["]@PYGaB[article]@PYGaB["], @PYGaB["]@PYGaB[/article/{section}/{slug}/{page}.html]@PYGaB["],
          controller@PYGbe[=]@PYGaB["]@PYGaB[article]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[view]@PYGaB["])
\end{Verbatim}

Extra variables may be any Python type, not just strings.  However, if the
route is used in generation, \code{str()} will  be called on the value unless
the generation call specifies an overriding value.

Other argument syntaxes are allowed for compatibility with earlier versions of
Routes.  These are described in the \code{Backward Compatibility} section.

Route paths should always begin with a slash (``/'').  Earlier versions of
Routes allowed slashless paths, but their behavior now is undefined.


\subsection{Requirements}

It's possible to restrict a path variable to a regular expression; e.g., to
match only a numeric component or a restricted choice of words.  There are two
syntaxes for this: inline and the \code{requirements} argument.  An inline
requirement looks like this:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB[R"]@PYGaB[/blog/{id:]@PYGaB[\]@PYGaB[d+}]@PYGaB["])
@PYGaY[map]@PYGbe[.]connect(@PYGaB[R"]@PYGaB[/download/{platform:windows@textbar[]mac}/{filename}]@PYGaB["])
\end{Verbatim}

This matches ``/blog/123'' but not ``/blog/12A''.  The equivalent \code{requirements}
syntax is:

\begin{Verbatim}[commandchars=@\[\]]
map.connect("/blog/{id}", requirements={"id": R"\d+"}
map.connect("/download/{platform}/{filename}",
    requirements={"platform": R"windows@textbar[]mac"})
\end{Verbatim}

Note the use of raw string syntax (\code{R""}) for regexes which might contain
backslashes.  Without the R you'd have to double every backslash.

Another example:

\begin{Verbatim}[commandchars=@\[\]]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[archives/{year}/{month}/{day}]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[archives]@PYGaB["],
          action@PYGbe[=]@PYGaB["]@PYGaB[view]@PYGaB["], year@PYGbe[=]@PYGaw[2004],
          requirements@PYGbe[=]@PYGaY[dict](year@PYGbe[=]@PYGaB[R"]@PYGaB[\]@PYGaB[d{2,4}]@PYGaB["], month@PYGbe[=]@PYGaB[R"]@PYGaB[\]@PYGaB[d{1,2}]@PYGaB["]))
\end{Verbatim}

The inline syntax was added in Routes (XXX 1.10?? not in changelog).  Previous
versions had only the \code{requirements} argument.  Two advantages of the
\code{requirements} argument are that if you have several variables with identical
requirements, you can set one variable or even the entire argument to a
global:

\begin{Verbatim}[commandchars=@\[\]]
NUMERIC @PYGbe[=] @PYGaB[R"]@PYGaB[\]@PYGaB[d+]@PYGaB["]
@PYGaY[map]@PYGbe[.]connect(@PYGbe[.]@PYGbe[.]@PYGbe[.], requirements@PYGbe[=]{@PYGaB["]@PYGaB[id]@PYGaB["]: NUMERIC})

ARTICLE@_REQS @PYGbe[=] {@PYGaB["]@PYGaB[year]@PYGaB["]: @PYGaB[R"]@PYGaB[\]@PYGaB[d]@PYGaB[\]@PYGaB[d]@PYGaB[\]@PYGaB[d]@PYGaB[\]@PYGaB[d]@PYGaB["], @PYGaB["]@PYGaB[month]@PYGaB["]: @PYGaB[R"]@PYGaB[\]@PYGaB[d]@PYGaB[\]@PYGaB[d]@PYGaB["], @PYGaB["]@PYGaB[day]@PYGaB["]: @PYGaB[R"]@PYGaB[\]@PYGaB[d]@PYGaB[\]@PYGaB[d]@PYGaB["]}
@PYGaY[map]@PYGbe[.]connect(@PYGbe[.]@PYGbe[.]@PYGbe[.], requirements@PYGbe[=]ARTICLE@_REQS)
\end{Verbatim}

Because the argument \code{requirements} is reserved, you can't define a routing
variable by that name.


\subsection{Magic path\_info}

If the ``path\_info'' variable is used at the end of the URL, Routes moves
everything preceding it into the ``SCRIPT\_NAME'' environment variable.  This is
useful when delegating to another WSGI application that does its own routing:
the subapplication will route on the remainder of the URL rather than the
entire URL.  You still
need the ``:.*'' requirement to capture the following URL components into the
variable.

\begin{Verbatim}[commandchars=@\[\]]
map.connect(None, "/cards/{path@_info:.*}",
    controller="main", action="cards")
@# Incoming URL "/cards/diamonds/4.png"
=@textgreater[] {"controller": "main", action: "cards", "path@_info": "/diamonds/4.png"}
@# Second WSGI application sees:
@# SCRIPT@_NAME="/cards"   PATH@_INFO="/diamonds/4.png"
\end{Verbatim}

This route does not match ``/cards'' because it requires a following slash.
Add another route to get around this:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[cards]@PYGaB["], @PYGaB["]@PYGaB[/cards]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[main]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[cards]@PYGaB["],
    path@_info@PYGbe[=]@PYGaB["]@PYGaB[/]@PYGaB["])
\end{Verbatim}

\begin{notice}{tip}{Tip:}
You may think you can combine the two with the following route:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[cards]@PYGaB["], @PYGaB["]@PYGaB[/cards{path@_info:.*}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[main]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[cards]@PYGaB["])
\end{Verbatim}

There are two problems with this, however. One, it would also match
``/cardshark''.  Two, Routes 1.10 has a bug: it forgets to take
the suffix off the SCRIPT\_NAME.
\end{notice}

A future version of Routes may delegate directly to WSGI applications, but for
now this must be done in the framework.  In Pylons, you can do this in a
controller action as follows:

\begin{Verbatim}[commandchars=@\[\]]
@PYGal[from] @PYGaW[paste.fileapp] @PYGal[import] DirectoryApp
@PYGay[def] @PYGaL[cards](@PYGaA[self], environ, start@_response):
    app @PYGbe[=] DirectoryApp(@PYGaB["]@PYGaB[/cards-directory]@PYGaB["])
    @PYGay[return] app(environ, start@_response)
\end{Verbatim}

Or create a fake controller module with a \code{\_\_controller\_\_} variable set to
the WSGI application:

\begin{Verbatim}[commandchars=@\[\]]
@PYGal[from] @PYGaW[paste.fileapp] @PYGal[import] DirectoryApp
@_@_controller@_@_ @PYGbe[=] DirectoryApp(@PYGaB["]@PYGaB[/cards-directory]@PYGaB["])
\end{Verbatim}


\subsection{Conditions}

Conditions impose additional constraints on what kinds of requests can match.
The \code{conditions} argument is a dict with up to three keys:
\begin{quote}

method
\begin{quote}

A list of uppercase HTTP methods.  The request must be one of the
listed methods.
\end{quote}

sub\_domain
\begin{quote}

Can be a list of subdomains, \code{True}, \code{False}, or \code{None}.  If a
list, the request must be for one of the specified subdomains.  If
\code{True}, the request must contain a subdomain but it can be anything.
If \code{False} or \code{None}, do not match if there's a subdomain.

\emph{New in Routes 1.10: {}`{}`False{}`{}` and {}`{}`None{}`{}` values.}
\end{quote}

function
\begin{quote}

A function that evaluates the request.  Its signature must be
\code{func(environ, match\_dict) =\textgreater{} bool}.  It should return true if the
match is successful or false otherwise.  The first arg is the WSGI
environment; the second is the routing variables that would be
returned if the match succeeds.  The function can modify \code{match\_dict}
in place to affect which variables are returned.  This allows a wide
range of transformations.
\end{quote}
\end{quote}

Examples:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaE[@# Match only if the HTTP method is "GET" or "HEAD".]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[/user/list]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[user]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[list]@PYGaB["],
          conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["], @PYGaB["]@PYGaB[HEAD]@PYGaB["]@PYGZrb[]))

@PYGaE[@# A sub-domain should be present.]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[/]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[user]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["],
          conditions@PYGbe[=]@PYGaY[dict](sub@_domain@PYGbe[=]@PYGaA[True]))

@PYGaE[@# Sub-domain should be either "fred" or "george".]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[/]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[user]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["],
          conditions@PYGbe[=]@PYGaY[dict](sub@_domain@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[fred]@PYGaB["], @PYGaB["]@PYGaB[george]@PYGaB["]@PYGZrb[]))

@PYGaE[@# Put the referrer into the resulting match dictionary.]
@PYGaE[@# This function always returns true, so it never prevents the match]
@PYGaE[@# from succeeding.]
@PYGay[def] @PYGaL[referals](environ, result):
    result@PYGZlb[]@PYGaB["]@PYGaB[referer]@PYGaB["]@PYGZrb[] @PYGbe[=] environ@PYGbe[.]get(@PYGaB["]@PYGaB[HTTP@_REFERER]@PYGaB["])
    @PYGay[return] @PYGaA[True]
m@PYGbe[.]connect(@PYGaB["]@PYGaB[/{controller}/{action}/{id}]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](function@PYGbe[=]referals))
\end{Verbatim}


\subsection{Wildcard routes}

By default, path variables do not match a slash.  This ensures that each
variable will match exactly one component.  You can use requirements to
override this:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/static/{filename:.*?}]@PYGaB["])
\end{Verbatim}

This matches ``/static/foo.jpg'', ``/static/bar/foo.jpg'', etc.

Beware that careless regexes may eat the entire rest of the URL and cause
components to the right of it not to match:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaE[@# OK because the following component is static and the regex has a "?".]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/static/{filename:.*?}/download]@PYGaB["])
\end{Verbatim}

The lesson is to always test wildcard patterns.


\subsection{Submappers}

A submapper lets you add several similar routes
without having to repeat identical keyword arguments.  There are two syntaxes,
one using a Python \code{with} block, and the other avoiding it.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaE[@# Using 'with']
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[home]@PYGaB["], @PYGaB["]@PYGaB[/]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[splash]@PYGaB["])
@PYGay[with] @PYGaY[map]@PYGbe[.]submapper(controller@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["]) @PYGay[as] m:
    m@PYGbe[.]connect(@PYGaB["]@PYGaB[index]@PYGaB["], @PYGaB["]@PYGaB[/index]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[index]@PYGaB["])

@PYGaE[@# Not using 'with']
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[home]@PYGaB["], @PYGaB["]@PYGaB[/]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[splash]@PYGaB["])
m @PYGbe[=] @PYGaY[map]@PYGbe[.]submapper(controller@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["])
m@PYGbe[.]connect(@PYGaB["]@PYGaB[index]@PYGaB["], @PYGaB["]@PYGaB[/index]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[index]@PYGaB["])

@PYGaE[@# Both of these syntaxes create the following routes::]
@PYGaE[@# "/"      =@textgreater[] {"controller": "home", action="splash"}]
@PYGaE[@# "/index" =@textgreater[] {"controller": "home", action="index"}]
\end{Verbatim}

You can also specify a common path prefix for your routes:

\begin{Verbatim}[commandchars=@\[\]]
@PYGay[with] @PYGaY[map]@PYGbe[.]submapper(path@_prefix@PYGbe[=]@PYGaB["]@PYGaB[/admin]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[admin]@PYGaB["]) @PYGay[as] m:
    m@PYGbe[.]connect(@PYGaB["]@PYGaB[admin@_users]@PYGaB["], @PYGaB["]@PYGaB[/users]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[users]@PYGaB["])
    m@PYGbe[.]connect(@PYGaB["]@PYGaB[admin@_databases]@PYGaB["], @PYGaB["]@PYGaB[/databases]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[databases]@PYGaB["])

@PYGaE[@# /admin/users     =@textgreater[] {"controller": "admin", "action": "users"}]
@PYGaE[@# /admin/databases =@textgreater[] {"controller": "admin", "action": "databases"}]
\end{Verbatim}

All arguments to \code{.submapper} must be keyword arguments.

The submapper is \emph{not} a complete mapper.  It's just a temporary object
with a \code{.connect} method that adds routes to the mapper it was spawned
from.

\emph{New in Routes 1.11.}


\subsection{Adding routes from a nested application}

\emph{New in Routes 1.11.}  Sometimes in nested applications, the child application
gives the parent a list of routes to add to its mapper.  These can be added
with the \code{.extend} method, optionally providing a path prefix:

\begin{Verbatim}[commandchars=@\[\]]
routes @PYGbe[=] @PYGZlb[]
    Route(@PYGaB["]@PYGaB[index]@PYGaB["], @PYGaB["]@PYGaB[/index.html]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[home]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[index]@PYGaB["]),
    @PYGZrb[]

@PYGaY[map]@PYGbe[.]extend(routes)
@PYGaE[@# /index.html =@textgreater[] {"controller": "home", "action": "index"}]

@PYGaY[map]@PYGbe[.]extend(routes, @PYGaB["]@PYGaB[/subapp]@PYGaB["])
@PYGaE[@# /subapp/index.html =@textgreater[] {"controller": "home", "action": "index"}]
\end{Verbatim}

This does not exactly add the route objects to the mapper.  It creates
identical new route objects and adds those to the mapper.

\emph{New in Routes 1.11.}


\section{Generation}

To generate URLs, use the \code{url} or \code{url\_for} object provided by your
framework.  \code{url} is an instance of Routes \code{URLGenerator}, while
\code{url\_for} is the older \code{routes.url\_for()} function.  \code{url\_for} is being
phased out, so new applications should use \code{url}.

To generate a named route, specify the route name as a positional argument:

\begin{Verbatim}[commandchars=@\[\]]
url("home")   =@textgreater[]  "/"
\end{Verbatim}

If the route contains path variables, you must specify values for them using
keyword arguments:

\begin{Verbatim}[commandchars=@\[\]]
url(@PYGaB["]@PYGaB[blog]@PYGaB["], year@PYGbe[=]@PYGaw[2008], month@PYGbe[=]@PYGaw[10], day@PYGbe[=]@PYGaw[2])
\end{Verbatim}

Non-string values are automatically converted to strings using \code{str()}.
(This may break with Unicode values containing non-ASCII characters.)

However, if the route defines an extra variable with the same name as a path
variable, the extra variable is used as the default if that keyword is not
specified.  Example:

\begin{Verbatim}[commandchars=@\[\]]
m.connect("archives", "/archives/{id}",
    controller="archives", action="view", id=1)
url("blog", id=123)  =@textgreater[]  "/blog/123"
url("blog")  =@textgreater[]  "/blog/1"
\end{Verbatim}

(The extra variable is \emph{not} used for matching unless minimization is enabled.)

Any keyword args that do not correspond to path variables will be put in the
query string.  Append a ``\_'' if the variable name collides with a Python
keyword:

\begin{Verbatim}[commandchars=@\[\]]
map.connect("archive", "/archive/{year}")
url("archive", year=2009, font=large)  =@textgreater[]  "/archive/2009?font=large"
url("archive", year=2009, print@_=1)  =@textgreater[]  "/archive/2009?print=1"
\end{Verbatim}

If the application is mounted at a subdirectory of the URL space,
all generated URLs will have the application prefix.  The application prefix is
the ``SCRIPT\_NAME'' variable in the request's WSGI environment.

If the positional argument corresponds to no named route, it is assumed to be a
literal URL.  The application's mount point is prefixed to it, and keyword args
are converted to query parameters:

\begin{Verbatim}[commandchars=@\[\]]
url("/search", q="My question")  =@textgreater[]  "/search?q=My+question"
\end{Verbatim}

If there is no positional argument, Routes will use the keyword args to choose
a route.  The first route that has all path variables specified by keyword args
and the fewest number of extra variables not overridden by keyword args will be
chosen.  This was common in older versions of Routes but can cause application
bugs if an unexpected route is chosen, so using route names is much preferable
because that guarantees only the named route will be chosen.  The most common
use for unnamed generation is when you have a seldom-used controller with a lot
of ad hoc methods; e.g., \code{url(controller="admin", action="session")}.

An exception is raised if no route corresponds to the arguments.  The exception
is \code{routes.util.GenerationException}.  (Prior to Routes 1.9, \code{None} was
returned instead.  It was changed to an exception to prevent invalid blank URLs
from being insered into templates.)

You'll also get this exception if Python produces a Unicode URL (which could
happen if the route path or a variable value is Unicode).  Routes generates
only \code{str} URLs.

The following keyword args are special:
\begin{quote}

anchor
\begin{quote}

Specifies the URL anchor (the part to the right of ``\#'').

\begin{Verbatim}[commandchars=@\[\]]
url("home", "summary")  =@textgreater[]  "/@#summary"
\end{Verbatim}
\end{quote}

host
\begin{quote}

Make the URL fully qualified and override the host (domain).
\end{quote}

protocol
\begin{quote}

Make the URL fully qualified and override the protocol (e.g., ``ftp'').
\end{quote}

qualified
\begin{quote}

Make the URL fully qualified (i.e., add ``protocol://host:port'' prefix).
\end{quote}

sub\_domain
\begin{quote}

See ``Generating URLs with subdomains'' below.
\end{quote}
\end{quote}

The syntax in this section is the same for both \code{url} and \code{url\_for}.

\emph{New in Routes 1.10: {}`{}`url{}`{}` and the {}`{}`URLGenerator{}`{}` class behind it.}


\subsection{Generating routes based on the current URL}

\code{url.current()} returns the URL of the current request, without the query
string.  This is called ``route memory'', and works only if the RoutesMiddleware
is in the middleware stack.  Keyword arguments override path variables or are
put on the query string.

\code{url\_for} combines the behavior of \code{url} and \code{url\_current}.  This is
deprecated because nameless routes and route memory have the same syntax, which
can lead to the wrong route being chosen in some cases.

Here's an example of route memory:

\begin{Verbatim}[commandchars=@\[\]]
m.connect("/archives/{year}/{month}/{day}", year=2004)

@# Current URL is "/archives/2005/10/4".
@# Routing variables are {"controller": "archives", "action": "view",
  "year": "2005", "month": "10", "day": "4"}

url.current(day=6)    =@textgreater[]  "/archives/2005/10/6"
url.current(month=4)  =@textgreater[]  "/archives/2005/4/4"
url.current()         =@textgreater[]  "/archives/2005/10/4"
\end{Verbatim}

Route memory can be disabled globally with \code{map.explicit = True}.


\subsection{Generation-only routes (aka. static routes)}

A static route is used only for generation -- not matching -- and it must be
named.  To define a static route, use the argument \code{\_static=True}.

This example provides a convenient way to link to a search:

\begin{Verbatim}[commandchars=@\[\]]
map.connect("google", "http://google.com/", @_static=True)
url("google", q="search term")  =@textgreater[]  "/http://google.com/?q=search+term")
\end{Verbatim}

This example generates a URL to a static image in a Pylons public directory.
Pylons serves the public directory in a way that bypasses Routes, so there's no
reason to match URLs under it.

\begin{Verbatim}[commandchars=@\[\]]
map.connect("attachment", "/images/attachments/{category}/{id}.jpg",
    @_static=True)
url("attachment", category="dogs", id="Mastiff") =@textgreater[]
    "/images/attachments/dogs/Mastiff.jpg"
\end{Verbatim}

Starting in Routes 1.10, static routes are exactly the same as regular routes
except they're not added to the internal match table.  In previous versions of
Routes they could not contain path variables and they had to point to external
URLs.


\subsection{Filter functions}

A filter function modifies how a named route is generated.  Don't confuse it
with a function condition, which is used in matching.  A filter function is its
opposite counterpart.

One use case is when you have a \code{story} object with attributes for year,
month, and day.  You don't want to hardcode these attributes in every \code{url}
call because the interface may change someday.  Instead you pass the story as a
pseudo-argument, and the filter produces the actual generation args.  Here's an
example:

\begin{Verbatim}[commandchars=@\[\]]
class Story(object):
    def @_@_init@_@_(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    @PYGZat[]staticmethod
    def expand(kw):
        try:
            story = kw@PYGZlb[]"story"@PYGZrb[]
        except KeyError:
            pass   @# Don't modify dict if []`[]`story[]`[]` key not present.
        else:
            @# Set the actual generation args from the story.
            kw@PYGZlb[]"year"@PYGZrb[] = story.year
            kw@PYGZlb[]"month"@PYGZrb[] = story.month
            kw@PYGZlb[]"day"@PYGZrb[] = story.day
        return kw

m.connect("archives", "/archives/{year}/{month}/{day}",
    controller="archives", action="view", @_filter=Story.expand)

my@_story = Story(2009, 1, 2)
url("archives", story=my@_story)  =@textgreater[]  "/archives/2009/1/2"
\end{Verbatim}

The \code{\_filter} argument can be any function that takes a dict and returns a
dict.  In the example we've used a static method of the \code{Story} class to keep
everything story-related together, but you may prefer to use a standalone
function to keep Routes-related code away from your model.


\subsection{Generating URLs with subdomains}

If subdomain support is enabled and the \code{sub\_domain} arg is passed to
\code{url\_for}, Routes ensures the generated route points to that subdomain.

\begin{Verbatim}[commandchars=@\[\]]
@# Enable subdomain support.
map.sub@_domains = True

@# Ignore the www subdomain.
map.sub@_domains@_ignore = "www"

map.connect("/users/{action}")

@# Add a subdomain.
url@_for(action="update", sub@_domain="fred")  =@textgreater[]  "http://fred.example.com/users/update"

@# Delete a subdomain.  Assume current URL is fred.example.com.
url@_for(action="new", sub@_domain=None)  =@textgreater[]  "http://example.com/users/new"
\end{Verbatim}


\section{Unicode}

Routes assumes UTF-8 encoding on incoming URLs, and \code{url} and \code{url\_for}
also generate UTF-8.  You can change the encoding with the \code{map.charset}
attribute:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]charset @PYGbe[=] @PYGaB["]@PYGaB[latin-1]@PYGaB["]
\end{Verbatim}

New in Routes 1.10: several bugfixes.


\section{RESTful services}

Routes makes it easy to configure RESTful web services.  \code{map.resource}
creates a set of add/modify/delete routes conforming to the Atom publishing
protocol.

A resource route addresses \emph{members} in a \emph{collection}, and the collection
itself.  Normally a collection is a plural word, and a member is the
corresponding singular word.  For instance, consider a collection of messages:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB["]@PYGaB[message]@PYGaB["], @PYGaB["]@PYGaB[messages]@PYGaB["])

@PYGaE[@# The above command sets up several routes as if you had typed the]
@PYGaE[@# following commands:]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[messages]@PYGaB["], @PYGaB["]@PYGaB[/messages]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[create]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[POST]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[messages]@PYGaB["], @PYGaB["]@PYGaB[/messages]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[index]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[formatted@_messages]@PYGaB["], @PYGaB["]@PYGaB[/messages.{format}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[index]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[new@_message]@PYGaB["], @PYGaB["]@PYGaB[/messages/new]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[new]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[formatted@_new@_message]@PYGaB["], @PYGaB["]@PYGaB[/messages/new.{format}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[new]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/messages/{id}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[update]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[PUT]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/messages/{id}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[delete]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[DELETE]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[edit@_message]@PYGaB["], @PYGaB["]@PYGaB[/messages/{id}/edit]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[edit]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[formatted@_edit@_message]@PYGaB["], @PYGaB["]@PYGaB[/messages/{id}.{format}/edit]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[edit]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[message]@PYGaB["], @PYGaB["]@PYGaB[/messages/{id}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[show]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[formatted@_message]@PYGaB["], @PYGaB["]@PYGaB[/messages/{id}.{format}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[messages]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[show]@PYGaB["],
    conditions@PYGbe[=]@PYGaY[dict](method@PYGbe[=]@PYGZlb[]@PYGaB["]@PYGaB[GET]@PYGaB["]@PYGZrb[]))
\end{Verbatim}

This establishes the following convention:

\begin{Verbatim}[commandchars=@\[\]]
GET    /messages        =@textgreater[] messages.index()    =@textgreater[] url("messages")
POST   /messages        =@textgreater[] messages.create()   =@textgreater[] url("messages")
GET    /messages/new    =@textgreater[] messages.new()      =@textgreater[] url("new@_message")
PUT    /messages/1      =@textgreater[] messages.update(id) =@textgreater[] url("message", id=1)
DELETE /messages/1      =@textgreater[] messages.delete(id) =@textgreater[] url("message", id=1)
GET    /messages/1      =@textgreater[] messages.show(id)   =@textgreater[] url("message", id=1)
GET    /messages/1/edit =@textgreater[] messages.edit(id)   =@textgreater[] url("edit@_message", id=1)
\end{Verbatim}

Thus, you GET the collection to see an index of links to members (``index''
method).  You GET a member to see it (``show'').  You GET ``COLLECTION/new'' to
obtain a new message form (``new''), which you POST to the collection (``create'').
You GET ``MEMBER/edit'' to obtain an edit for (``edit''), which you PUT to the
member (``update'').  You DELETE the member to delete it.  Note that there are
only four route names because multiple actions are doubled up on the same URLs.

This URL structure may look strange if you're not used to the Atom protocol.
REST is a vague term, and some people think it means proper URL syntax (every
component contains the one on its right), others think it means not putting IDs
in query parameters, and others think it means using HTTP methods beyond GET
and POST.  \code{map.resource} does all three, but it may be overkill for
applications that don't need Atom compliance or prefer to stick with GET and
POST.  \code{map.resource} has the advantage that many automated tools and
non-browser agents will be able to list and modify your resources without any
programming on your part.  But you don't have to use it if you prefer a simpler
add/modify/delete structure.

HTML forms can produce only GET and POST requests.  As a workaround, if a POST
request contains a \code{\_method} parameter, the Routes middleware changes the
HTTP method to whatever the parameter specifies, as if it had been requested
that way in the first place.  This convention is becoming increasingly common
in other frameworks.  If you're using WebHelpers, the The WebHelpers \code{form}
function has a \code{method} argument which automatically sets the HTTP method and
``\_method'' parameter.

Several routes are paired with an identical route containing the \code{format}
variable.  The intention is to allow users to obtain different formats by means
of filename suffixes; e.g., ``/messages/1.xml''.  This produces a routing
variable ``xml'', which in Pylons will be passed to the controller action if it
defines a formal argument for it.  In generation you can pass the \code{format}
argument to produce a URL with that suffix:

\begin{Verbatim}[commandchars=@\[\]]
url("message", id=1, format="xml")  =@textgreater[]  "/messages/1.xml"
\end{Verbatim}

Routes does not recognize any particular formats or know which ones are valid
for your application.  It merely passes the \code{format} attribute through if it
appears.

New in Routes 1.7.3: changed URL suffix from ``;edit'' to ``/edit''.  Semicolons
are not allowed in the path portion of a URL except to delimit path parameters,
which nobody uses.


\subsection{Resource options}

The \code{map.resource} method recognizes a number of keyword args which modifies
its behavior:

controller
\begin{quote}

Use the specified controller rather than deducing it from the collection
name.
\end{quote}

collection
\begin{quote}

Additional URLs to allow for the collection.  Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB["]@PYGaB[message]@PYGaB["], @PYGaB["]@PYGaB[messages]@PYGaB["], collection@PYGbe[=]{@PYGaB["]@PYGaB[rss]@PYGaB["]: @PYGaB["]@PYGaB[GET]@PYGaB["]})
@PYGaE[@# "GET /message/rss"  =@textgreater[]  []`[]`Messages.rss()[]`[]`.]
@PYGaE[@# Defines a named route "rss@_messages".]
\end{Verbatim}
\end{quote}

member
\begin{quote}

Additional URLs to allow for a member.  Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB[']@PYGaB[message]@PYGaB['], @PYGaB[']@PYGaB[messages]@PYGaB['], member@PYGbe[=]{@PYGaB[']@PYGaB[mark]@PYGaB[']:@PYGaB[']@PYGaB[POST]@PYGaB[']})
@PYGaE[@# "POST /message/1/mark"  =@textgreater[]  []`[]`Messages.mark(1)[]`[]`]
@PYGaE[@# also adds named route "mark@_message"]
\end{Verbatim}

This can be used to display a delete confirmation form:

\begin{Verbatim}[commandchars=@\[\]]
map.resource("message", "messages", member={"ask@_delete": "GET"}
@# "GET /message/1/ask@_delete"   =@textgreater[]   []`[]`Messages.ask@_delete(1)[]`[]`.
@# Also adds a named route "ask@_delete@_message".
\end{Verbatim}
\end{quote}

new
\begin{quote}

Additional URLs to allow for new-member functionality.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB["]@PYGaB[message]@PYGaB["], @PYGaB["]@PYGaB[messages]@PYGaB["], new@PYGbe[=]{@PYGaB["]@PYGaB[preview]@PYGaB["]: @PYGaB["]@PYGaB[POST]@PYGaB["]})
@PYGaE[@# "POST /messages/new/preview"]
\end{Verbatim}
\end{quote}

path\_prefix
\begin{quote}

Prepend the specified prefix to all URL patterns.  The prefix may include
path variables.  This is mainly used to nest resources within resources.
\end{quote}

name\_prefix
\begin{quote}

Prefix the specified string to all route names.  This is most often
combined with \code{path\_prefix} to nest resources:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB["]@PYGaB[message]@PYGaB["], @PYGaB["]@PYGaB[messages]@PYGaB["], controller@PYGbe[=]@PYGaB["]@PYGaB[categories]@PYGaB["],
    path@_prefix@PYGbe[=]@PYGaB["]@PYGaB[/category/{category@_id}]@PYGaB["],
    name@_prefix@PYGbe[=]@PYGaB["]@PYGaB[category@_]@PYGaB["])
@PYGaE[@# GET /category/7/message/1]
@PYGaE[@# Adds named route "category@_message"]
\end{Verbatim}
\end{quote}

parent\_resource
\begin{quote}

A dict containing information about the parent resource, for creating a
nested resource. It should contain the member\_name and collection\_name
of the parent resource. This dict will be available via the associated
Route object which can be accessed during a request via
\code{request.environ{[}"routes.route"{]}}.

If parent\_resource is supplied and path\_prefix isn't, path\_prefix will
be generated from parent\_resource as ``\textless{}parent collection name\textgreater{}/:\textless{}parent
member name\textgreater{}\_id''.

If parent\_resource is supplied and name\_prefix isn't, name\_prefix will
be generated from parent\_resource as ``\textless{}parent member name\textgreater{}\_''.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper()
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['],
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['],
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']))
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# path@_prefix is "regions/:region@_id"]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# name prefix is "region@_"]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[region@_locations]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13])
@PYGaa['/regions/13/locations']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[region@_new@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13])
@PYGaa['/regions/13/locations/new']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[region@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13], @PYGaY[id]@PYGbe[=]@PYGaw[60])
@PYGaa['/regions/13/locations/60']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[region@_edit@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13], @PYGaY[id]@PYGbe[=]@PYGaw[60])
@PYGaa['/regions/13/locations/60/edit']

@PYGaa[Overriding generated path@_prefix:]

@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper()
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['],
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['],
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']),
@PYGaQ[... ]           path@_prefix@PYGbe[=]@PYGaB[']@PYGaB[areas/:area@_id]@PYGaB['])
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# name prefix is "region@_"]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[region@_locations]@PYGaB['], area@_id@PYGbe[=]@PYGaw[51])
@PYGaa['/areas/51/locations']

@PYGaa[Overriding generated name@_prefix:]

@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper()
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['],
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['],
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']),
@PYGaQ[... ]           name@_prefix@PYGbe[=]@PYGaB[']@PYGaB['])
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# path@_prefix is "regions/:region@_id"]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url(@PYGaB[']@PYGaB[locations]@PYGaB['], region@_id@PYGbe[=]@PYGaw[51])
@PYGaa['/regions/51/locations']
\end{Verbatim}
\end{quote}


\section{Redirect routes}

Redirect routes allow you to specify redirects in the route map, similar to
RewriteRule in an Apache configuration.  This avoids the need to define dummy
controller actions just to handle redirects.  It's especially useful when the
URL structure changes and you want to redirect legacy URLs to their new
equivalents.  The redirection is done by the Routes middleware, and the WSGI
application is not called.

\code{map.redirect} takes two positional arguments:  the route path and the
destination URL.  Redirect routes do not have a name.  Both paths can contain
variables, and the route path can take inline requirements.  Keyword arguments
are the same as \code{map.connect}, both in regards to extra variables and to route
options.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]redirect(@PYGaB["]@PYGaB[/legacyapp/archives/{url:.*}]@PYGaB["], @PYGaB["]@PYGaB[/archives/{url}]@PYGaB["])

@PYGaY[map]@PYGbe[.]redirect(@PYGaB["]@PYGaB[/legacyapp/archives/{url:.*}]@PYGaB["], @PYGaB["]@PYGaB[/archives/{url}]@PYGaB["])
\end{Verbatim}

By default a ``302 Found'' HTTP status is issued.  You can override this with the
\code{\_redirect\_code} keyword argument.  The value must be an entire status
string.

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]redirect(@PYGaB["]@PYGaB[/home/index]@PYGaB["], @PYGaB["]@PYGaB[/]@PYGaB["], @_redirect@_code@PYGbe[=]@PYGaB["]@PYGaB[301 Moved Permanently]@PYGaB["])
\end{Verbatim}

\emph{New in Routes 1.10.}


\section{Introspection}

The mapper attribute \code{.matchlist} contains the list of routes to be matched
against incoming URLs.  You can iterate this list to see what routes are
defined.  This can be useful when debugging route configurations.


\section{Other}

If your application is behind an HTTP proxy such a load balancer on another
host, the WSGI environment will refer to the internal server rather than to the
proxy, which will mess up generated URLs.  Use the ProxyMiddleware in
PasteDeploy to fix the WSGI environment to what it would have been without the
proxy.

To debug routes, turn on debug logging for the ``routes.middleware'' logger.
(See Python's \code{logging} module to set up your logging configuration.)


\section{Backward compatibility}

The following syntaxes are allowed for compatibility with previous versions
of Routes.  They may be removed in the future.


\subsection{Omitting the name arg}

In the tutorial we said that nameless routes can be defined by passing \code{None}
as the first argument.  You can also omit the first argument entirely:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaA[None], @PYGaB["]@PYGaB[/{controller}/{action}]@PYGaB["])
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/{controller}/{action}]@PYGaB["])
\end{Verbatim}

The syntax with \code{None} is preferred to be forward-compatible with future
versions of Routes.  It avoids the path argument changing position between
the first and second arguments, which is unpythonic.


\subsection{:varname}

Path variables were defined in the format \code{:varname} and \code{:(varname)}
prior to Routes 1.9.  The form with parentheses was called ``grouping'', used
to delimit the variable name from a following letter or number.  Thus the old
syntax ``/:controller/:(id)abc'' corresponds to the new syntax
``/\{controller\}/\{id\}abc''.

The older wildcard syntax is \code{*varname} or \code{*(varname)}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaE[@# OK because the following component is static.]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/static/*filename/download]@PYGaB["])

@PYGaE[@# Deprecated syntax.  WRONG because the wildcard will eat the rest of the]
@PYGaE[@# URL, leaving nothing for the following variable, which will cause the]
@PYGaE[@# match to fail.]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[/static/*filename/:action]@PYGaB["])
\end{Verbatim}


\subsection{Minimization}

Minimization was a misfeature which was intended to save typing, but which
often resulted in the wrong route being chosen.  New applications should
disable it by putting \code{map.minimization = False} in their route definitions.
Old applications that depend on it can set the attribute to true.

Without minimization, the URL must contain values for all path variables in
the route:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB["]@PYGaB[basic]@PYGaB["], @PYGaB["]@PYGaB[/{controller}/{action}]@PYGaB["],
    controller@PYGbe[=]@PYGaB["]@PYGaB[mycontroller]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[myaction]@PYGaB["], weather@PYGbe[=]@PYGaB["]@PYGaB[sunny]@PYGaB["])
\end{Verbatim}

This route matches any two-component URL, for instance ``/help/about''.  The
resulting routing variables would be:

\begin{Verbatim}[commandchars=@\[\]]
{@PYGaB["]@PYGaB[controller]@PYGaB["]: @PYGaB["]@PYGaB[help]@PYGaB["], @PYGaB["]@PYGaB[action]@PYGaB["]: @PYGaB["]@PYGaB[about]@PYGaB["], @PYGaB["]@PYGaB[weather]@PYGaB["]: @PYGaB["]@PYGaB[sunny]@PYGaB["]}
\end{Verbatim}

The path variables are taken from the URL, and any extra variables are added as
constants.  The extra variables for ``controller'' and ``action'' are \emph{never used}
in matching, but are available as default values for generation:

\begin{Verbatim}[commandchars=@\[\]]
url("basic", controller="help") =@textgreater[] "/help/about?weather=sunny"
\end{Verbatim}

With minimization, the same route path would also match shorter URLs such as
``/help'', ``/foo'', and ``/''.  Missing values on the right of the URL would be
taken from the extra variables.  This was intended to lessen the number of
routes you had to write.  In practice it led to obscure application bugs
because sometimes an unexpected route would be matched.  Thus Routes 1.9
introduced non-minimization and recommended ``map.minimization = False'' for
all new applications.

A corollary problem was generating the wrong route.  Routes 1.9 tightened up
the rule for generating named routes.  If a route name is specified in
\code{url()} or \code{url\_for()}, \emph{only} that named route will be chosen.  In
previous versions, it might choose another route based on the keyword args.


\subsection{Implicit defaults and route memory}

Implicit defaults worked with minimization to provide automatic default values
for the ``action'' and ``id'' variables.  If a route was defined as
\code{map.connect("/\{contoller\}/\{action\}/\{id\}") and the URL "/archives"} was
requested, Routes would implicitly add \code{action="index", id=None} to the
routing variables.

To enable implicit defaults, set \code{map.minimization = True; map.explicit =
False}.  You can also enable implicit defaults on a per-route basis by setting
\code{map.explicit = True} and defining each route with a keyword argument \code{explicit=False}.

Previous versions also had implicit default values for ``controller'',
``action'', and ``id''.  These are now disabled by default, but can be enabled via
\code{map.explicit = True}.  This also enables route memory


\subsection{url\_for()}

\code{url\_for} was a route generation function which was replaced by the \code{url}
object.  Usage is the same except that \code{url\_for} uses route memory in some
cases and \code{url} never does.  Route memory is where variables from the current
URL (the current request) are injected into the generated URL.  To use route
memory with \code{url}, call \code{url.current()} passing the variables you want to
override.  Any other variables needed by the route will be taken from the
current routing variables.

In other words, \code{url\_for} combines \code{url} and \code{url.current()} into one
function.  The location of \code{url\_for} is also different.  \code{url\_for} is
properly imported from \code{routes}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGal[from] @PYGaW[routes] @PYGal[import] url@_for
\end{Verbatim}

\code{url\_for} was traditionally imported into WebHelpers, and it's still used in
some tests and in \code{webhelpers.paginate}.  Many old Pylons applications
contain \code{h.url\_for()} based on its traditional importation to helpers.py.
However, its use in new applications is discouraged both because of its
ambiguous syntax and because its implementation depends on an ugly singleton.

The \code{url} object is created by the RoutesMiddleware and inserted into the
WSGI environment.  Pylons makes it available as \code{pylons.url}, and in
templates as \code{url}.


\subsection{redirect\_to()}

This combined \code{url\_for} with a redirect.  Instead, please use your
framework's redirect mechanism with a \code{url} call.  For instance in Pylons:

\begin{Verbatim}[commandchars=@\[\]]
@PYGal[from] @PYGaW[pylons.controllers.util] @PYGal[import] redirect
redirect(url(@PYGaB["]@PYGaB[login]@PYGaB["]))
\end{Verbatim}

\resetcurrentobjects
\hypertarget{--doc-glossary}{}

\hypertarget{glossary}{}\chapter{Glossary}
\begin{description}
\index{component}\item[component]\hypertarget{term-component}{}
A part of a URL delimited by slashes.  The URL ``/help/about'' contains
two components: ``help'' and ``about''.

\index{generation}\item[generation]\hypertarget{term-generation}{}
The act of creating a URL based on a route name and/or variable values.
This is the opposite of matching.  Finding a route by name is called
\emph{named generation}.  Finding a route without specifying a name is
called \emph{nameless generation}.

\index{mapper}\item[mapper]\hypertarget{term-mapper}{}
A container for routes.  There is normally one mapper per application,
although nested subapplications might have their own mappers.  A
mapper knows how to match routes and generate them.

\index{matching}\item[matching]\hypertarget{term-matching}{}
The act of matching a given URL against a list  of routes, and
returning the routing variables.  See the \emph{route} entry for an example.

\index{minimization}\item[minimization]\hypertarget{term-minimization}{}
A deprecated feature which allowed short URLs to match long paths.
Details are in the \code{Backward Compatibility} section in the manual.

\index{route}\item[route]\hypertarget{term-route}{}
A rule mapping a URL pattern to a dict of routing  variables.   For
instance, if the pattern is ``/\{controller\}/\{action\}'' and the requested
URL is ``/help/about'', the resulting dict would be:

\begin{Verbatim}[commandchars=@\[\]]
{@PYGaB["]@PYGaB[controller]@PYGaB["]: @PYGaB["]@PYGaB[help]@PYGaB["], @PYGaB["]@PYGaB[action]@PYGaB["]: @PYGaB["]@PYGaB[about]@PYGaB["]}
\end{Verbatim}

Routes does not know what these variables mean; it simply returns them
to the application.  Pylons would look for a \code{controllers/help.py}
module containing a \code{HelpController} class, and call its \code{about}
method.  Other frameworks may do something different.

A route may have a name, used to identify the route.

\index{route path}\item[route path]\hypertarget{term-route-path}{}
The URL pattern in a route.

\index{routing variables}\item[routing variables]\hypertarget{term-routing-variables}{}
A dict of key-value pairs returned by matching.  Variables defined in
the route path are called \emph{path variables}; their values will be taken
from the URL.  Variables defined outside the route path are called
\emph{default variables}; their values are not affected by the URL.

The WSGI.org environment key for routing variables is
``wsgiorg.routing\_args''.  This manual does not use that term because it
can be confused with function arguments.

\end{description}

\resetcurrentobjects
\hypertarget{--doc-porting}{}

\chapter{Porting Routes to a WSGI Web Framework}


\section{RoutesMiddleware}

An application can create a raw mapper object and call its \code{.match} and
\code{.generate} methods.  However, WSGI applications probably want to use
the \code{RoutesMiddleware} as Pylons does:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaE[@# In myapp/config/middleware.py]
@PYGal[from] @PYGaW[routes.middleware] @PYGal[import] RoutesMiddleware
app @PYGbe[=] RoutesMiddleware(app, @PYGaY[map])     @PYGaE[@# []`[]`map[]`[]` is a routes.Mapper.]
\end{Verbatim}

The middleware matches the requested URL and sets the following WSGI
variables:

\begin{Verbatim}[commandchars=@\[\]]
environ@PYGZlb[]@PYGaB[']@PYGaB[wsgiorg.routing@_args]@PYGaB[']@PYGZrb[] @PYGbe[=] ((url, match))
environ@PYGZlb[]@PYGaB[']@PYGaB[routes.route]@PYGaB[']@PYGZrb[] @PYGbe[=] route
environ@PYGZlb[]@PYGaB[']@PYGaB[routes.url]@PYGaB[']@PYGZrb[] @PYGbe[=] url
\end{Verbatim}

where \code{match} is the routing variables dict, \code{route} is the matched route,
and \code{url} is a \code{URLGenerator} object.  In Pylons, \code{match} is used by the
dispatcher, and \code{url} is accessible as \code{pylons.url}.

The middleware handles redirect routes itself, issuing the appropriate
redirect.  The application is not called in this case.

To debug routes, turn on debug logging for the ``routes.middleware'' logger.

See the Routes source code for other features which may have been added.


\section{URL Resolution}

When the URL is looked up, it should be matched against the Mapper. When
matching an incoming URL, it is assumed that the URL path is the only string
being matched. All query args should be stripped before matching:

\begin{Verbatim}[commandchars=@\[\]]
m@PYGbe[.]connect(@PYGaB[']@PYGaB[articles/{year}/{month}]@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[blog]@PYGaB['], action@PYGbe[=]@PYGaB[']@PYGaB[view]@PYGaB['], year@PYGbe[=]@PYGaA[None])

m@PYGbe[.]match(@PYGaB[']@PYGaB[/articles/2003/10]@PYGaB['])
@PYGaE[@# {'controller':'blog', 'action':'view', 'year':'2003', 'month':'10'}]
\end{Verbatim}

Matching a URL will return a dict of the match results, if you'd like to
differentiate between where the argument came from you can use routematch which
will return the Route object that has all these details:

\begin{Verbatim}[commandchars=@\[\]]
m@PYGbe[.]connect(@PYGaB[']@PYGaB[articles/{year}/{month}]@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[blog]@PYGaB['], action@PYGbe[=]@PYGaB[']@PYGaB[view]@PYGaB['], year@PYGbe[=]@PYGaA[None])

result @PYGbe[=] m@PYGbe[.]routematch(@PYGaB[']@PYGaB[/articles/2003/10]@PYGaB['])
@PYGaE[@# result is a tuple of the match dict and the Route object]

@PYGaE[@# result@PYGZlb[]0@PYGZrb[] - {'controller':'blog', 'action':'view', 'year':'2003', 'month':'10'}]
@PYGaE[@# result@PYGZlb[]1@PYGZrb[] - Route object]
@PYGaE[@# result@PYGZlb[]1@PYGZrb[].defaults - {'controller':'blog', 'action':'view', 'year':None}]
@PYGaE[@# result@PYGZlb[]1@PYGZrb[].hardcoded - @PYGZlb[]'controller', 'action'@PYGZrb[]]
\end{Verbatim}

Your integration code is then expected to dispatch to a controller and action
in the dict. How it does this is entirely up to the framework integrator. Your
integration should also typically provide the web developer a mechanism to
access the additional dict values.


\section{Request Configuration}

If you intend to support \code{url\_for()} and \code{redirect\_to()}, they depend on a
singleton object which requires additional configuration.  You're better off
not supporting them at all because they will be deprecated soon.
\code{URLGenerator} is the forward-compatible successor to \code{url\_for()}.
\code{redirect\_to()} is better done in the web framework{}`as in
\code{pylons.controllers.util.redirect\_to()}.

\code{url\_for()} and \code{redirect\_to()} need information on the current request,
and since they can be called from anywhere they don't have direct access to the
WSGI environment.  To remedy this, Routes provides a thread-safe singleton class
called ``request\_config'', which holds the request information for the current
thread. You should update this after matching the incoming URL but before
executing any code that might call the two functions.  Here is an example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGal[from] @PYGaW[routes] @PYGal[import] request@_config

config @PYGbe[=] request@_config()

config@PYGbe[.]mapper @PYGbe[=] m                  @PYGaE[@# Your mapper object]
config@PYGbe[.]mapper@_dict @PYGbe[=] result        @PYGaE[@# The dict from m.match for this URL request]
config@PYGbe[.]host @PYGbe[=] hostname             @PYGaE[@# The server hostname]
config@PYGbe[.]protocol @PYGbe[=] port             @PYGaE[@# Protocol used, http, https, etc.]
config@PYGbe[.]redirect @PYGbe[=] redir@_func       @PYGaE[@# A redirect function used by your framework, that is]
                                   @PYGaE[@# expected to take as the first non-keyword arg a single]
                                   @PYGaE[@# full or relative URL]
\end{Verbatim}

See the docstring for \code{request\_config} in routes/\_\_init\_\_.py to make sure
you've initialized everything necessary.


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\item {} 
\emph{Search Page}

\item {} 
\hyperlink{glossary}{\emph{Glossary}}

\end{itemize}


\section{Module Listing}

\resetcurrentobjects
\hypertarget{--doc-modules}{}

\subsection{\texttt{routes} -- Routes module}
\index{routes (module)}
\hypertarget{module-routes}{}
\declaremodule[routes]{}{routes}
\modulesynopsis{}
Provides common classes and functions most users will want access to.


\subsubsection{Module Contents}
\index{request\_config() (in module routes)}

\hypertarget{routes.request_config}{}\begin{funcdesc}{request\_config}{original=False}
Returns the Routes RequestConfig object.

To get the Routes RequestConfig:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGal[from] @PYGaW[routes] @PYGal[import] @PYGbe[*]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]config @PYGbe[=] request@_config()
\end{Verbatim}

The following attributes must be set on the config object every request:
\begin{description}
\item[mapper]
mapper should be a Mapper instance thats ready for use

\item[host]
host is the hostname of the webapp

\item[protocol]
protocol is the protocol of the current request

\item[mapper\_dict]
mapper\_dict should be the dict returned by mapper.match()

\item[redirect]
redirect should be a function that issues a redirect, 
and takes a url as the sole argument

\item[prefix (optional)]
Set if the application is moved under a URL prefix. Prefix
will be stripped before matching, and prepended on generation

\item[environ (optional)]
Set to the WSGI environ for automatic prefix support if the
webapp is underneath a `SCRIPT\_NAME'

Setting the environ will use information in environ to try and
populate the host/protocol/mapper\_dict options if you've already
set a mapper.

\end{description}

\textbf{Using your own requst local}

If you have your own request local object that you'd like to use instead 
of the default thread local provided by Routes, you can configure Routes 
to use it:

\begin{Verbatim}[commandchars=@\[\]]
from routes import request@_config()
config = request@_config()
if hasattr(config, 'using@_request@_local'):
    config.request@_local = YourLocalCallable
    config = request@_config()
\end{Verbatim}

Once you have configured request\_config, its advisable you retrieve it 
again to get the object you wanted. The variable you assign to 
request\_local is assumed to be a callable that will get the local config 
object you wish.

This example tests for the presence of the `using\_request\_local' attribute
which will be present if you haven't assigned it yet. This way you can 
avoid repeat assignments of the request specific callable.

Should you want the original object, perhaps to change the callable its 
using or stop this behavior, call request\_config(original=True).
\end{funcdesc}
\index{Mapper (class in routes)}

\hypertarget{routes.Mapper}{}\begin{classdesc}{Mapper}{controller\_scan=\textless{}function controller\_scan at 0x101d88b90\textgreater{}, directory=None, always\_scan=False, register=True, explicit=False}
Mapper handles URL generation and URL recognition in a web
application.

Mapper is built handling dictionary's. It is assumed that the web
application will handle the dictionary returned by URL recognition
to dispatch appropriately.

URL generation is done by passing keyword parameters into the
generate function, a URL is then returned.

Create a new Mapper instance

All keyword arguments are optional.
\begin{description}
\item[\code{controller\_scan}]
Function reference that will be used to return a list of
valid controllers used during URL matching. If
\code{directory} keyword arg is present, it will be passed
into the function during its call. This option defaults to
a function that will scan a directory for controllers.

Alternatively, a list of controllers or None can be passed
in which are assumed to be the definitive list of
controller names valid when matching `controller'.

\item[\code{directory}]
Passed into controller\_scan for the directory to scan. It
should be an absolute path if using the default 
\code{controller\_scan} function.

\item[\code{always\_scan}]
Whether or not the \code{controller\_scan} function should be
run during every URL match. This is typically a good idea
during development so the server won't need to be restarted
anytime a controller is added.

\item[\code{register}]
Boolean used to determine if the Mapper should use 
\code{request\_config} to register itself as the mapper. Since
it's done on a thread-local basis, this is typically best
used during testing though it won't hurt in other cases.

\item[\code{explicit}]
Boolean used to determine if routes should be connected
with implicit defaults of:

\begin{Verbatim}[commandchars=@\[\]]
{@PYGaB[']@PYGaB[controller]@PYGaB[']:@PYGaB[']@PYGaB[content]@PYGaB['],@PYGaB[']@PYGaB[action]@PYGaB[']:@PYGaB[']@PYGaB[index]@PYGaB['],@PYGaB[']@PYGaB[id]@PYGaB[']:@PYGaA[None]}
\end{Verbatim}

When set to True, these defaults will not be added to route
connections and \code{url\_for} will not use Route memory.

\end{description}

Additional attributes that may be set after mapper
initialization (ie, map.ATTRIBUTE = `something'):
\begin{description}
\item[\code{encoding}]
Used to indicate alternative encoding/decoding systems to
use with both incoming URL's, and during Route generation
when passed a Unicode string. Defaults to `utf-8'.

\item[\code{decode\_errors}]
How to handle errors in the encoding, generally ignoring
any chars that don't convert should be sufficient. Defaults
to `ignore'.

\item[\code{minimization}]
Boolean used to indicate whether or not Routes should
minimize URL's and the generated URL's, or require every
part where it appears in the path. Defaults to True.

\item[\code{hardcode\_names}]
Whether or not Named Routes result in the default options
for the route being used \emph{or} if they actually force url
generation to use the route. Defaults to False.

\end{description}
\index{connect() (routes.Mapper method)}

\hypertarget{routes.Mapper.connect}{}\begin{methoddesc}{connect}{*args, **kargs}
Create and connect a new Route to the Mapper.

Usage:

\begin{Verbatim}[commandchars=@\[\]]
m @PYGbe[=] Mapper()
m@PYGbe[.]connect(@PYGaB[']@PYGaB[:controller/:action/:id]@PYGaB['])
m@PYGbe[.]connect(@PYGaB[']@PYGaB[date/:year/:month/:day]@PYGaB['], controller@PYGbe[=]@PYGaB["]@PYGaB[blog]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[view]@PYGaB["])
m@PYGbe[.]connect(@PYGaB[']@PYGaB[archives/:page]@PYGaB['], controller@PYGbe[=]@PYGaB["]@PYGaB[blog]@PYGaB["], action@PYGbe[=]@PYGaB["]@PYGaB[by@_page]@PYGaB["],
requirements @PYGbe[=] { @PYGaB[']@PYGaB[page]@PYGaB[']:@PYGaB[']@PYGaB[\]@PYGaB[d{1,2}]@PYGaB['] })
m@PYGbe[.]connect(@PYGaB[']@PYGaB[category@_list]@PYGaB['], @PYGaB[']@PYGaB[archives/category/:section]@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[blog]@PYGaB['], action@PYGbe[=]@PYGaB[']@PYGaB[category]@PYGaB['],
section@PYGbe[=]@PYGaB[']@PYGaB[home]@PYGaB['], @PYGaY[type]@PYGbe[=]@PYGaB[']@PYGaB[list]@PYGaB['])
m@PYGbe[.]connect(@PYGaB[']@PYGaB[home]@PYGaB['], @PYGaB[']@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[blog]@PYGaB['], action@PYGbe[=]@PYGaB[']@PYGaB[view]@PYGaB['], section@PYGbe[=]@PYGaB[']@PYGaB[home]@PYGaB['])
\end{Verbatim}
\end{methoddesc}
\index{create\_regs() (routes.Mapper method)}

\hypertarget{routes.Mapper.create_regs}{}\begin{methoddesc}{create\_regs}{*args, **kwargs}
Atomically creates regular expressions for all connected
routes
\end{methoddesc}
\index{generate() (routes.Mapper method)}

\hypertarget{routes.Mapper.generate}{}\begin{methoddesc}{generate}{*args, **kargs}
Generate a route from a set of keywords

Returns the url text, or None if no URL could be generated.

\begin{Verbatim}[commandchars=@\[\]]
m@PYGbe[.]generate(controller@PYGbe[=]@PYGaB[']@PYGaB[content]@PYGaB['],action@PYGbe[=]@PYGaB[']@PYGaB[view]@PYGaB['],@PYGaY[id]@PYGbe[=]@PYGaw[10])
\end{Verbatim}
\end{methoddesc}
\index{match() (routes.Mapper method)}

\hypertarget{routes.Mapper.match}{}\begin{methoddesc}{match}{url}
Match a URL against against one of the routes contained.

Will return None if no valid match is found.

\begin{Verbatim}[commandchars=@\[\]]
resultdict @PYGbe[=] m@PYGbe[.]match(@PYGaB[']@PYGaB[/joe/sixpack]@PYGaB['])
\end{Verbatim}
\end{methoddesc}
\index{redirect() (routes.Mapper method)}

\hypertarget{routes.Mapper.redirect}{}\begin{methoddesc}{redirect}{match\_path, destination\_path, *args, **kwargs}
Add a redirect route to the mapper

Redirect routes bypass the wrapped WSGI application and instead
result in a redirect being issued by the RoutesMiddleware. As
such, this method is only meaningful when using
RoutesMiddleware.

By default, a 302 Found status code is used, this can be
changed by providing a \code{\_redirect\_code} keyword argument
which will then be used instead. Note that the entire status
code string needs to be present.

When using keyword arguments, all arguments that apply to
matching will be used for the match, while generation specific
options will be used during generation. Thus all options
normally available to connected Routes may be used with
redirect routes as well.

Example:

\begin{Verbatim}[commandchars=@\[\]]
map = Mapper()
map.redirect('/legacyapp/archives/{url:.*}, '/archives/{url})
map.redirect('/home/index', '/', @_redirect@_code='301 Moved Permanently')
\end{Verbatim}
\end{methoddesc}
\index{resource() (routes.Mapper method)}

\hypertarget{routes.Mapper.resource}{}\begin{methoddesc}{resource}{member\_name, collection\_name, **kwargs}
Generate routes for a controller resource

The member\_name name should be the appropriate singular version
of the resource given your locale and used with members of the
collection. The collection\_name name will be used to refer to
the resource collection methods and should be a plural version
of the member\_name argument. By default, the member\_name name
will also be assumed to map to a controller you create.

The concept of a web resource maps somewhat directly to `CRUD' 
operations. The overlying things to keep in mind is that
mapping a resource is about handling creating, viewing, and
editing that resource.

All keyword arguments are optional.
\begin{description}
\item[\code{controller}]
If specified in the keyword args, the controller will be
the actual controller used, but the rest of the naming
conventions used for the route names and URL paths are
unchanged.

\item[\code{collection}]
Additional action mappings used to manipulate/view the
entire set of resources provided by the controller.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB[']@PYGaB[message]@PYGaB['], @PYGaB[']@PYGaB[messages]@PYGaB['], collection@PYGbe[=]{@PYGaB[']@PYGaB[rss]@PYGaB[']:@PYGaB[']@PYGaB[GET]@PYGaB[']})
@PYGaE[@# GET /message/rss (maps to the rss action)]
@PYGaE[@# also adds named route "rss@_message"]
\end{Verbatim}

\item[\code{member}]
Additional action mappings used to access an individual
`member' of this controllers resources.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB[']@PYGaB[message]@PYGaB['], @PYGaB[']@PYGaB[messages]@PYGaB['], member@PYGbe[=]{@PYGaB[']@PYGaB[mark]@PYGaB[']:@PYGaB[']@PYGaB[POST]@PYGaB[']})
@PYGaE[@# POST /message/1/mark (maps to the mark action)]
@PYGaE[@# also adds named route "mark@_message"]
\end{Verbatim}

\item[\code{new}]
Action mappings that involve dealing with a new member in
the controller resources.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB[']@PYGaB[message]@PYGaB['], @PYGaB[']@PYGaB[messages]@PYGaB['], new@PYGbe[=]{@PYGaB[']@PYGaB[preview]@PYGaB[']:@PYGaB[']@PYGaB[POST]@PYGaB[']})
@PYGaE[@# POST /message/new/preview (maps to the preview action)]
@PYGaE[@# also adds a url named "preview@_new@_message"]
\end{Verbatim}

\item[\code{path\_prefix}]
Prepends the URL path for the Route with the path\_prefix
given. This is most useful for cases where you want to mix
resources or relations between resources.

\item[\code{name\_prefix}]
Perpends the route names that are generated with the
name\_prefix given. Combined with the path\_prefix option,
it's easy to generate route names and paths that represent
resources that are in relations.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]resource(@PYGaB[']@PYGaB[message]@PYGaB['], @PYGaB[']@PYGaB[messages]@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[categories]@PYGaB['], 
    path@_prefix@PYGbe[=]@PYGaB[']@PYGaB[/category/:category@_id]@PYGaB['], 
    name@_prefix@PYGbe[=]@PYGaB["]@PYGaB[category@_]@PYGaB["])
@PYGaE[@# GET /category/7/message/1]
@PYGaE[@# has named route "category@_message"]
\end{Verbatim}

\item[\code{parent\_resource} ]
A \code{dict} containing information about the parent
resource, for creating a nested resource. It should contain
the \code{member\_name} and \code{collection\_name} of the parent
resource. This \code{dict} will 
be available via the associated \code{Route} object which can
be accessed during a request via
\code{request.environ{[}'routes.route'{]}}

If \code{parent\_resource} is supplied and \code{path\_prefix}
isn't, \code{path\_prefix} will be generated from
\code{parent\_resource} as
``\textless{}parent collection name\textgreater{}/:\textless{}parent member name\textgreater{}\_id''.

If \code{parent\_resource} is supplied and \code{name\_prefix}
isn't, \code{name\_prefix} will be generated from
\code{parent\_resource} as  ``\textless{}parent member name\textgreater{}\_''.

Example:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGal[from] @PYGaW[routes.util] @PYGal[import] url@_for 
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper() 
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['], 
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['], 
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']))
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# path@_prefix is "regions/:region@_id" ]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# name prefix is "region@_"  ]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[region@_locations]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13]) 
@PYGaa['/regions/13/locations']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[region@_new@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13]) 
@PYGaa['/regions/13/locations/new']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[region@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13], @PYGaY[id]@PYGbe[=]@PYGaw[60]) 
@PYGaa['/regions/13/locations/60']
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[region@_edit@_location]@PYGaB['], region@_id@PYGbe[=]@PYGaw[13], @PYGaY[id]@PYGbe[=]@PYGaw[60]) 
@PYGaa['/regions/13/locations/60/edit']
\end{Verbatim}

Overriding generated \code{path\_prefix}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper()
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['],
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['],
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']),
@PYGaQ[... ]           path@_prefix@PYGbe[=]@PYGaB[']@PYGaB[areas/:area@_id]@PYGaB['])
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# name prefix is "region@_"]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[region@_locations]@PYGaB['], area@_id@PYGbe[=]@PYGaw[51])
@PYGaa['/areas/51/locations']
\end{Verbatim}

Overriding generated \code{name\_prefix}:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m @PYGbe[=] Mapper()
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]m@PYGbe[.]resource(@PYGaB[']@PYGaB[location]@PYGaB['], @PYGaB[']@PYGaB[locations]@PYGaB['],
@PYGaQ[... ]           parent@_resource@PYGbe[=]@PYGaY[dict](member@_name@PYGbe[=]@PYGaB[']@PYGaB[region]@PYGaB['],
@PYGaQ[... ]                                collection@_name@PYGbe[=]@PYGaB[']@PYGaB[regions]@PYGaB[']),
@PYGaQ[... ]           name@_prefix@PYGbe[=]@PYGaB[']@PYGaB['])
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]@PYGaE[@# path@_prefix is "regions/:region@_id" ]
@PYGaQ[@textgreater[]@textgreater[]@textgreater[] ]url@_for(@PYGaB[']@PYGaB[locations]@PYGaB['], region@_id@PYGbe[=]@PYGaw[51])
@PYGaa['/regions/51/locations']
\end{Verbatim}

\end{description}
\end{methoddesc}
\index{routematch() (routes.Mapper method)}

\hypertarget{routes.Mapper.routematch}{}\begin{methoddesc}{routematch}{url}
Match a URL against against one of the routes contained.

Will return None if no valid match is found, otherwise a
result dict and a route object is returned.

\begin{Verbatim}[commandchars=@\[\]]
resultdict, route@_obj @PYGbe[=] m@PYGbe[.]match(@PYGaB[']@PYGaB[/joe/sixpack]@PYGaB['])
\end{Verbatim}
\end{methoddesc}
\end{classdesc}
\index{URLGenerator (class in routes)}

\hypertarget{routes.URLGenerator}{}\begin{classdesc}{URLGenerator}{mapper, environ}
The URL Generator generates URL's

It is automatically instantiated by the RoutesMiddleware and put
into the \code{wsgiorg.routing\_args} tuple accessible as:

\begin{Verbatim}[commandchars=@\[\]]
url @PYGbe[=] environ@PYGZlb[]@PYGaB[']@PYGaB[wsgiorg.routing@_args]@PYGaB[']@PYGZrb[]@PYGZlb[]@PYGaw[0]@PYGZrb[]@PYGZlb[]@PYGaw[0]@PYGZrb[]
\end{Verbatim}

Or via the \code{routes.url} key:

\begin{Verbatim}[commandchars=@\[\]]
url @PYGbe[=] environ@PYGZlb[]@PYGaB[']@PYGaB[routes.url]@PYGaB[']@PYGZrb[]
\end{Verbatim}

The url object may be instantiated outside of a web context for use
in testing, however sub\_domain support and fully qualified URL's
cannot be generated without supplying a dict that must contain the
key \code{HTTP\_HOST}.

Instantiate the URLGenerator
\begin{description}
\item[\code{mapper}]
The mapper object to use when generating routes.

\item[\code{environ}]
The environment dict used in WSGI, alternately, any dict
that contains at least an \code{HTTP\_HOST} value.

\end{description}
\end{classdesc}
\index{url\_for() (in module routes)}

\hypertarget{routes.url_for}{}\begin{funcdesc}{url\_for}{*args, **kargs}
Generates a URL

All keys given to url\_for are sent to the Routes Mapper instance for 
generation except for:

\begin{Verbatim}[commandchars=@\[\]]
anchor          specified the anchor name to be appened to the path
host            overrides the default (current) host if provided
protocol        overrides the default (current) protocol if provided
qualified       creates the URL with the host/port information as 
                needed
\end{Verbatim}

The URL is generated based on the rest of the keys. When generating a new 
URL, values will be used from the current request's parameters (if 
present). The following rules are used to determine when and how to keep 
the current requests parameters:
\begin{itemize}
\item {} 
If the controller is present and begins with `/', no defaults are used

\item {} 
If the controller is changed, action is set to `index' unless otherwise 
specified

\end{itemize}

For example, if the current request yielded a dict of
\{`controller': `blog', `action': `view', `id': 2\}, with the standard 
`:controller/:action/:id' route, you'd get the following results:

\begin{Verbatim}[commandchars=@\[\]]
url@_for(id=4)                    =@textgreater[]  '/blog/view/4',
url@_for(controller='/admin')     =@textgreater[]  '/admin',
url@_for(controller='admin')      =@textgreater[]  '/admin/view/2'
url@_for(action='edit')           =@textgreater[]  '/blog/edit/2',
url@_for(action='list', id=None)  =@textgreater[]  '/blog/list'
\end{Verbatim}

\textbf{Static and Named Routes}

If there is a string present as the first argument, a lookup is done 
against the named routes table to see if there's any matching routes. The
keyword defaults used with static routes will be sent in as GET query 
arg's if a route matches.

If no route by that name is found, the string is assumed to be a raw URL. 
Should the raw URL begin with \code{/} then appropriate SCRIPT\_NAME data will
be added if present, otherwise the string will be used as the url with 
keyword args becoming GET query args.
\end{funcdesc}
\index{redirect\_to() (in module routes)}

\hypertarget{routes.redirect_to}{}\begin{funcdesc}{redirect\_to}{*args, **kargs}
Issues a redirect based on the arguments.

Redirect's \emph{should} occur as a ``302 Moved'' header, however the web 
framework may utilize a different method.

All arguments are passed to url\_for to retrieve the appropriate URL, then
the resulting URL it sent to the redirect function as the URL.
\end{funcdesc}
\index{strip\_slashes() (in module routes.mapper)}

\hypertarget{routes.mapper.strip_slashes}{}\begin{funcdesc}{strip\_slashes}{name}
Remove slashes from the beginning and end of a part/URL.
\end{funcdesc}
\index{RoutesMiddleware (class in routes.middleware)}

\hypertarget{routes.middleware.RoutesMiddleware}{}\begin{classdesc}{RoutesMiddleware}{wsgi\_app, mapper, use\_method\_override=True, path\_info=True}
Routing middleware that handles resolving the PATH\_INFO in
addition to optionally recognizing method overriding.

Create a Route middleware object

Using the use\_method\_override keyword will require Paste to be
installed, and your application should use Paste's WSGIRequest
object as it will properly handle POST issues with wsgi.input
should Routes check it.

If path\_info is True, then should a route var contain
path\_info, the SCRIPT\_NAME and PATH\_INFO will be altered
accordingly. This should be used with routes like:

\begin{Verbatim}[commandchars=@\[\]]
@PYGaY[map]@PYGbe[.]connect(@PYGaB[']@PYGaB[blog/*path@_info]@PYGaB['], controller@PYGbe[=]@PYGaB[']@PYGaB[blog]@PYGaB['], path@_info@PYGbe[=]@PYGaB[']@PYGaB['])
\end{Verbatim}
\end{classdesc}


\renewcommand{\indexname}{Module Index}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
