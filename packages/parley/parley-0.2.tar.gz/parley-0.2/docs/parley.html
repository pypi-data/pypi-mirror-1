<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>parley</title>
<link rel="stylesheet" type="text/css" href="default.css">
</head>
<body>
<h1>Package parley</h1>
<h2>Modules</h2>
<div class="submodule">
<code><b><a href="parley.controllers.html">parley.controllers</a></b></code><blockquote></blockquote>
</div>
<div class="submodule">
<code><b><a href="parley.controller.html">parley.controller</a></b></code><blockquote></blockquote>
</div>
<div class="submodule">
<code><b><a href="parley.proxy.html">parley.proxy</a></b></code><blockquote><pre>parley/proxy.py - reference and communice with spawned actors.</pre></blockquote>
</div>
<div class="submodule">
<code><b><a href="parley.helpers.html">parley.helpers</a></b></code><blockquote><pre>parley/helpers.py - helper classes and functions for constructing actors.</pre></blockquote>
</div>
<div class="submodule">
<code><b><a href="parley.actor.html">parley.actor</a></b></code><blockquote></blockquote>
</div>
<h2>Classes</h2>
<a name="RPCException"><div class="class">
<code><b>class RPCException</b>(<a href="exceptions.html#Exception">exceptions.Exception</a>):</code><blockquote><pre>Indicates a generic failure during an RPC call.</pre></blockquote>
</div></a><a name="RemoteException"><div class="class">
<code><b>class RemoteException</b>(<a href="parley.html#RPCException">parley.RPCException</a>):</code><blockquote><pre>This exception indicates that the remote actor responded to a
message by sending an exception.</pre></blockquote>
</div></a><a name="StopActor"><div class="class">
<code><b>class StopActor</b>(<a href="exceptions.html#Exception">exceptions.Exception</a>):</code><blockquote><pre>Raise this exception to cause an actor to terminate normally.</pre></blockquote>
</div></a><h2>Functions</h2>
<div class="function">
<code><b>def link(</b>target<b>):</b></code><blockquote><pre>Create a bidirectional link to the target actor.

If one linked actor terminates abnormally, the other will
raise an AbnormalExit exception upon its next call to recv().
Similarly, if one actor terminates normally, a quit message
will be sent to the other.</pre></blockquote>
</div>
<div class="function">
<code><b>def lookup(</b>name<b>):</b></code><blockquote><pre>Return the actor proxy associated with the given name.

Raises NoSuchActor if the name has not been registered.</pre></blockquote>
</div>
<div class="function">
<code><b>def me(</b><b>):</b></code><blockquote><pre>Return a proxy object for the currently running actor.</pre></blockquote>
</div>
<div class="function">
<code><b>def recv(</b>msg_filter=None<b>):</b></code><blockquote><pre>Return a waiting message for the current actor, or block
(allowing other threads to continue) until a message is available.

The optional msg_filter argument should accept a message as
an argument and return True or False to determine whether to
return the message or leave it for later.

If any actor linked to the current actor terminates abnormally, this
method will raise AbnormalExit instead of returning.</pre></blockquote>
</div>
<div class="function">
<code><b>def recv_nowait(</b>msg_filter=None<b>):</b></code><blockquote><pre>Like recv, but returns None instead of blocking if no message is
available.

In the future, arbitrary timeouts will likely be supported.</pre></blockquote>
</div>
<div class="function">
<code><b>def register(</b>target, name<b>):</b></code><blockquote><pre>Register the target actor proxy as being
available under the given name.</pre></blockquote>
</div>
<div class="function">
<code><b>def register_controller(</b>controller<b>):</b></code><blockquote><pre>Register a given actor controller object as the global actor controller.

Normally, you will call start_tasklet_controller or
start_thread_controller instead of this function; this function
exists for those implementing some sort of alternative actor
initialization scheme.</pre></blockquote>
</div>
<div class="function">
<code><b>def schedule(</b><b>):</b></code><blockquote><pre>Allow another thread the chance to run. In an execution model
that is already preemptive, this is a noop.</pre></blockquote>
</div>
<div class="function">
<code><b>def set_name(</b>name<b>):</b></code><blockquote><pre>Set the internal name of the current actor.

This is not any sort of globally reachable ID; this name is just
to identify the actor for debugging purposes (e.g. if trace_on()
has been called).</pre></blockquote>
</div>
<div class="function">
<code><b>def spawn(</b>actor, *args, **kwargs<b>):</b></code><blockquote><pre>Spawn a new actor in a new thread of execution.

This function returns an ActorProxy object that can be used to
reference the spawned actor and communicate with it.

As with the built-in "apply" function, the first argument can be
any callable object, and remaining arguments are forwarded to that
function.</pre></blockquote>
</div>
<div class="function">
<code><b>def spawn_link(</b>actor, *args, **kwargs<b>):</b></code><blockquote><pre>Spawn a new actor and link the current actor to it.

Equivalent to:
  a=spawn(...)
  link(a)
but executed atomically: i.e., the spawned actor will not be started
until it has been linked to the calling actor.</pre></blockquote>
</div>
<div class="function">
<code><b>def start_tasklet_controller(</b>entry_point, *args, **kwargs<b>):</b></code><blockquote><pre>Start the tasklet controller and spawn the actor given by entry_point
(forwarding args and kwargs to entry_point).</pre></blockquote>
</div>
<div class="function">
<code><b>def start_thread_controller(</b>entry_point, *args, **kwargs<b>):</b></code><blockquote><pre>Start the thread controller and spawn the actor given by entry_point
(forwarding args and kwargs to entry_point).</pre></blockquote>
</div>
<div class="function">
<code><b>def trace_off(</b><b>):</b></code><blockquote><pre>Stop the tracing of sent messages.</pre></blockquote>
</div>
<div class="function">
<code><b>def trace_on(</b>out_file=&lt;open file '&lt;stdout&gt;', mode 'w'&gt;<b>):</b></code><blockquote><pre>Cause sent messages to be printed to the specified file.

If no file is specified, stdout is used.</pre></blockquote>
</div>
<div class="function">
<code><b>def unlink(</b>target<b>):</b></code><blockquote><pre>Cancel the bidirectional link to the target actor.</pre></blockquote>
</div>
<div class="function">
<code><b>def unregister(</b>name<b>):</b></code><blockquote><pre>Unregister the actor proxy associated with the given name.</pre></blockquote>
</div>
</body>
</html>
