<!-- generated by hnb 1.9.17 (http://hnb.sourceforge.net) -->
<tree>
	<node done="yes" type="todo">
		<data>
			Introduction 
		</data>
		<node done="yes" type="todo">
			<data>
				Welcome 
			</data>
			<node>
				<data>
					Welcome to the Kupu book! This book has been written by one of the authors of Kupu, Guido Wesdorp, to give you an insight in the Kupu WYSIWYG editor. I hope you will find this book useful, if you have complaints or comments please email me at guido@infrae.com. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				Who is this book for? 
			</data>
			<node>
				<data>
					This book contains background information, a usage manual and in-depth documentation about Kupu. It's main target audience is JavaScript developers and server-side integrators, so for the largest part of the book at least basic knowledge of the JavaScript programming language as well as some HTTP and server-side programming knowledge are required. Small parts, however, contain end-user information (how to use Kupu rather then how to integrate or hack it) and will not imply knowledge of any programming language. 
				</data>
			</node>
			<node>
				<data>
					If you just want to use Kupu on some website, you can safely ignore everything except the chapter 'Using Kupu'. Integrators and developer will probably want to skip 'Using Kupu' and integrators will probably not care much for the chapter about extending Kupu. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				What is Kupu? 
			</data>
			<node>
				<data>
					Kupu is a WYSIWYG (What You See Is What You Get) editor, written in JavaScript. WYSIWYG editors allow you to edit text visually rather then adding markup like HTML or LaTeX. Typical examples of WYSIWYG editors can be found in the Webdesign world, like Macromedia's DreamWeaver or Microsoft's FrontPage. WYSIWYG editing is much like editing in a rich-text editor like Word or OpenOffice: there is a typing area in which you can select text and press buttons to apply layout and design. 
				</data>
			</node>
			<node>
				<data>
					Kupu provides an interface very similar to the WYSIWYG editors mentioned above, but instead of running stand-alone on a desktop computer it is resided inside a web page. This way web site developers can offer authors on their web system a full fledged WYSIWYG editor to edit content, regardless of platform or location (of course the machine should support IE or Mozilla). Instead of having to learn a 'language' like HTML or some form of XML to edit web content, they can just use their mouse to add layout and design to their page, which to most average website content providers makes a huge difference. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				History 
			</data>
			<node done="yes" type="todo">
				<data>
					Infrae 
				</data>
				<node>
					<data>
						A company called 'Infrae' in Rotterdam, the Netherlands was looking for a WYSIWYG editor for their Content Management System (CMS) 'Silva'. One of the main requirements for this editor was that it would work on both Internet Explorer and Mozilla based browsers. After they had tried a couple of proprietary solutions, some JavaScript and some Java based, and found that none of them were satisfactory, they stumbled on a product called 'Epoz', a Zope specific product written by Maik Jablonski. Epoz did not have all the features they had in mind, but it had a usable open-source license (ZPL, the Zope Public License), was written completely in JavaScript (which meant that Infrae could develop the features themselves) and worked on both Mozilla and Internet Explorer. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					Maik Jablonski 
				</data>
				<node>
					<data>
						So off they went to Maik, to ask him whether he was interested in teaming up, which unfortunately he wasn't. He felt the tool did what he wanted it to do and wasn't interested in developing it further. After some chats it was agreed that Infrae would continue development and they could use the name Epoz, since Maik wouldn't use it anymore anyway. Infrae decided to call in another developer, Paul Everitt, well-known in the Zope world for his knowledge on XML and standards and a die-hard Zopista. Together with Guido Wesdorp from Infrae he dove into the project and a couple of months later 'Epoz NG' (rewritten from scratch) was born. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					Starting the project... 
				</data>
				<node>
					<data>
						Of course all beginning is hard, and not everything went as smoothly as planned. The first release was usable, but barely, and not really feature complete. After receiving some emails from old customers and having tried and failed to replace Epoz 'OG' with the new version, Maik decided to continue bugfixing his own version, in effect forking the project. Of course the 'NG' team kept on working on their own version, and the two teams sort of got in their way. By that time the 'NG' team was asked to join the OSCOM (Open Source COntent Management) association, an organization that spends a lot of time and effort in promoting and helping open-source CMS'ses, as an 'umbrella' project, which they were definitely interested in. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					OSCOM 
				</data>
				<node>
					<data>
						OSCOM now provides the website and one of the mailing list, and the 'NG' team decided to change the name to 'Kupu' to make the Epoz situation less messy. Also they changed the license from ZPL (which is very Zopish, and 'NG' by then didn't depend on Zope at all anymore) to a BSD-style and started using one of OSCOM's mailing lists, editors@oscom.org, in addition to the old codespeak.net lists (see appendices). 
					</data>
				</node>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				Why a book? 
			</data>
			<node>
				<data>
					Kupu is getting more and more stable and mature. It's still 'in development' but knowing the people who work on it and the nature of the web it probably always will, and compared to the first release (1.0, Kupu followed a somewhat strange release numbering path) it's a nice API to build on and use, some parts even without Kupu. 
				</data>
			</node>
			<node>
				<data>
					With this book I hope to give people a better understanding of how Kupu works and how to use the seperate components. Also I want to provide a complete reference about how to use, integrate and hack Kupu, thereby hopefully making it easier to deploy the application or contribute to the project. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				About the authors 
			</data>
			<node done="yes" type="todo">
				<data>
					Authors 
				</data>
				<node>
					<data>
						Kupu is based on Epoz, which was written by Maik Jablonski. However, the amount of code left from the original product is little or none. It was rewritten by Paul Everitt and Guido Wesdorp, with additional code (mainly Python integration code, although he's doing more and more JavaScript nowadays) from Philipp von Weitershausen. Of course, Kupu is an Open Source project so it contains code from numerous other developers and the list of contributers is growing, for a complete list see the CREDITS.txt file in the release package. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					Paul Everitt 
				</data>
				<node>
					<data>
						Paul Everitt stood by at the birth of Zope and was one of the heads at Zope Corporation for a while and currently works on his own non-profit project called the 'Zope Europe Association' (http://www.zope-europe.org). He's done a lot of the dirty ground work and is to blame for stuff like 'document-centricness' (emphasis on PUT instead of forms) and removal of all the string processing (document.write) that was originally in Kupu. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					Guido Wesdorp 
				</data>
				<node done="no" type="todo">
					<data>
						Guido Wesdorp works at Infrae, the company that requested initial development. Usually he does Python and Zope development, but since he did some JavaScript work in one of his previous jobs he thought hacking Kupu would make a nice change. He's been responsible for most of Kupu's architecture and wrote the majority of the code. 
					</data>
				</node>
			</node>
			<node done="yes" type="todo">
				<data>
					Philipp von Weitershausen 
				</data>
				<node done="yes" type="todo">
					<data>
						Even though he claims he's really a physics student Philipp is one of the major contributors and spokes people for Zope 3. He doesn't have much JavaScript experience, but has been with Kupu since quite some time to help with releases and administrative work, and has been spotted checking quite some changes in concerning the new drawers. And on top of that he manages to run his own company, called 'philikon Valley', where he does Python, Zope, PHP and sometimes even Java hacking... 
					</data>
				</node>
			</node>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Installing Kupu 
		</data>
		<node done="yes" type="todo">
			<data>
				Introduction 
			</data>
			<node>
				<data>
					This chapter describes how to install Kupu on your machine. It assumes you're using an unmodified release or nightly build tarball or Subversion checkout. Customization can be applied afterwards. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				Downloading and installing 
			</data>
			<node>
				<data>
					Installing can be as easy as unpacking a tarball into a directory. Get the latest release tarball, 'cd' to the location where you want to install Kupu and run 'tar -zxvf Kupu-&lt;version&gt;.tar.gz' where &lt;version&gt; is your version number. Release versions should include all required templates, so after you're done you can use your browser to go to 'common/kupu.html', either directly from the filesystem or via a webserver such as Apache or IIS. 
				</data>
			</node>
			<node>
				<data>
					Of course you can run the product stand-alone, but you will not be able to save, since that requires some server-side logic. Out-of-the-box, Kupu is set up to use PUT to write to the server. If your server supports WebDAV, setting up Kupu is quite easy: you will have to change the 'src' attribute on the iframe in kupu.html so it points to the resource URI where Kupu can GET the data from (the raw data of the HTML file) and the 'dst' in the configuration XML, also in kupu.html, to point to the resource URI where Kupu can PUT the data to. 
				</data>
			</node>
			<node>
				<data>
					If your server does not support WebDAV, don't worry, you can just as easily set up Kupu to use PUT. Instead of 'kupu.html', use the 'kupuform.html' file and change the 'src' attribute on the iframe so it points to your HTML file and the action on the form so it points to the script that processes the form. The script will receive the full contents of the iframe (including &lt;html&gt;, &lt;head&gt; and &lt;body&gt; tags) as the value of a variable called 'kupu'. 
				</data>
			</node>
			<node>
				<data>
					Basically that's it, you now have Kupu working on your webserver, loading data from some URL and saving it to some other. Of course adding some dynamic elements will make it a lot more useful, especially the 'src' attribute and 'dst' config vars aren't very useful when kept static. However, Kupu will run on just about any webserver and therefore it's impossible to get into detail here, for information about how to add dynamical elements to your system, refer to the documentation of your webserver or server-side language. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				What's in the package? 
			</data>
			<node done="no">
				<data>
					When you untar the tarball, you will find a number of directories and files. The most important of the directories is the one called 'common', this contains everything required to run a stand-alone version of Kupu. Most of the files are JavaScripts (you will find quite a bunch of those) and there are some CSS files, some directories with images or XML files and some HTML files (remember that in case you grabbed a Subversion checkout you will have to build the templates yourself). 
				</data>
			</node>
			<node done="no">
				<data>
					The 'driving force' is the file called 'kupueditor.js'. This file contains the KupuDocument class, which 'wraps' the iframe containing the content and provides some low-level functionality to edit its contents, and the KupuEditor class that glues the document and all other components together and provides the main API. This API includes functionality to edit the contents: the KupuDocument object should *never* be used directly since the KupuEditor keeps track of some state for IE's selection and such. Much more in-depth information about the API provided by these objects and the behaviour they exhibit can be found further on in this book. 
				</data>
			</node>
			<node done="no">
				<data>
					The 'kupuinit.js' and 'kupustart.js', files contain the initialization code for Kupu. Both contain a single function, startKupu() in kupustart.js takes care of initializing external functionality (such as the source edit and 'save on part' features of Kupu, both are handled from code outside of the Kupu framework) and initKupu() in kupuinit.js handles instantiation of the KupuDocument and KupuEditor objects and registration of tools and filters. If you're going to do larger customizations you will have to edit these files, configuring Kupu currently still means editing JavaScript (hopefully we can use XML for the 'bootstrapping' process in the future). 
				</data>
			</node>
			<node done="no">
				<data>
					The 'kupubasetools.js' file contains the tools and toolboxes. It has two base classes called 'KupuTool' and 'KupuToolBox' that define the interface for the tools and toolboxes. Tools are essentially plugins for Kupu, they provide additional functionality and can be plugged in from external files (note that they should get registered in initKupu(), so if you write external tools you will also have to provide an external initKupu() function). Toolboxes are the UI elements ('views') for more complicated tools. There's an additional tool implementation in the 'kupuinspector.js' file, a generic tool to set properties and styles on elements, which you may want to check out too. 
				</data>
			</node>
			<node done="no">
				<data>
					The file 'kupuhelpers.js' contains helper functions and classes. The most important of those classes are probably the Selection ones, currently there's one for IE and one for Mozilla, that provide a high-level API for handling the cursor and selection. Also there are a couple of functions for common actions such as registering an event handler, opening a popup, selecting an item from a select box and iterating a DOM node. If you're going to write Kupu code, make sure you know what this module contains, since it has some really useful stuff and it would be a pity to find yourself re-inventing the wheel. 
				</data>
			</node>
			<node done="no">
				<data>
					The 'kupudrawers.js' contains the Kupu drawers, a special kind of toolbox that provides a pop-up like user interface (currently only in use in the 'experimental' distribution and in the Plone one). Drawers are quite plain toolboxes: they use existing tools for their functionality and usually replace a toolbox in the sidebar. The idea of drawers is that they can provide toolbox functionality in a page where there's not enough 'real-estate' to add a set of plain toolboxes. Next to the base class and implementations of the simple toolbox replacement drawers you will also find the KupuLibraryDrawer baseclass and some implementations of it, which uses XSLT to generate the drawer contents from XML retrieved from the server. There's a small chapter dedicated to those drawers further on in this book. 
				</data>
			</node>
			<node done="no">
				<data>
					The other Kupu components can be found in 'kupucontentfilters.js', which contains a class that filters non-XHTML tags from the Kupu content before saving, 'kupuloggers.js', containing a set of logging object where you can choose from, and 'kupucontextmenu.js', which provides the context menu. More information about the classes in these files later on in the book. 
				</data>
			</node>
			<node done="no">
				<data>
					Last there's a couple of files that contain 'external' functionality, in other words that contain additional Kupu functionality outside of the framework. The 'kupusaveonpart.js' file contains a piece of code that asks whether the client wants to save the contents before leaving the editor (and saves it if he or she confirms) and the 'kupusourceedit.js' file contains some code to make the contents of the iframe get saved to a textarea on demand so it can be edited as raw HTML and to send it back to the iframe. 
				</data>
			</node>
		</node>
		<node done="yes" type="todo">
			<data>
				Building the macros 
			</data>
			<node>
				<data>
					This section contains information about how to build templates using the templating system, which is only required if you use a Subversion checkout. If you use a release or nightly build, the templates will all be in the package. 
				</data>
			</node>
			<node>
				<data>
					When you grabbed a Kupu Subversion checkout, it will *not* contain any HTML files or templates. To ease the burden of maintenance a bit, the Kupu developers wrote a templating system that generates templates from chunks of HTML. To build a template, you will have to have an XSLT processor installed. To simplify the build process, a 'make' script (Makefile) for UNIX and a batch file for Windows are supplied. These imply you have installed 'xsltproc' as an XSLT processor (and have it available in your PATH). 
				</data>
			</node>
			<node>
				<data>
					To view the possible targets, view the 'Makefile' and 'make.bat' scripts in the root of the Kupu package. This file will also provide some documentation if you want to use a different XSLT processor. Basic usage on a UNIX system with xsltproc and (GNU?) make installed as well as on Windows machines is just to call 'make' or 'make kupu.html', this will generate the file 'kupu.html' in the 'common' directory. Other common targets (currently the only ones, actually, but you can expect more in the future as platform support will be added to the core) are 'kupuform.html', 'zope2macros', 'silvamacros' and 'plonemacros'. 
				</data>
			</node>
			<node>
				<data>
					More information about the templating system and how to use it (for example to create your own dists) can be found in the Appendices. 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				Zope example 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Library drawers 
			</data>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Using Kupu 
		</data>
		<node done="no" type="todo">
			<data>
				Basic formatting 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Images and links 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Lists and definition lists 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Tables 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Library drawers 
			</data>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Integrating Kupu 
		</data>
		<node done="no" type="todo">
			<data>
				Basic steps 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Zope 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Other platforms 
			</data>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Customizing Kupu 
		</data>
		<node done="no" type="todo">
			<data>
				Customization using CSS 
			</data>
			<node done="no" type="todo">
				<data>
					CSS for the obvious: design 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Removing tools and buttons 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					The drawback 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				Basic customization 
			</data>
			<node done="no" type="todo">
				<data>
					Not the easiest tool to configure... 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Know your weapons! 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					The future of Kupu customization 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				Kupustart 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Kupuinit 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Buttons 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Tools and toolboxes 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Other elements 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				The templating system 
			</data>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Extending Kupu 
		</data>
		<node done="no" type="todo">
			<data>
				Kupu helpers library 
			</data>
			<node done="yes" type="todo">
				<data>
					Introduction 
				</data>
				<node>
					<data>
						Extending Kupu is quite involved and will almost inevitably mean you will run into some of the oddities of the JavaScript programming languages, either in the form of differences between one browser or another or just some language quirk (being a Python developer in my spare time I spot a lot of those, may be me being a bit oversensitive to such quirks as well ;). The kupuhelpers.js file tries to make life a bit easier by providing nice abstraction layers, workarounds and other hacks, nicely tucked away in a dark corner. Whether you write complete extensions or just integrate Kupu into some application, you will want to know what's inside this module, since it contains a lot of useful stuff. 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Helper functions and classes 
				</data>
				<node done="yes" type="todo">
					<data>
						addEventHandler 
					</data>
					<node>
						<data>
							A function to register an event handler for an event on a certain element. This should be called with 4 arguments: a reference to the element on which to listen to the event, the name of the event, a reference to the function to call when the event occurs and the context in which the event handler should be called (usually the object it belongs to, see ContextFixer below). 
						</data>
					</node>
					<node>
						<data>
							The event handler will be called in the context passed in as the last argument and with the event as the only argument. 
						</data>
					</node>
				</node>
				<node done="yes" type="todo">
					<data>
						removeEventHandler 
					</data>
					<node>
						<data>
							Unregisters an event handler registered with 'addEventHandler', arguments are the element on which the handler was registered, the name of the event and a reference to the handler. 
						</data>
					</node>
				</node>
				<node done="yes" type="todo">
					<data>
						openPopup 
					</data>
					<node>
						<data>
							Simple helper method for opening a popup window. Arguments are the URL to display, the width and the height of the window. 
						</data>
					</node>
				</node>
				<node done="yes" type="todo">
					<data>
						selectSelectItem 
					</data>
					<node>
						<data>
							Helper function for selecting an item in a &lt;select&gt; element. Arguments are a reference to the select list and the value of the option to select. If the value can not be found the first element of the list will be selected. 
						</data>
					</node>
				</node>
				<node done="yes" type="todo">
					<data>
						StateButtonCheckFunction 
					</data>
					<node>
						<data>
							Helper class for Buttons, it is used to make a Button look 'pressed in' when the cursor is inside the a piece of text affected by the button. For instance, if a button looks bold, this class will help in making the bold button look pressed in. Arguments to instantiate a class are an Array of tag names to check for, the name of the style attribute to respond to and the value the style attribute should have. The class has a single method, 'execute' that will be called by the Button object to which it should be registered (see KupuStateButton in the Buttons chapter) on certain events on the editor frame. It will be called with 4 arguments, a reference to the current selected node, a reference to the button, one to the editor and one to the event. 
						</data>
					</node>
				</node>
				<node done="yes" type="todo">
					<data>
						loadDictFromXML 
					</data>
					<node>
						<data>
							Helper function for the initKupu() function, this is used to read the XML data island containing the configuration from the HTML. It will be called with 2 arguments: a reference to the document in which the data island is resided and the id of the &lt;xml&gt; element of the data island. The island should contain a single 'document element' and a flat set of key/value pairs in the form of elements with values. The function will parse this island to a flat object (dictionary) and return that when done. 
						</data>
					</node>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					ContextFixer 
				</data>
				<node done="no" type="todo">
					<data>
						Description 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Scope 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Instantiating 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Basic functionality 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Customizing 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Timer 
				</data>
				<node done="no" type="todo">
					<data>
						Description 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Scope 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Instantiating 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Basic functionality 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						Customizing 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Additional basic datatype functionality 
				</data>
				<node done="no" type="todo">
					<data>
						Array.contains 
					</data>
				</node>
				<node done="no" type="todo">
					<data>
						String.strip 
					</data>
				</node>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				Selection 
			</data>
			<node done="no" type="todo">
				<data>
					Description 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Scope 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Instantiating 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Basic functionality 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Customizing 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				KupuDocument 
			</data>
			<node done="no" type="todo">
				<data>
					Description 
				</data>
				<node>
					<data>
						KupuDocument is a wrapper around the iframe. It contains a small set of methods that either provide access to the iframe or the iframe's contents (window, document) or perform actions on the iframe (execCommand). You can get a reference to the Document object by calling KupuEditor.getDocument(), don't ever access the document another way since that might break in setups where more than one document are controlled by the same Editor class (currently in the making). 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Scope 
				</data>
				<node>
					<data>
						Used by KupuEditor to access the iframe. When writing extensions you will also need to use the KupuDocument object to get access to the iframe or the iframe's attributes. 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Instantiating 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Basic functionality 
				</data>
				<node>
					<data>
						KupuDocument contains the method that forms the basis of the Kupu editor (well, for most of the classic functionality of the editor at least), execCommand. This is a method that is implemented by the browsers and allows one to generate all sorts of markup (to create bold, italic and underlined text but also to add images). ExecCommand is a very useful and powerful tool, it can be used to build quite a nice WYSIWYG editor without much effort, but it's also quite limited, restricting element creation to the basics such as images and lists. To allow more complex elements to be created Kupu has implemented the Selection object (for more information, see the chapter about Selection). ExecCommand should never be called directly, always use the KupuEditor's execCommand method that performs some extra actions. 
					</data>
				</node>
				<node>
					<data>
						To allow more complex elements Kupu provides the Selection object (for more information about this object read the previous chapter). The KupuDocument class provides a method to acquire a reference to such a Selection object, but, as with the 'execCommand' method, it should never be called directly but always using the 'getSelection' method on KupuEditor. 
					</data>
				</node>
			</node>
			<node done="no" type="todo">
				<data>
					Customizing 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				KupuEditor 
			</data>
			<node done="no" type="todo">
				<data>
					Description 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Scope 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Instantiating 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Basic functionality 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Customizing 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				KupuTool 
			</data>
			<node done="no" type="todo">
				<data>
					Description 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Scope 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Instantiating 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Basic functionality 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Customizing 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				KupuToolbox 
			</data>
			<node done="no" type="todo">
				<data>
					Description 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Scope 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Instantiating 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Basic functionality 
				</data>
			</node>
			<node done="no" type="todo">
				<data>
					Customizing 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				LibraryDrawer 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				ContextMenu and ContextMenuElement 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				ContentFilters 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Loggers 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Kupu default tools and toolboxes 
			</data>
		</node>
	</node>
	<node done="no" type="todo">
		<data>
			Appendices 
		</data>
		<node done="no" type="todo">
			<data>
				API reference 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				The Templating system 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				ECMAUnit 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Sarissa 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				License 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				OSCOM 
			</data>
			<node done="no" type="todo">
				<data>
					OSCOM (the Open Source COntent Management association) is an international association that tries to make CMS developers and users of the world unite. To achieve this goal they organize conferences and sprints (events where a group of hackers work on a certain project for a couple of days), undertake and support projects (of which Kupu is one) and provide promotion, both for open-source content management systems as for instance standards to improve interoperability and exchangeability. 
				</data>
			</node>
		</node>
		<node done="no" type="todo">
			<data>
				Mailing lists 
			</data>
		</node>
		<node done="no" type="todo">
			<data>
				Subversion 
			</data>
		</node>
	</node>
</tree>
