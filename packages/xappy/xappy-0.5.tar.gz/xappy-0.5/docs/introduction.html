<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">
<div class="section">
<h1><a class="toc-backref" href="#id1" id="introduction" name="introduction">Introduction</a></h1>
<div class="contents topic">
<p class="topic-title first"><a id="table-of-contents" name="table-of-contents">Table of contents</a></p>
<ul class="simple">
<li><a class="reference" href="#introduction" id="id1" name="id1">Introduction</a></li>
<li><a class="reference" href="#installing-and-testing" id="id2" name="id2">Installing and testing</a><ul>
<li><a class="reference" href="#dependencies" id="id3" name="id3">Dependencies</a></li>
<li><a class="reference" href="#installation" id="id4" name="id4">Installation</a></li>
<li><a class="reference" href="#running-the-testsuite" id="id5" name="id5">Running the testsuite</a></li>
</ul>
</li>
<li><a class="reference" href="#building-a-database" id="id6" name="id6">Building a database</a><ul>
<li><a class="reference" href="#setting-up-a-field-structure" id="id7" name="id7">Setting up a field structure</a></li>
<li><a class="reference" href="#indexing" id="id8" name="id8">Indexing</a></li>
</ul>
</li>
<li><a class="reference" href="#searching" id="id9" name="id9">Searching</a><ul>
<li><a class="reference" href="#finding-similar-documents" id="id10" name="id10">Finding similar documents</a></li>
<li><a class="reference" href="#concurrent-update-limitations" id="id11" name="id11">Concurrent update limitations</a></li>
<li><a class="reference" href="#sorting" id="id12" name="id12">Sorting</a></li>
<li><a class="reference" href="#collapsing" id="id13" name="id13">Collapsing</a></li>
</ul>
</li>
<li><a class="reference" href="#errors" id="id14" name="id14">Errors</a></li>
<li><a class="reference" href="#other-documentation" id="id15" name="id15">Other documentation</a></li>
</ul>
</div>
<p>The &quot;xappy&quot; module is an easy-to-use interface to the Xapian search engine.
Xapian provides a low level interface, dealing with terms and documents, but
not really worrying about where terms come from, or how to build searches to
match the way in which data has been indexed.  In contrast, Xappy allows you
to design a field structure, specifying what kind of information is held in
particular fields, and then uses this field structure to index data
appropriately, and to build and perform searches.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="installing-and-testing" name="installing-and-testing">Installing and testing</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id3" id="dependencies" name="dependencies">Dependencies</a></h2>
<p>You will need an up-to-date version of Xapian (both the core library and the
corresponding Python bindings) to use Xappy.  Unfortunately, the latest
release (1.0.3) doesn't support all the features needed by Xappy, so you will
either need a recent snapshot release, or to build from Xapian SVN HEAD.  We
recommend using a snapshot unless you are actively developing Xapian itself.</p>
<p>We hope that release 1.0.4 will be suitable for use with Xappy.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="installation" name="installation">Installation</a></h2>
<p>There is not yet a distutils setup script for xappy, but other than Xapian it
has no dependencies or resources which need installing, so it may be installed
simply by copying the &quot;xappy&quot; directory to somewhere on your Python path.</p>
<p>Once Xapian and Xappy are installed, you should be able to start the python
interpreter and run:</p>
<pre class="literal-block">
&gt;&gt;&gt; import xappy
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="running-the-testsuite" name="running-the-testsuite">Running the testsuite</a></h2>
<p>To run the testsuite, simply run &quot;./testsuite/runtests.py&quot;.  This will
display any errors produced when running the testsuite, and then display a
coverage report for the modules tested.</p>
<p>The testsuite is composed of tests taken from three sources:</p>
<blockquote>
<ul class="simple">
<li>doctest tests in the code comments in the</li>
<li>additional doctest tests in text files with names of the form
'FOO_doctestN.txt', which test the module named &quot;FOO&quot; (and are run in a
context in which the modules public symbols have all been imported).</li>
<li>additional documentation files (such as this one) which contain doctest
formatted examples.</li>
</ul>
</blockquote>
<p>The list of core modules to test, and additional documentation files to check,
is maintained in the &quot;testsuite/runtests.py&quot; file.</p>
<p>The coverage report displayed after running the testsuite is statement based,
which is sadly one of the least precise methods of generating a coverage
report, and counts lines as having been executed even if they haven't been
tested in all possible code paths.  On the plus side, its judgement is reliable
if it considers that a line of code hasn't been tested.  For this reason, it is
reasonable to aim for 100% coverage by this metric, and the coverage report can
be helpful to keep track of sections of code which aren't tested at all.</p>
<p>For any released version of Xappy, the coverage report should indicate 100%
coverage for all modules.  However, if you are using an SVN snapshot of Xappy,
you may find that some code is not covered.  In addition, the coverage testing
currently contains a bug when run under Python 2.5 which causes some lines of
code to be incorectly marked as &quot;not covered&quot; when they actually are.  When run
under Python 2.4, this bug doesn't manifest.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="building-a-database" name="building-a-database">Building a database</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="setting-up-a-field-structure" name="setting-up-a-field-structure">Setting up a field structure</a></h2>
<p>Before we process any documents, we need to create a database to hold the
documents.  This is done simply by creating an &quot;IndexerConnection&quot; object, and
passing it the path we want to create the database at.  If the database doesn't
already exist, this will create a new, empty, database:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn = xappy.IndexerConnection('db1')
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">All connections may only be accessed from a single thread at a time,
and there may only be one IndexerConnection in existence at any given time.
Additionally, it generally gives a large performance gain to ensure that the
connection is kept open between modifications of the database, so that
modifications can be grouped together.  Therefore, you must protect access to
the connection with a mutex if multiple threads might access it.</p>
</div>
<p>Once we've created an IndexerConnection, we can use it to specify the actions
which should be performed on fields with a given name.  There are several
actions available, for different types of field content, and for different
types of searches.  You need to decide what actions you need before adding
documents, because the database does not store enough information about
documents to get back to the unprocessed document.  The connection will allow
you to change the field actions after documents have been added, but this
change will not be reflected in any documents which have already been added to
the database.</p>
<p>Fields which contain plain text should be added with the <tt class="docutils literal"><span class="pre">INDEX_FREETEXT</span></tt>
action.  This action takes various optional parameters:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">weight</span></tt>: if this is supplied, the frequency information for all terms in
the specified field will be multiplied by the given factor; this can be used
for fields which are often a better indication of the subject matter than
other fields (eg, title fields).</li>
<li><tt class="docutils literal"><span class="pre">language</span></tt>: if this is supplied, it indicates the language that the
supplied text is written in: this is used to perform language specific term
normalising (to allow, for example, plural and singular forms to be
matched).  The language may be specified as a 2 character ISO-639 language
code.</li>
<li><tt class="docutils literal"><span class="pre">stop</span></tt>: if this is supplied, it must contain an sequence or other iterable
which returns a list of stopwords, which will be filtered out of the index.
This may reduce index size and improve search and indexing speed, but will
reduce the flexibility of the search.  Note that some information on the
terms in the stoplist will still be stored, to allow phrase searches to be
performed.</li>
<li><tt class="docutils literal"><span class="pre">spell</span></tt>: this is a boolean flag; if supplied, and true, the contents of
the field will be used for spelling correction.</li>
<li><tt class="docutils literal"><span class="pre">nopos</span></tt>: this is a boolean flag; if supplied, and true, the positions of
words in the field will not be stored.  These are used for performing phrase
and proximity searches, so this kind of search will not be possible on the
field.  On the other hand, the amount of data indexed for the field will be
reduced, resulting in a lower database size, faster indexing, and
potentially faster searching.</li>
<li><tt class="docutils literal"><span class="pre">allow_field_specific</span></tt>: this is a boolean flag - if False, prevents terms
with the field prefix being generated.  This means that searches specific to
this field will not work, and thus should only be used when only non-field
specific searches are desired.  Defaults to True.</li>
<li><tt class="docutils literal"><span class="pre">search_by_default</span></tt>: this is a boolean flag - if False, the field will not
be searched by non-field specific searches.  If True, or omitted, the field
will be included in searches for non field-specific searches.</li>
</ul>
</blockquote>
<p>All text passed to the interface is assumed to be UTF-8 encoded Unicode.</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('title', xappy.FieldActions.INDEX_FREETEXT, weight=5, language='en')
&gt;&gt;&gt; conn.add_field_action('text', xappy.FieldActions.INDEX_FREETEXT, language='en', spell=True)
</pre>
<p>Any fields which contain exact values which we want to search for (such as a
category name, or an ID number should be given the <tt class="docutils literal"><span class="pre">INDEX_EXACT</span></tt> actions.
This doesn't perform any processing on the field value, so any symbols or
punctuation will be preserved in the database:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('category', xappy.FieldActions.INDEX_EXACT)
</pre>
<p>If we want to be able to sort on a field, we need to give it the <tt class="docutils literal"><span class="pre">SORTABLE</span></tt>
action.  By default, sorting is performed based on a lexicographical comparison
of string values, but it is possible to set the sort order to be by date, or by
floating point number.  Fields which are given then <tt class="docutils literal"><span class="pre">SORTABLE</span></tt> action can
also be used to restrict the results to a given range - think of it as
declaring that there is a useful ordering for the field values.</p>
<p>Date values can be supplied as strings in the form YYYYMMDD or YYYY-MM-DD (or
using / or . as separators).  Floating point numbers can be in any
representation which is understood by Python's float() function:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('category', xappy.FieldActions.SORTABLE)
&gt;&gt;&gt; conn.add_field_action('date', xappy.FieldActions.SORTABLE, type=&quot;date&quot;)
&gt;&gt;&gt; conn.add_field_action('price', xappy.FieldActions.SORTABLE, type=&quot;float&quot;)
</pre>
<p>If we want to be able to be able to remove duplicates based on a field, we need
to give it the <tt class="docutils literal"><span class="pre">COLLAPSE</span></tt> action.  This allows the result set to be
&quot;collapsed&quot; such that only the highest result with each value of a field will
be returned.  For example, we might want to just display the highest ranked
document in each category (with a link to a list of the results in that
category):</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('category', xappy.FieldActions.COLLAPSE)
</pre>
<p>If we want to be able to retrieve data from the document when it is
the result of a search, we need to set the <tt class="docutils literal"><span class="pre">STORE_CONTENT</span></tt> action:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('text', xappy.FieldActions.STORE_CONTENT)
&gt;&gt;&gt; conn.add_field_action('title', xappy.FieldActions.STORE_CONTENT)
&gt;&gt;&gt; conn.add_field_action('category', xappy.FieldActions.STORE_CONTENT)
</pre>
<p>If we want to use the contents of a field as &quot;tags&quot;, which can be counted at
search time (possibly, in order to build a tag-cloud, or other such
visualisation), we need to set the <tt class="docutils literal"><span class="pre">TAG</span></tt> action:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('tag', xappy.FieldActions.TAG)
</pre>
<p>Xappy also supports &quot;faceted browsing&quot;: this means attaching &quot;facets&quot; to
documents, where a facet is a value representing one aspect of information
about a document: for example, the price of an object would be a facet of a
document representing that object.  Xappy supports storing many facets about a
document, restricting the search results to only those documents which contain
a particular facet, and automatically selecting a set of facets which are
relevant to the set of results returned by a search (so that the facets can be
presented to the user to be used to refine their search).</p>
<p>If we want to use a field as a facet, we simply add the <tt class="docutils literal"><span class="pre">FACET</span></tt> action to it.
Facets can be of two types - &quot;string&quot; (which are just exact string matches), or
&quot;float&quot; (which will automatically be grouped into ranges when returning a
suggested list of facets).  The default is &quot;string&quot;:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add_field_action('price', xappy.FieldActions.FACET, type='float')
&gt;&gt;&gt; conn.add_field_action('category', xappy.FieldActions.FACET, type='string')
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="indexing" name="indexing">Indexing</a></h2>
<p>To add data to the database, we first create <tt class="docutils literal"><span class="pre">UnprocessedDocument</span></tt> objects.
These contain a list of fields, which are processed in turn to create a
<tt class="docutils literal"><span class="pre">ProcessedDocument</span></tt>, which can be added to the database.  The
<tt class="docutils literal"><span class="pre">ProcessedDocument</span></tt> can't be converted back into an <tt class="docutils literal"><span class="pre">UnprocessedDocument</span></tt>
because some information is generally lost in this processing process (but it
is possible to make alterations directly to the <tt class="docutils literal"><span class="pre">ProcessedDocument</span></tt> later.</p>
<p>We can access the list of fields in an <tt class="docutils literal"><span class="pre">UnprocessedDocument</span></tt> directly, using
the <tt class="docutils literal"><span class="pre">fields</span></tt> member:</p>
<pre class="literal-block">
&gt;&gt;&gt; doc = xappy.UnprocessedDocument()
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;title&quot;, &quot;Our first document&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;text&quot;, &quot;This is a paragraph of text.  It's quite short.&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;text&quot;, &quot;We can create another paragraph of text.  &quot;
...                               &quot;We can have as many of these as we like.&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;category&quot;, &quot;Test documents&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;tag&quot;, &quot;Tag1&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;tag&quot;, &quot;Test document&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;tag&quot;, &quot;Test document&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;price&quot;, &quot;20.56&quot;))
</pre>
<p>We can add the document directly to the database: if we do this, the connection
will process the document to generate a <tt class="docutils literal"><span class="pre">ProcessedDocument</span></tt> behind the
scenes, and then add this:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.add(doc)
'0'
</pre>
<p>Note that the <tt class="docutils literal"><span class="pre">add</span></tt> method returned a value <tt class="docutils literal"><span class="pre">'0'</span></tt>.  This is a unique
identifier for the document which was added, and may be used later to delete or
replace the document.  If we have externally generated unique identifiers, we
can specify that the system should use them instead of generating its own, by
setting the <tt class="docutils literal"><span class="pre">id</span></tt> property on the processed or unprocessed document
before adding it to the database.</p>
<p>We can also ask the database to process a document explicitly before calling
the &quot;add&quot; method.  We might do this if we want to change the processed document
in some way, but this isn't generally necessary:</p>
<pre class="literal-block">
&gt;&gt;&gt; doc = xappy.UnprocessedDocument()
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;title&quot;, &quot;Our second document&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;text&quot;, &quot;In the beginning God created the heaven and the earth.&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;category&quot;, &quot;Bible&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;price&quot;, &quot;12.20&quot;))
&gt;&gt;&gt; doc.id='Bible1'
&gt;&gt;&gt; pdoc = conn.process(doc)
&gt;&gt;&gt; conn.add(pdoc)
'Bible1'
&gt;&gt;&gt; doc = xappy.UnprocessedDocument()
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;title&quot;, &quot;Our third document&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;text&quot;, &quot;And the earth was without form, and void; &quot;
...                               &quot;and darkness was upon the face of the deep. &quot;
...                               &quot;And the Spirit of God moved upon the face of the waters.&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;category&quot;, &quot;Bible&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;date&quot;, &quot;17501225&quot;))
&gt;&gt;&gt; doc.fields.append(xappy.Field(&quot;price&quot;, &quot;16.56&quot;))
&gt;&gt;&gt; doc.id='Bible2'
&gt;&gt;&gt; pdoc = conn.process(doc)
&gt;&gt;&gt; conn.add(pdoc)
'Bible2'
</pre>
<p>Once we have finished indexing, we should flush the changes to disk.  Any
changes which are unflushed may not be preserved if the processes exits without
closing the database nicely:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.flush()
</pre>
<p>Finally, we should close the connection to release its resources (if we leave
this to the garbage collector, this might not happen for a long time).  After
closing, no other methods may be called on the connection, but a new connection
can be made.:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.close()
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="searching" name="searching">Searching</a></h1>
<p>A search connection is opened similarly to an indexing connection.  However,
note that multiple search connections may be opened at once (though each
connection must not be accessed from more than one thread).  Search connections
can even be open while indexing connections are:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn = xappy.SearchConnection('db1')
</pre>
<p>A search connection attempts to provide a stable view of the database, so when
an update is made by a concurrent indexing process, the search connection will
not reflect this change.  This allows the results of the search to be gathered
without needing to worry about concurrent updates (but see the section below
about this for limitations on this facility).</p>
<p>The search connection can be reopened at any time to make it point to the
latest version of the database:</p>
<pre class="literal-block">
&gt;&gt;&gt; conn.reopen()
</pre>
<p>To perform a search, we need to specify what we're searching for.  This is
called a &quot;Query&quot;, and the search connection provides several methods for
building up a query.  The simplest of these is the <tt class="docutils literal"><span class="pre">query_field</span></tt> method,
which builds a query to search a single field:</p>
<pre class="literal-block">
&gt;&gt;&gt; q = conn.query_field('text', 'create a paragraph')
&gt;&gt;&gt; str(q)
'Xapian::Query(((ZXBcreat:(pos=1) AND ZXBa:(pos=2) AND ZXBparagraph:(pos=3)) AND_MAYBE (XBcreate:(pos=1) AND XBa:(pos=2) AND XBparagraph:(pos=3))))'
</pre>
<p>As you can see, the str() function will display the underlying Xapian query
which is generated by the search connection.  This may look a little weird at
first, but you can get a general idea of the shape of the query.</p>
<p>The default operator for searches is &quot;AND&quot;, but if we wish to be a little wider
in our search, we can use the &quot;OR&quot; operator instead:</p>
<pre class="literal-block">
&gt;&gt;&gt; q = conn.query_field('text', 'create a paragraph', default_op=conn.OP_OR)
&gt;&gt;&gt; str(q)
'Xapian::Query(((ZXBcreat:(pos=1) OR ZXBa:(pos=2) OR ZXBparagraph:(pos=3)) AND_MAYBE (XBcreate:(pos=1) OR XBa:(pos=2) OR XBparagraph:(pos=3))))'
</pre>
<p>Once we have a query, we can use it to get a set of search results.  Xapian is
optimised for situations where only a small subset of the total result set is
required, so when we perform a search we specify the starting <cite>rank</cite> (ie, the
position in the total set of results, starting at 0) of the results we want to
retrieve, and also the ending rank.  Following usual Python conventions, the
ending rank isn't inclusive, but the starting rank is.</p>
<p>In this case we want the first 10 results, so we can search with:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(q, 0, 10)
</pre>
<p>The result set has a variety of pieces of information, but a useful one is the
estimate of the total number of matching documents:</p>
<pre class="literal-block">
&gt;&gt;&gt; results.matches_estimated
2
</pre>
<p>Only an estimated value is available because of Xapian's optimisations: the
search process can often stop early because it has proved that there can be no
better ranked documents, and especially for large searches, it would be a waste
of time to then attempt to calculate the precise number of matching documents.
We can check if the estimate is known to be correct by looking at the
<tt class="docutils literal"><span class="pre">estimate_is_exact</span></tt> property:</p>
<pre class="literal-block">
&gt;&gt;&gt; results.estimate_is_exact
True
</pre>
<p>The <tt class="docutils literal"><span class="pre">SearchResults</span></tt> object also provides upper and lower bounds on the number
of matching documents, and a check for whether there are more results following
those in this result set (very useful when writing a &quot;pager&quot; type interface,
which needs to know whether to include a &quot;Next&quot; button).</p>
<p>Once you have a <tt class="docutils literal"><span class="pre">SearchResults</span></tt> object, you want to be able to get at the
actual resulting documents.  This can be done by using the <tt class="docutils literal"><span class="pre">get_hit()</span></tt>
method, or by iterating through all the results with the usual Python iterator
idiom.  Both of these will return <tt class="docutils literal"><span class="pre">SearchResult</span></tt> objects, which is a subclass
of <tt class="docutils literal"><span class="pre">ProcessedDocument</span></tt>, but has the additional property of <cite>rank</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for result in results:
...     print result.rank, result.id, result.data['category']
0 0 ['Test documents']
1 Bible1 ['Bible']
</pre>
<p>In addition, <tt class="docutils literal"><span class="pre">SearchResults</span></tt> objects have methods allowing a highlighted or
summarised version of a field to be displayed:</p>
<pre class="literal-block">
&gt;&gt;&gt; results.get_hit(0).highlight('text')[0]
&quot;This is &lt;b&gt;a&lt;/b&gt; &lt;b&gt;paragraph&lt;/b&gt; of text.  It's quite short.&quot;
&gt;&gt;&gt; results.get_hit(0).summarise('text', maxlen=20)
'This is &lt;b&gt;a&lt;/b&gt; &lt;b&gt;paragraph&lt;/b&gt;..'
</pre>
<p>(Note that the highlight() method returns a list of field instances, as stored
in the document data, so we've asked for it to only return the first of these,
but the summarise() method joins these all together before generating the
summary.)</p>
<p>Queries can be built and combined with other methods.  The most flexible of
these is the <tt class="docutils literal"><span class="pre">query_parse()</span></tt> method, which allows a user entered query to be
parsed appropriately.  The parser understands &quot;Google style&quot; searches, in which
a search term can be restricted to a specified field by writing
&quot;fieldname:term&quot;, and in which boolean operators can be used in the search.
The full syntax is described in the <a class="reference" href="http://xapian.org/docs/queryparser.html">Xapian QueryParser documentation</a>.
(Note that the wildcard option is currently disabled by default.)</p>
<p>If a field has been indexed with the &quot;spell&quot; option turned on, the
<tt class="docutils literal"><span class="pre">spell_correct()</span></tt> method can return a version of the query string with the
spelling corrected.  This method takes similar arguments to <tt class="docutils literal"><span class="pre">query_parse()</span></tt>,
but instead of performing a search, it returns the corrected query string (or
the original query string, if no spelling corrections were found).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; conn.spell_correct('teext')
'text'
</pre>
</blockquote>
<p>In addition, two queries may be combined (with an AND or OR operator) using the
<tt class="docutils literal"><span class="pre">query_composite()</span></tt> method, or a query can be &quot;filtered&quot; with another query
such that only documents which match both queries will be returned (but the
rankings are determined by the first query) using the <tt class="docutils literal"><span class="pre">query_filter()</span></tt>
method.</p>
<p>To perform a range restriction, a range query can be built using the
<tt class="docutils literal"><span class="pre">query_range()</span></tt> method.  This will return a query which matches all documents
in the database which satisfy the range restriction:</p>
<pre class="literal-block">
&gt;&gt;&gt; rq = conn.query_range('date', '20000101', '20010101')
</pre>
<p>This query can be performed on its own, but note that for a large database it
could take a long time to run, because if run on its own it will iterate
through all the values in the database to return those which fit in the range.
Instead, it will usually be used in conjunction with the <tt class="docutils literal"><span class="pre">query_filter()</span></tt>
method, to filter the results of an existing query:</p>
<pre class="literal-block">
&gt;&gt;&gt; filtered_query = conn.query_filter(q, rq)
&gt;&gt;&gt; print filtered_query
Xapian::Query((((ZXBcreat:(pos=1) OR ZXBa:(pos=2) OR ZXBparagraph:(pos=3)) AND_MAYBE (XBcreate:(pos=1) OR XBa:(pos=2) OR XBparagraph:(pos=3))) FILTER VALUE_RANGE 1 20000101 20010101))
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The implementation of sorting and range filtering for floating point values uses terms which typically contain non-printable characters.  Don't panic if you call <tt class="docutils literal"><span class="pre">print</span></tt> on a query generated with <tt class="docutils literal"><span class="pre">query_range()</span></tt> and odd control-characters are displayed; it's probably normal.)</p>
</div>
<p>To get a list of the tags which are contained in the result set, we have to
specify the gettags parameter to the search() method:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(q, 0, 10, gettags='tag')
&gt;&gt;&gt; results.get_top_tags('tag', 10)
[('tag1', 1), ('test document', 1)]
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">When the result set is being generated, various optimisations are performed to avoid wasting time looking at documents which can't possibly get into the portion of the result set which has been requested.  These are normally desirable optimisations because they can speed up searches considerably, but if information about the tags in the result set as a whole is desired, the optimisations can cause inaccurate values to be returned.  Therefore, it is possible to force the search engine to look at at least a minimum number of results, by setting the &quot;checkatleast&quot; parameter of the search() method.  As a special case, a value of -1 forces all matches to be examined, regardless of database size: this should be used with care, because it can result in slow searches.</p>
</div>
<p>To search for only those documents containing a given tag, we can use the
query_field() method:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(conn.query_field('tag', 'tag1'), 0, 10)
&gt;&gt;&gt; results.matches_estimated, results.estimate_is_exact
(1, True)
&gt;&gt;&gt; results.get_hit(0).highlight('text')[0]
&quot;This is a paragraph of text.  It's quite short.&quot;
</pre>
<p>To get a list of facets which are relevant to the result set, we have to
specify the getfacets parameter to the search() method.  We can also specify
the allowfacets or denyfacets parameters to control the set of facets which are
considered for display (this may be useful to reduce work if we've already
restricted to a particular facet value, for example).  Note that as with the
gettags option, it may be advisable to specify a reasonably high value for the
&quot;checkatleast&quot; parameter:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(q, 0, 10, checkatleast=1000, getfacets=True)
&gt;&gt;&gt; results.get_suggested_facets()
[('category', [('bible', 1), ('test documents', 1)]), ('price', [((12.199999999999999, 12.199999999999999), 1), ((20.559999999999999, 20.559999999999999), 1)])]
</pre>
<p>Note that the values for the suggested facets contain the string for facets of
type &quot;string&quot;, but contain a pair of numbers for facets of type &quot;float&quot; - these
numbers define an automatically suggested range of values to use for the facet.</p>
<p>To restrict a further search to a particular value of the facet, or range of
facets, a query can be produced using the query_facet() method.  This will
often be combined with an existing query using query_filter(), but you are free
to use it differently if you wish.  Note that the values in the output of
get_suggested_facets() are in a form suitable for passing to the value
parameter of query_facet().  For example, results can be restricted using a
&quot;string&quot; facet like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; facet_q = conn.query_facet('category', 'bible')
&gt;&gt;&gt; results = conn.search(conn.query_filter(q, facet_q), 0, 10)
&gt;&gt;&gt; for result in results:
...     print result.rank, result.id, result.data['category']
0 Bible1 ['Bible']
</pre>
<p>Or can be restricted using a &quot;float&quot; facet like this:</p>
<pre class="literal-block">
&gt;&gt;&gt; facet_q = conn.query_facet('price', (20.559999999999999, 20.559999999999999))
&gt;&gt;&gt; results = conn.search(conn.query_filter(q, facet_q), 0, 10)
&gt;&gt;&gt; for result in results:
...     print result.rank, result.id, result.data['category']
0 0 ['Test documents']
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="finding-similar-documents" name="finding-similar-documents">Finding similar documents</a></h2>
<p>Sometimes, instead of searching for documents matching a specific set of
criteria, you want to find documents similar to a document (or documents) that
you already have.  You might also want to combine such a similarity search with
a search for some specific criteria; restricting the results by the criteria,
but sorting in similarity order.</p>
<p>This can be achieved using the <tt class="docutils literal"><span class="pre">query_similar()</span></tt> method, which produces a
query, based on a list of document ids, which will return documents similar to
those identified by the supplied document IDs.</p>
<p>The similarity search is only based on the terms generated for free text
searching (ie, with the <tt class="docutils literal"><span class="pre">INDEX_FREETEXT</span></tt> action), so there must be at least
one such field for the similarity search to work.  By default, all fields
indexed with <tt class="docutils literal"><span class="pre">INDEX_FREETEXT</span></tt> will be used for the similarity search, but the
list of fields to use may be controlled with the <tt class="docutils literal"><span class="pre">allow</span></tt> and <tt class="docutils literal"><span class="pre">deny</span></tt>
parameters.</p>
<p>In addition, the number of terms to use for the similarity calculation may be
controlled with the <tt class="docutils literal"><span class="pre">simterms</span></tt> parameter (which defaults to 10).   A higher
value will allow documents which are less similar to appear in the result set
(but the most similar documents will still occur first).  A lower value will
usually result in a faster search.  10 is probably a suitable value in most
situations, but experimentation may be worthwhile for a particular dataset to
determine whether changing the value can improve the results (or produce a
useful speedup without compromising the results).</p>
<p>To perform a simple similarity search, based on a few document IDs:</p>
<pre class="literal-block">
&gt;&gt;&gt; simq = conn.query_similar(('Bible1',))
&gt;&gt;&gt; results = conn.search(simq, 0, 10)
&gt;&gt;&gt; [result.id for result in results]
['Bible1', 'Bible2', '0']
</pre>
<p>Note that the document ID supplied came first in the set of results.  While
this is not guaranteed (in particular, it may not occur if there are other
documents in the search corpus which are very similar to the supplied
documents), this will usually be the case - if you wish to ignore the documents
specified, you should ask for the appropriate number of extra results, and
filter them out at display time (don't just ignore the top N results, assuming
that they are those supplied).</p>
<p>To perform a normal search, but reorder the ranking based on similarity, use
the <tt class="docutils literal"><span class="pre">query_filter()</span></tt> method to filter the results of a similarity search to
be only those documents which match the normal search:</p>
<pre class="literal-block">
&gt;&gt;&gt; plainq = conn.query_field('text', 'God OR moved OR text')
&gt;&gt;&gt; simq = conn.query_similar(('Bible1',))
&gt;&gt;&gt; combined = conn.query_filter(simq, plainq)

&gt;&gt;&gt; results = conn.search(plainq, 0, 10)
&gt;&gt;&gt; [result.id for result in results]
['Bible2', '0', 'Bible1']

&gt;&gt;&gt; results = conn.search(combined, 0, 10)
&gt;&gt;&gt; [result.id for result in results]
['Bible1', 'Bible2', '0']
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="concurrent-update-limitations" name="concurrent-update-limitations">Concurrent update limitations</a></h2>
<p>Unfortunately, Xapian's current database implementation doesn't allow search
connections to be arbitrarily old: once <em>two</em> updates have been made to the
database since the connection was opened, the connection may fail with a
&quot;DatabaseModifiedError&quot; when it tries to access the database.  Once this has
happened, the search connection needs to be reopened to proceed further, and
will then access a new, updated, view of the database.</p>
<p>To make this easier to manage, if the &quot;DatabaseModifiedError&quot; occurs during the
search process, the error will be handled automatically, and the search will be
re-performed.  However, it is still possible for the error to occur when
retrieving the document data from a search result, so handling for this should
be included in code which reads the data from search results.</p>
<p>To avoid this happening, avoid calling the flush() method on the indexer
connection too frequently, and call the reopen() method on the search
connection before performing each new search.  You should generally try not to
call flush() more than once every 60 seconds anyway, because performance with
many small flushes will be sub-optimal.</p>
<p>We hope to remove this restriction in a future release of Xapian.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="sorting" name="sorting">Sorting</a></h2>
<p>By default, the results are returned in order sorted by their &quot;relevance&quot; to
the query, with the most relevant documents returned first.  This order may be
changed by specifying the sortby parameter of the search() method.  The field
specified in this parameter must have been given the <tt class="docutils literal"><span class="pre">SORTABLE</span></tt> action before
indexing:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(q, 0, 10, sortby='category')
&gt;&gt;&gt; for result in results:
...     print result.rank, result.id, result.data['category']
0 Bible1 ['Bible']
1 0 ['Test documents']
</pre>
<p>The sort is in ascending order by default (ie, documents with a field value
which is first in order will be returned first).  The opposite order can be
requested by preceding the field name with a &quot;-&quot; sign:</p>
<pre class="literal-block">
&gt;&gt;&gt; results = conn.search(q, 0, 10, sortby='-category')
&gt;&gt;&gt; for result in results:
...     print result.rank, result.id, result.data['category']
0 0 ['Test documents']
1 Bible1 ['Bible']
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">There is some potential for confusion here, because Xapian defines
ascending order in the opposite direction: its logic is that ascending order
means that the value should be highest in documents which come top of the
result list.  This seems counter-intuitive to many people, and hopefully the
sort order definition here will seem more natural.</p>
</div>
<p>If the sort terms are equal, the documents with equal sort terms will be
returned in relevance order.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id13" id="collapsing" name="collapsing">Collapsing</a></h2>
<p>Xapian offers the useful feature of collapsing the result set such that only
the top result with a given &quot;collapse&quot; value is returned.  This feature can be
used by adding a <tt class="docutils literal"><span class="pre">COLLAPSE</span></tt> action to the field before indexing, and then
setting the collapse parameter of the <tt class="docutils literal"><span class="pre">search()</span></tt> method to the field name:</p>
<pre class="literal-block">
&gt;&gt;&gt; q = conn.query_field('title', 'document')
&gt;&gt;&gt; [result.id for result in conn.search(q, 0, 10)]
['Bible1', '0', 'Bible2']
&gt;&gt;&gt; [result.id for result in conn.search(q, 0, 10, collapse='category')]
['Bible1', '0']
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id14" id="errors" name="errors">Errors</a></h1>
<p>Most errors raised by xappy will be a subclass of xappy.SearchEngineError (the
only deliberate exceptions are standard python errors, caused by invalid
parameters being supplied to xappy).  Any errors related to searching will be
instances of xappy.SearchError, and errors related to indexing will be
instances of xappy.IndexerError.</p>
<p>Errors may also be raised by the underlying Xapian library.  For example, if
you attempt to make two simultaneous IndexerConnections to a single database,
Xapian will raise a xapian.DatabaseLockError.  However, to avoid users of xappy
needing to import xapian, the xapian errors are exposed by xappy.  For example,
xapian.DatabaseLockError can be caught by catching
xappy.XapianDatabaseLockError (note the &quot;Xapian&quot; prefix of
&quot;XapianDatabaseLockError&quot;).  In addition, the inheritance heirarchy of the
xapian errors is modified so that xappy.XapianError can be used as a catch-all
for all Xapian errors, and xappy.SearchEngineError will catch all Xapian errors as well as any errors directly from xappy.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id15" id="other-documentation" name="other-documentation">Other documentation</a></h1>
<p>Detailed API documentation is available as docstrings in the Python code, but
you may find it more convenient to browse it in <a class="reference" href="api/index.html">formatted form (as generated by
epydoc)</a>.</p>
</div>
</div>
</body>
</html>
