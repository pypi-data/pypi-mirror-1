<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Connection package reference</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="programming-guidelines.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="connection-package-reference">
<h1 class="title">Connection package reference</h1>
<p>The <tt class="docutils literal"><span class="pre">connection</span></tt> sub-package allows the sending of picklable objects
between processes using sockets or (on Windows) <em>named pipes</em>.  It
also has support for <em>digest authetication</em> (using the <tt class="docutils literal"><span class="pre">hmac</span></tt> module
from the standard library).</p>
<p>The sub-package contains C extensions <tt class="docutils literal"><span class="pre">socket_connection</span></tt> and
<tt class="docutils literal"><span class="pre">pipe_connection</span></tt>.  Without these extensions <tt class="docutils literal"><span class="pre">connection</span></tt> will
still work, but will be slower and will not support the use of named
pipes.</p>
<div class="section">
<h1><a id="classes-and-functions" name="classes-and-functions">Classes and functions</a></h1>
<p>The module exports the following classes:</p>
<blockquote>
<dl class="docutils">
<dt><strong>class</strong> <tt class="docutils literal"><span class="pre">Listener(address=None,</span> <span class="pre">family=None,</span> <span class="pre">backlog=1,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd>A wrapper for a bound socket or Windows named pipe which is
'listening' for connections.</dd>
<dt><strong>exception</strong> <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt></dt>
<dd>Exception raised when there is an authentication error.</dd>
</dl>
</blockquote>
<p>The module exports one function:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Client(address,</span> <span class="pre">family=None,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd><p class="first">Attempts to set up a connection to the listener which is using
address <tt class="docutils literal"><span class="pre">address</span></tt>.</p>
<p>The type of the connection is determined by <tt class="docutils literal"><span class="pre">family</span></tt>
argument, but this can generally be omitted since it can
usually be inferred from the format of <tt class="docutils literal"><span class="pre">address</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">authkey</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> then a <em>handshake</em> is preformed
with the other end of the connection using <tt class="docutils literal"><span class="pre">authkey</span></tt> as an
authentication key.  If this fails then <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt>
is raised.</p>
<p class="last">A <tt class="docutils literal"><span class="pre">Connection</span></tt> object is returned.  (See <a class="reference" href="#connection-objects">Connection
objects</a>.)</p>
</dd>
</dl>
</blockquote>
<!-- `deliver_challenge(connection, authkey)`
    Sends a randomly generated message to the other end of the
    connection and waits for a reply.

    If the reply matches the digest of the message using `authkey`
    as the key then a welcome message is sent to the other end of
    the connection.  Otherwise `AuthenticationError` is raised.

`answer_challenge(connection, authkey)`
    Receives a message, calculates the digest of the message using
    `authkey` as the key, and then sends the digest back.

    If a welcome message is not received then
    `AuthenticationError` is raised. -->
</div>
<div class="section">
<h1><a id="listener-objects" name="listener-objects">Listener objects</a></h1>
<p>Instances of <tt class="docutils literal"><span class="pre">Listener</span></tt> have the following methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">__init__(address=None,</span> <span class="pre">family=None,</span> <span class="pre">backlog=1,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd><dl class="first last docutils">
<dt><tt class="docutils literal"><span class="pre">address</span></tt></dt>
<dd>The address to be used by the bound socket
or named pipe of the listener object.</dd>
<dt><tt class="docutils literal"><span class="pre">family</span></tt></dt>
<dd><p class="first">The type of the socket (or named pipe) to use.</p>
<p>This can be one of the strings <tt class="docutils literal"><span class="pre">'AF_INET'</span></tt> (for a TCP
socket), <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt> (for a Unix domain socket) or
<tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> (for a Windows named pipe).  Of these only
the first is guaranteed to be available.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">family</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> than the family is inferred from the
format of <tt class="docutils literal"><span class="pre">address</span></tt>.  If <tt class="docutils literal"><span class="pre">address</span></tt> is also <tt class="docutils literal"><span class="pre">None</span></tt> then a
default is chosen.  This default is the family which is
assumed to be the fastest available.  See <a class="reference" href="#address-formats">Address
formats</a>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">backlog</span></tt></dt>
<dd>If the listener object uses a socket then <tt class="docutils literal"><span class="pre">backlog</span></tt> is
passed to the <tt class="docutils literal"><span class="pre">listen()</span></tt> method of the socket once it has
been bound.</dd>
<dt><tt class="docutils literal"><span class="pre">authkey</span></tt></dt>
<dd>If not <tt class="docutils literal"><span class="pre">None</span></tt> then when <tt class="docutils literal"><span class="pre">accept()</span></tt> is called the other end
of the resulting connection is required to prove that it
knows the value of <tt class="docutils literal"><span class="pre">authkey</span></tt>.  See <a class="reference" href="#authentication-keys">Authentication keys</a>.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">accept()</span></tt></dt>
<dd><p class="first">Accept a connection on the bound socket or named pipe of
the listener object.</p>
<p>Returns a <tt class="docutils literal"><span class="pre">Connection</span></tt> object.  See <a class="reference" href="#connection-objects">Connection objects</a>.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">authkey</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> then a <em>handshake</em> is preformed
with the other end of the connection using <tt class="docutils literal"><span class="pre">authkey</span></tt> as an
authentication key.  If this fails then <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt>
is raised.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">close()</span></tt></dt>
<dd><p class="first">Close the bound socket or named pipe of the listener object.</p>
<p class="last">This is called automatically when the listener is garbage
collected.</p>
</dd>
</dl>
</blockquote>
<p>Listener objects have the following read-only properties:</p>
<blockquote>
<dl class="docutils">
<dt><strong>property</strong> <tt class="docutils literal"><span class="pre">address</span></tt></dt>
<dd>The address which is being used by the listener object.</dd>
<dt><strong>property</strong> <tt class="docutils literal"><span class="pre">last_accepted</span></tt></dt>
<dd><p class="first">The address from which the last accepted connection came.</p>
<p class="last">If this is unavailable then <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="connection-objects" name="connection-objects">Connection objects</a></h1>
<p>Connections objects have the following methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">recv()</span></tt></dt>
<dd>Return an object sent from the other end of the connection
using <tt class="docutils literal"><span class="pre">send()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">send(obj)</span></tt></dt>
<dd><p class="first">Send an object to the other end of the connection which should
be read using <tt class="docutils literal"><span class="pre">recv()</span></tt>.</p>
<p class="last">The object must be picklable.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">recv_string()</span></tt></dt>
<dd>Return a string sent from the other end of the connection
using <tt class="docutils literal"><span class="pre">send_string()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">send_string(obj)</span></tt></dt>
<dd>Send a string to the other end of the connection which should
be read using <tt class="docutils literal"><span class="pre">recv_string()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">close()</span></tt></dt>
<dd><p class="first">Close the connection.</p>
<p class="last">This is called automatically when the connection is garbage
collected.</p>
</dd>
</dl>
</blockquote>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <tt class="docutils literal"><span class="pre">recv()</span></tt> method automatically unpickles the data it receives
which can be a security risk.  Therefore if you are using the
<tt class="docutils literal"><span class="pre">recv()</span></tt> and <tt class="docutils literal"><span class="pre">send()</span></tt> methods you should be using some form of
authentication.  See <a class="reference" href="#authentication-keys">Authentication keys</a>.</p>
</div>
</div>
<div class="section">
<h1><a id="address-formats" name="address-formats">Address formats</a></h1>
<ul>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_INET'</span></tt> address is a tuple of the form <tt class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">port)</span></tt>
where <tt class="docutils literal"><span class="pre">hostname</span></tt> is a string and <tt class="docutils literal"><span class="pre">port</span></tt> is an integer</p>
</li>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt> address is a string representing a filename on the
filesystem.</p>
</li>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> address is a string of the form
<tt class="docutils literal"><span class="pre">r'\\.\pipe\PipeName'</span></tt>.</p>
<p>To use <tt class="docutils literal"><span class="pre">Client</span></tt> to connect to a named pipe on a remote computer
called <tt class="docutils literal"><span class="pre">ServerName</span></tt> one should use an address of the form
<tt class="docutils literal"><span class="pre">r'\\ServerName\pipe\PipeName'</span></tt> instead.</p>
</li>
</ul>
<p>Note that any string beginning with two backslashes is assumed by
default to be an <tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> address rather than an <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt>
address.</p>
</div>
<div class="section">
<h1><a id="authentication-keys" name="authentication-keys">Authentication keys</a></h1>
<p>When one uses the <tt class="docutils literal"><span class="pre">recv()</span></tt> method of a connection object, the data
received is automatically unpickled.  Unfortunately unpickling data
from an untrusted source is a security risk.  Therefore <tt class="docutils literal"><span class="pre">Listener</span></tt> and
<tt class="docutils literal"><span class="pre">Client</span></tt> use the <tt class="docutils literal"><span class="pre">hmac</span></tt> module to provide digest authentication.</p>
<p>An authentication key is a string which can be thought of as a
password: once a connection is established both ends will demand proof
that the other knows the authentication key.  (Demonstrating that both
ends are using the same key does <em>not</em> involve sending the key over
the connection.)</p>
<p>As an authentication key one can use the return value of
<tt class="docutils literal"><span class="pre">currentProcess().getAuthKey()</span></tt> (see <a class="reference" href="process-objects.html">Process objects</a>).  This value will automatically inherited by
any <tt class="docutils literal"><span class="pre">Process</span></tt> object that the current process creates.  This means
that (by default) all processes of a multi-process program will share
a single authentication key which can be used when setting up
connections between the themselves.</p>
<p>Suitable authentication keys can be generated by <tt class="docutils literal"><span class="pre">os.urandom()</span></tt>.</p>
</div>
<div class="section">
<h1><a id="example" name="example">Example</a></h1>
<p>The following server code creates a listener which uses <tt class="docutils literal"><span class="pre">'secret</span>
<span class="pre">password'</span></tt> as an authentication key.  It then waits for a connection,
receives an object and then sends it back boxed inside a list:</p>
<pre class="literal-block">
from processing.connection import Listener

address = ('localhost', 6000)     # family is deduced to be 'AF_INET'
listener = Listener(address, authkey='secret password')

conn = listener.accept()
print 'connection accepted from', listener.last_accepted

obj = conn.recv()
boxed_obj = [obj]
conn.send(boxed_obj)
</pre>
<p>The following code connects to the server, sends it the number 42, and
then prints the reply from the server:</p>
<pre class="literal-block">
from processing.connection import Client

address = ('localhost', 6000)
conn = Client(address, authkey='secret password')

obj = 42
print 'sending:', obj
conn.send(obj)
print 'recieved:', conn.recv()    # prints 'received: [42]'
</pre>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="programming-guidelines.html">Next</a>
</div>
</body>
</html>
