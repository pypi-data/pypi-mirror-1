<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Connection module</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="programming-guidelines.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="connection-module">
<h1 class="title">Connection module</h1>
<p>The <tt class="docutils literal"><span class="pre">connection</span></tt> module allows the sending of picklable objects
between processes using sockets or (on Windows) named pipes.  It
also has support for <em>digest authentication</em> (using the <tt class="docutils literal"><span class="pre">hmac</span></tt> module
from the standard library).</p>
<p>If the C extension <tt class="docutils literal"><span class="pre">_processing</span></tt> is not available then connections
will be slower and on Windows one will not be able to use named pipes.</p>
<div class="section">
<h1><a id="classes-and-functions" name="classes-and-functions">Classes and functions</a></h1>
<p>The module defines the following functions:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Listener(address=None,</span> <span class="pre">family=None,</span> <span class="pre">backlog=1,</span> <span class="pre">authenticate=False,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd>Returns a wrapper for a bound socket or Windows named pipe
which is 'listening' for connections.</dd>
<dt><tt class="docutils literal"><span class="pre">Client(address,</span> <span class="pre">family=None,</span> <span class="pre">authenticate=False,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd><p class="first">Attempts to set up a connection to the listener which is using
address <tt class="docutils literal"><span class="pre">address</span></tt>.</p>
<p>The type of the connection is determined by <tt class="docutils literal"><span class="pre">family</span></tt>
argument, but this can generally be omitted since it can
usually be inferred from the format of <tt class="docutils literal"><span class="pre">address</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">authentication</span></tt> or <tt class="docutils literal"><span class="pre">authkey</span></tt> is a string then then digest
authentication is used.  The key used for authentication will
be either <tt class="docutils literal"><span class="pre">authkey</span></tt> or <tt class="docutils literal"><span class="pre">currentProcess.getAuthKey()</span></tt> if
<tt class="docutils literal"><span class="pre">authkey</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>.  If authentication fails then
<tt class="docutils literal"><span class="pre">AuthenticationError</span></tt> is raised.  See <a class="reference" href="#authentication-keys">Authentication keys</a>.</p>
<p class="last">A <tt class="docutils literal"><span class="pre">Connection</span></tt> object is returned.  (See <a class="reference" href="#connection-objects">Connection
objects</a>.)</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Pipe()</span></tt></dt>
<dd><p class="first">Returns a pair of two connection objects (see <a class="reference" href="#connection-objects">Connection
objects</a>) representing the ends of a duplex connection.
It is also available directly from <tt class="docutils literal"><span class="pre">processing</span></tt>.</p>
<p>For example:</p>
<pre class="literal-block">
from processing import Process, Pipe

def foo(conn):
    conn.send(42)

if __name__ == '__main__':
    c, d = Pipe()
    p = Process(target=foo, args=[d])
    p.start()
    print c.recv()   # prints 42
    p.join()
</pre>
<p class="last">Note that at most one thread/process should be sending or
receiving from a connection object at a given time.</p>
</dd>
</dl>
</blockquote>
<!-- `deliver_challenge(connection, authkey)`
    Sends a randomly generated message to the other end of the
    connection and waits for a reply.

    If the reply matches the digest of the message using `authkey`
    as the key then a welcome message is sent to the other end of
    the connection.  Otherwise `AuthenticationError` is raised.

`answer_challenge(connection, authkey)`
    Receives a message, calculates the digest of the message using
    `authkey` as the key, and then sends the digest back.

    If a welcome message is not received then
    `AuthenticationError` is raised. -->
<p>The module exports two exception types:</p>
<blockquote>
<dl class="docutils">
<dt><strong>exception</strong> <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt></dt>
<dd>Exception raised when there is an authentication error.</dd>
<dt><strong>exception</strong> <tt class="docutils literal"><span class="pre">BufferTooShort</span></tt></dt>
<dd><p class="first">Exception raise by the <tt class="docutils literal"><span class="pre">recvbytes_into()</span></tt> method of a
connection object when the supplied buffer object is too small
for the message read.</p>
<p>If <tt class="docutils literal"><span class="pre">e</span></tt> is an instance of <tt class="docutils literal"><span class="pre">BufferTooShort</span></tt> then <tt class="docutils literal"><span class="pre">e.args[0]</span></tt> will
give the message as a byte string.</p>
<p class="last">Only available if <tt class="docutils literal"><span class="pre">_processing</span></tt> can be imported.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="listener-objects" name="listener-objects">Listener objects</a></h1>
<p>Instances of <tt class="docutils literal"><span class="pre">Listener</span></tt> have the following methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">__init__(address=None,</span> <span class="pre">family=None,</span> <span class="pre">backlog=1,</span> <span class="pre">authenticate=False,</span> <span class="pre">authkey=None)</span></tt></dt>
<dd><dl class="first last docutils">
<dt><tt class="docutils literal"><span class="pre">address</span></tt></dt>
<dd>The address to be used by the bound socket
or named pipe of the listener object.</dd>
<dt><tt class="docutils literal"><span class="pre">family</span></tt></dt>
<dd><p class="first">The type of the socket (or named pipe) to use.</p>
<p>This can be one of the strings <tt class="docutils literal"><span class="pre">'AF_INET'</span></tt> (for a TCP
socket), <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt> (for a Unix domain socket) or
<tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> (for a Windows named pipe).  Of these only
the first is guaranteed to be available.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">family</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> than the family is inferred from the
format of <tt class="docutils literal"><span class="pre">address</span></tt>.  If <tt class="docutils literal"><span class="pre">address</span></tt> is also <tt class="docutils literal"><span class="pre">None</span></tt> then a
default is chosen.  This default is the family which is
assumed to be the fastest available.  See <a class="reference" href="#address-formats">Address
formats</a>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">backlog</span></tt></dt>
<dd>If the listener object uses a socket then <tt class="docutils literal"><span class="pre">backlog</span></tt> is
passed to the <tt class="docutils literal"><span class="pre">listen()</span></tt> method of the socket once it has
been bound.</dd>
<dt><tt class="docutils literal"><span class="pre">authenticate</span></tt></dt>
<dd>If <tt class="docutils literal"><span class="pre">authenticate</span></tt> is true or <tt class="docutils literal"><span class="pre">authkey</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt> then
digest authentication is used.</dd>
<dt><tt class="docutils literal"><span class="pre">authkey</span></tt></dt>
<dd><p class="first">If <tt class="docutils literal"><span class="pre">authkey</span></tt> is a string then it will be used as the
authentication key; otherwise it must be <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">authkey</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">authenticate</span></tt> is true then
<tt class="docutils literal"><span class="pre">currentProcess.getAuthKey()</span></tt> is used as the authentication
key.</p>
<p>If <tt class="docutils literal"><span class="pre">authkey</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> and <tt class="docutils literal"><span class="pre">authentication</span></tt> is false then
no authentication is done.</p>
<p class="last">If authentication fails then <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt> is
raised.  See <a class="reference" href="#authentication-keys">Authentication keys</a>.</p>
</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">accept()</span></tt></dt>
<dd><p class="first">Accept a connection on the bound socket or named pipe of the
listener object.  If authentication is attempted and fails
then <tt class="docutils literal"><span class="pre">AuthenticationError</span></tt> is raised.</p>
<p class="last">Returns a <tt class="docutils literal"><span class="pre">Connection</span></tt> object.  See <a class="reference" href="#connection-objects">Connection objects</a>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">close()</span></tt></dt>
<dd><p class="first">Close the bound socket or named pipe of the listener object.</p>
<p class="last">This is called automatically when the listener is garbage
collected.</p>
</dd>
</dl>
</blockquote>
<p>Listener objects have the following read-only properties:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">address</span></tt></dt>
<dd>The address which is being used by the listener object.</dd>
<dt><tt class="docutils literal"><span class="pre">last_accepted</span></tt></dt>
<dd><p class="first">The address from which the last accepted connection came.</p>
<p class="last">If this is unavailable then <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="connection-objects" name="connection-objects">Connection objects</a></h1>
<p>A connection object represents one end of a message oriented socket or
pipe connection.  Connection objects have the following methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">send(obj)</span></tt></dt>
<dd><p class="first">Send an object to the other end of the connection which should
be read using <tt class="docutils literal"><span class="pre">recv()</span></tt>.</p>
<p class="last">The object must be picklable.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">recv()</span></tt></dt>
<dd>Return an object sent from the other end of the connection
using <tt class="docutils literal"><span class="pre">send()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">fileno()</span></tt></dt>
<dd>Returns the file descriptor or handle used by the connection.</dd>
<dt><tt class="docutils literal"><span class="pre">close()</span></tt></dt>
<dd><p class="first">Close the connection.</p>
<p class="last">This is called automatically when the connection is garbage
collected.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">poll(timeout)</span></tt></dt>
<dd>Return whether there is any data available to be read.</dd>
<dt><tt class="docutils literal"><span class="pre">sendbytes(buffer)</span></tt></dt>
<dd><p class="first">Send byte data from an object supporting the buffer interface
as a complete message.</p>
<p class="last">Can be used to send strings.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">recvbytes()</span></tt></dt>
<dd>Return a complete message of byte data sent from the other end
of the connection as a string.</dd>
<dt><tt class="docutils literal"><span class="pre">recvbytes_into(buffer)</span></tt></dt>
<dd><p class="first">Read into buffer a complete message of byte data sent from the
other end of the connection and return the number of bytes in
the message.</p>
<p class="last">If the buffer is too short then a <tt class="docutils literal"><span class="pre">BufferTooShort</span></tt> exception
is raised and the complete message of bytes data is available
as <tt class="docutils literal"><span class="pre">e.args[0]</span></tt> where <tt class="docutils literal"><span class="pre">e</span></tt> is the exception instance.</p>
</dd>
</dl>
</blockquote>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <tt class="docutils literal"><span class="pre">recv()</span></tt> method automatically unpickles the data it
receives which can be a security risk.  Therefore if you are using
the <tt class="docutils literal"><span class="pre">recv()</span></tt> and <tt class="docutils literal"><span class="pre">send()</span></tt> methods you should be using some
form of authentication.  See <a class="reference" href="#authentication-keys">Authentication keys</a>.</p>
</div>
</div>
<div class="section">
<h1><a id="transferring-connection-objects-between-processes" name="transferring-connection-objects-between-processes">Transferring connection objects between processes</a></h1>
<p>If the C extension <tt class="docutils literal"><span class="pre">processing._process</span></tt> is available and contains
support then socket objects, connection objects and file objects can
be successfully pickled in one process and unpickled in another.</p>
<p>Note however that on Windows there is no <tt class="docutils literal"><span class="pre">socket.fromfd()</span></tt> function.
As a result on Windows an unpickled socket object is not a true socket
object: only the <tt class="docutils literal"><span class="pre">recv()</span></tt>, <tt class="docutils literal"><span class="pre">send()</span></tt>, <tt class="docutils literal"><span class="pre">sendall()</span></tt>, <tt class="docutils literal"><span class="pre">close()</span></tt> and
<tt class="docutils literal"><span class="pre">fileno()</span></tt> methods will work.</p>
</div>
<div class="section">
<h1><a id="address-formats" name="address-formats">Address formats</a></h1>
<ul>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_INET'</span></tt> address is a tuple of the form <tt class="docutils literal"><span class="pre">(hostname,</span> <span class="pre">port)</span></tt>
where <tt class="docutils literal"><span class="pre">hostname</span></tt> is a string and <tt class="docutils literal"><span class="pre">port</span></tt> is an integer</p>
</li>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt> address is a string representing a filename on the
filesystem.</p>
</li>
<li><p class="first">An <tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> address is a string of the form
<tt class="docutils literal"><span class="pre">r'\\.\pipe\PipeName'</span></tt>.</p>
<p>To use <tt class="docutils literal"><span class="pre">Client</span></tt> to connect to a named pipe on a remote computer
called <tt class="docutils literal"><span class="pre">ServerName</span></tt> one should use an address of the form
<tt class="docutils literal"><span class="pre">r'\\ServerName\pipe\PipeName'</span></tt> instead.</p>
</li>
</ul>
<p>Note that any string beginning with two backslashes is assumed by
default to be an <tt class="docutils literal"><span class="pre">'AF_PIPE'</span></tt> address rather than an <tt class="docutils literal"><span class="pre">'AF_UNIX'</span></tt>
address.</p>
</div>
<div class="section">
<h1><a id="authentication-keys" name="authentication-keys">Authentication keys</a></h1>
<p>When one uses the <tt class="docutils literal"><span class="pre">recv()</span></tt> method of a connection object, the data
received is automatically unpickled.  Unfortunately unpickling data
from an untrusted source is a security risk.  Therefore <tt class="docutils literal"><span class="pre">Listener</span></tt> and
<tt class="docutils literal"><span class="pre">Client</span></tt> use the <tt class="docutils literal"><span class="pre">hmac</span></tt> module to provide digest authentication.</p>
<p>An authentication key is a string which can be thought of as a
password: once a connection is established both ends will demand proof
that the other knows the authentication key.  (Demonstrating that both
ends are using the same key does <em>not</em> involve sending the key over
the connection.)</p>
<p>If authentication is requested but do authentication key is specified
then the return value of <tt class="docutils literal"><span class="pre">currentProcess().getAuthKey()</span></tt> is used (see
<a class="reference" href="process-objects.html">Process objects</a>).  This value will
automatically inherited by any <tt class="docutils literal"><span class="pre">Process</span></tt> object that the current
process creates.  This means that (by default) all processes of a
multi-process program will share a single authentication key which can
be used when setting up connections between the themselves.</p>
<p>Suitable authentication keys can also be generated by using
<tt class="docutils literal"><span class="pre">os.urandom()</span></tt>.</p>
</div>
<div class="section">
<h1><a id="example" name="example">Example</a></h1>
<p>The following server code creates a listener which uses <tt class="docutils literal"><span class="pre">'secret</span>
<span class="pre">password'</span></tt> as an authentication key.  It then waits for a connection
and sends some data to the client:</p>
<pre class="literal-block">
from processing.connection import Listener
from array import array

address = ('localhost', 6000)     # family is deduced to be 'AF_INET'
listener = Listener(address, authkey='secret password')

conn = listener.accept()
print 'connection accepted from', listener.last_accepted

conn.send([2.25, None, 'junk', float])

conn.sendbytes('hello')

conn.sendbytes(array('i', [42, 1729]))

conn.close()
listener.close()
</pre>
<p>The following code connects to the server and receives some data from
the server:</p>
<pre class="literal-block">
from processing.connection import Client
from array import array

address = ('localhost', 6000)
conn = Client(address, authkey='secret password')

print conn.recv()                 # =&gt; [2.25, None, 'junk', float]

print conn.recvbytes()            # =&gt; 'hello'

arr = array('i', [0, 0, 0, 0, 0])
print conn.recvbytes_into(arr)    # =&gt; 8
print arr                         # =&gt; array('i', [42, 1729, 0, 0, 0])

conn.close()
</pre>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="programming-guidelines.html">Next</a>
</div>
</body>
</html>
