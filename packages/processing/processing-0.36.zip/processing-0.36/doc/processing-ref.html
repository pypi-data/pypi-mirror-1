<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>processing package reference</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="intro.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="process-objects.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="processing-package-reference">
<h1 class="title">processing package reference</h1>
<p>The <tt class="docutils literal"><span class="pre">processing</span></tt> package mostly replicates the API of the <tt class="docutils literal"><span class="pre">threading</span></tt>
module.</p>
<div class="section">
<h1><a id="classes-and-exceptions" name="classes-and-exceptions">Classes and exceptions</a></h1>
<blockquote>
<dl class="docutils">
<dt><strong>class</strong> <tt class="docutils literal"><span class="pre">Process(group=None,</span> <span class="pre">target=None,</span> <span class="pre">name=None,</span> <span class="pre">args=(),</span> <span class="pre">kwargs={})</span></tt></dt>
<dd><p class="first">An analogue of <tt class="docutils literal"><span class="pre">threading.Thread</span></tt>.</p>
<p class="last">See <a class="reference" href="process-objects.html">Process objects</a>.</p>
</dd>
<dt><strong>exception</strong> <tt class="docutils literal"><span class="pre">ProcessExit</span></tt></dt>
<dd>Exception raised in a target process when the <tt class="docutils literal"><span class="pre">Process.stop()</span></tt>
method is used.  This is a subclass of <tt class="docutils literal"><span class="pre">SystemExit</span></tt>.</dd>
<dt><strong>exception</strong> <tt class="docutils literal"><span class="pre">BufferTooShort</span></tt></dt>
<dd><p class="first">Exception raise by the <tt class="docutils literal"><span class="pre">recvbytes_into()</span></tt> method of a
<a class="reference" href="connection-ref.html#connection-objects">connection object</a>
when the supplied buffer object is too small for the message
read.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">e</span></tt> is an instance of <tt class="docutils literal"><span class="pre">BufferTooShort</span></tt> then <tt class="docutils literal"><span class="pre">e.args[0]</span></tt>
will give the message as a byte string.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="pipes-and-queues" name="pipes-and-queues">Pipes and Queues</a></h1>
<p>When using multiple processes one generally uses message passing for
communication between processes and avoids having to use any
synchronization primitives like locks.</p>
<p>For passing messages one can use a pipe (for a connection between two
processes) or a queue (which allows multiple producers and consumers).</p>
<p>Note that one can also create a shared queue by using a manager object
-- see <a class="reference" href="#managers">Managers</a>.</p>
<p>For an example of the usage of queues for interprocess communication
see <a class="reference" href="../test/test_workers.py">test_workers.py</a>.</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Pipe()</span></tt></dt>
<dd><p class="first">Returns a pair of connection objects representing the ends of
a duplex pipe.</p>
<p>These connection objects can be inherited by child processes
and have methods <tt class="docutils literal"><span class="pre">send()</span></tt> and <tt class="docutils literal"><span class="pre">recv()</span></tt> (among others) for
sending and receiving picklable objects.  (See <a class="reference" href="connection-ref.html#connection-objects">Connection
objects</a>.)  For
example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from processing import Pipe
&gt;&gt;&gt; a, b = Pipe()
&gt;&gt;&gt; a.send([1, 'hello', None])
&gt;&gt;&gt; b.recv()
[1, 'hello', None]
&gt;&gt;&gt; b.sendbytes('thank you')
&gt;&gt;&gt; a.recvbytes()
'thank you'
</pre>
<p>Note that it is not safe to have more than one process (or
thread) reading or writing to the same end of a pipe at the
same time.</p>
<p class="last">On Windows this requires the <tt class="docutils literal"><span class="pre">_processing</span></tt> extension.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Queue(maxsize=0)</span></tt></dt>
<dd><p class="first">Alias for either <tt class="docutils literal"><span class="pre">PosixQueue</span></tt> if available or else <tt class="docutils literal"><span class="pre">PipeQueue</span></tt>
-- see below.</p>
<p class="last">It differs from Python standard <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt> type by only
have finite capacity, so even when <tt class="docutils literal"><span class="pre">maxsize</span></tt> is specified as
<tt class="docutils literal"><span class="pre">0</span></tt> the <tt class="docutils literal"><span class="pre">put()</span></tt> method might block.  If you need to be sure
that <tt class="docutils literal"><span class="pre">put()</span></tt> will not block then you should use
<tt class="docutils literal"><span class="pre">BufferedQueue()</span></tt> instead.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">BufferedQueue()</span></tt></dt>
<dd><p class="first">Alias for either <tt class="docutils literal"><span class="pre">BufferedPosixQueue</span></tt> if available or else
<tt class="docutils literal"><span class="pre">BufferedPipeQueue</span></tt>.</p>
<p>Differs from <tt class="docutils literal"><span class="pre">Queue()</span></tt> by guaranteeing that the <tt class="docutils literal"><span class="pre">put()</span></tt> method
will not block.  A buffered queue tends to be slower than a
normal queue if you are putting items on the queue one by one
(rather than using <tt class="docutils literal"><span class="pre">putmany()</span></tt>).</p>
<p>The first time a process puts an item on a buffered queue a
thread is started whose job is to transfer items from a buffer
onto the true interprocess queue.  In addition to the usual
queue methods <tt class="docutils literal"><span class="pre">BufferedQueue</span></tt> supports two extra:</p>
<blockquote class="last">
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">putmany(iterable)</span></tt></dt>
<dd>Adds all items in the iterable to the queue's buffer.
So <tt class="docutils literal"><span class="pre">q.putmany(X)</span></tt> is a faster equivalent of
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">X:</span> <span class="pre">q.put(x)</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">close()</span></tt></dt>
<dd>Flushes data from the buffer to the interprocess
queue, then instructs the thread to stop and waits for
it to do so.  This will be called automatically when
the queue is garbage collected or when the process
exits.</dd>
</dl>
</blockquote>
</dd>
<dt><tt class="docutils literal"><span class="pre">PipeQueue(maxsize=0)</span></tt></dt>
<dd><p class="first">Returns a near clone of <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt> except that the
<tt class="docutils literal"><span class="pre">qsize()</span></tt> method is not implemented.  It is implemented using
a pipe and some locks/semaphores.</p>
<p>On Unix if a client terminates while it is reading or writing
from the queue, other clients reading from the queue may lose
track of where messages boundaries are or may retrieve
incomplete messages.  At least on Windows a keyboard interrupt
(SIGINT) or the use of a process's <tt class="docutils literal"><span class="pre">stop()</span></tt> method should not
cause such a problem.</p>
<p>Placing an object on a <tt class="docutils literal"><span class="pre">PipeQueue</span></tt> can block because of lack
of buffer space even if a zero timeout is used.</p>
<p class="last">Requires support for native semaphore support from <tt class="docutils literal"><span class="pre">_processing</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">PosixQueue(maxsize=0,</span> <span class="pre">msgsize=0)</span></tt></dt>
<dd><p class="first">Returns a near clone of <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt> implemented using a (Unix
only) posix message queue.</p>
<p>If <tt class="docutils literal"><span class="pre">maxsize</span></tt> is non-zero it determines the maximum number of
messages that can be in the queue and if <tt class="docutils literal"><span class="pre">msgsize</span></tt> is non-zero
it determines the maximum size in bytes of a message.  If
either is zero then the system default (which is finite) is
used.  (For instance on my Linux system the default maximum
number of messages in a queue is 10 and the maximum message
size is 8192 bytes.)  A <tt class="docutils literal"><span class="pre">PosixQueue</span></tt> object has attributes
<tt class="docutils literal"><span class="pre">_maxmsg</span></tt> and <tt class="docutils literal"><span class="pre">_maxsize</span></tt> which give these limits for that
queue.</p>
<p>Note that if <tt class="docutils literal"><span class="pre">maxsize</span></tt> or <tt class="docutils literal"><span class="pre">msgsize</span></tt> is larger than the system
maximum then an <tt class="docutils literal"><span class="pre">OSError</span></tt> exception will be thrown.  On Linux
the system maximums can viewed and modified through the
<tt class="docutils literal"><span class="pre">/proc</span></tt> filesystem --- see <tt class="docutils literal"><span class="pre">man</span> <span class="pre">7</span> <span class="pre">mq_overview</span></tt>.</p>
<p class="last">Only available on Unix and only if support for posix queues
was built in to <tt class="docutils literal"><span class="pre">_processing</span></tt>.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="synchronization-primitives" name="synchronization-primitives">Synchronization primitives</a></h1>
<p>Generally synchronization primitives are not a necessary in a
multiprocess program as they are in a mulithreaded program.</p>
<p>Note that one can also create synchronization primitves by using a
manager object -- see <a class="reference" href="#managers">Managers</a>.</p>
<p>The following all require support for native sempahores from the
<tt class="docutils literal"><span class="pre">_processing</span></tt> extension.</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">BoundedSemaphore(value=1)</span></tt></dt>
<dd>Returns a bounded semaphore object: a clone of
<tt class="docutils literal"><span class="pre">threading.BoundedSemaphore</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Condition(lock=None)</span></tt></dt>
<dd><p class="first">Returns a condition variable: a clone of <tt class="docutils literal"><span class="pre">threading.Condition</span></tt>.</p>
<p class="last">If <tt class="docutils literal"><span class="pre">lock</span></tt> is specified then it should be a <tt class="docutils literal"><span class="pre">Lock</span></tt> or <tt class="docutils literal"><span class="pre">RLock</span></tt>
object from <tt class="docutils literal"><span class="pre">processing</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Event()</span></tt></dt>
<dd>Returns an event object: a clone of <tt class="docutils literal"><span class="pre">threading.Event</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Lock()</span></tt></dt>
<dd><p class="first">Returns a non-recursive lock object: a near clone of <tt class="docutils literal"><span class="pre">threading.Lock</span></tt>.</p>
<p class="last">There are two differences from <tt class="docutils literal"><span class="pre">threading.Lock</span></tt>: trying to
acquire a lock already owned by the current thread raises an
exception instead of deadlocking; and trying to release a lock
held by a different thread/process will raise and exception.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">RLock()</span></tt></dt>
<dd>Returns a recursive lock object: a clone of <tt class="docutils literal"><span class="pre">threading.RLock</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Semaphore(value=1)</span></tt></dt>
<dd>Returns a bounded semaphore object: a clone of
<tt class="docutils literal"><span class="pre">threading.Semaphore</span></tt>.</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="managers" name="managers">Managers</a></h1>
<p>Managers provide a way to create data which can be shared between
different processes.</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">LocalManager()</span></tt></dt>
<dd><p class="first">Returns a manager object which uses shared memory instead of a
server process.  It has instance methods</p>
<blockquote>
<tt class="docutils literal"><span class="pre">SharedValue</span></tt>, <tt class="docutils literal"><span class="pre">SharedStruct</span></tt>, <tt class="docutils literal"><span class="pre">SharedArray</span></tt></blockquote>
<p>for creating objects stored in shared memory map.  Also has
static methods</p>
<blockquote>
<tt class="docutils literal"><span class="pre">Lock</span></tt>, <tt class="docutils literal"><span class="pre">RLock</span></tt>, <tt class="docutils literal"><span class="pre">Semaphore</span></tt>, <tt class="docutils literal"><span class="pre">BoundedSemaphore</span></tt>,
<tt class="docutils literal"><span class="pre">Condition</span></tt>, <tt class="docutils literal"><span class="pre">Event</span></tt>, <tt class="docutils literal"><span class="pre">Queue</span></tt></blockquote>
<p>which are just aliases for other functions in the <tt class="docutils literal"><span class="pre">processing</span></tt>
namespace.  See <a class="reference" href="manager-objects.html#shared-memory-managers">LocalManager</a>.</p>
<p class="last">Requires support for native semaphores from <tt class="docutils literal"><span class="pre">_processing</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Manager()</span></tt></dt>
<dd><p class="first">Returns a started <tt class="docutils literal"><span class="pre">SyncManager</span></tt> object which can be
used for sharing objects between processes.  The returned
manager object corresponds to a spawned child process and has
methods which will create shared objects and return
corresponding proxies.</p>
<p>The methods for creating shared objects are</p>
<blockquote>
<tt class="docutils literal"><span class="pre">list()</span></tt>, <tt class="docutils literal"><span class="pre">dict()</span></tt>, <tt class="docutils literal"><span class="pre">Namespace()</span></tt>, <tt class="docutils literal"><span class="pre">SharedValue()</span></tt>,
<tt class="docutils literal"><span class="pre">SharedStruct()</span></tt>, <tt class="docutils literal"><span class="pre">SharedArray()</span></tt>, <tt class="docutils literal"><span class="pre">Lock()</span></tt>, <tt class="docutils literal"><span class="pre">RLock()</span></tt>,
<tt class="docutils literal"><span class="pre">Semaphore()</span></tt>, <tt class="docutils literal"><span class="pre">BoundedSemaphore()</span></tt>, <tt class="docutils literal"><span class="pre">Condition()</span></tt>,
<tt class="docutils literal"><span class="pre">Event()</span></tt>, <tt class="docutils literal"><span class="pre">Queue()</span></tt>.</blockquote>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from processing import Manager
&gt;&gt;&gt; manager = Manager()
&gt;&gt;&gt; l = manager.list(range(10))
&gt;&gt;&gt; l.reverse()
&gt;&gt;&gt; print l
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
&gt;&gt;&gt; print repr(l)
&lt;Proxy[list] object at 0x00E1B3B0&gt;
</pre>
<p class="last">See <a class="reference" href="manager-objects.html#syncmanager">SyncManager</a> and
<a class="reference" href="proxy-objects.html">Proxy objects</a>.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="process-pools" name="process-pools">Process Pools</a></h1>
<p>One can create a pool of processes which will carry out tasks
submitted to it.</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Pool(processes=None)</span></tt></dt>
<dd><p class="first">Returns a process pool object which controls a pool of worker
processes to which jobs can be submitted.</p>
<p>It supports asynchronous results with timeouts and
callbacks and has a parallel map implementation.</p>
<p>If <tt class="docutils literal"><span class="pre">processes</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> then the number returned by
<tt class="docutils literal"><span class="pre">cpuCount()</span></tt> is used.  See <a class="reference" href="pool-objects.html">Pool objects</a>.</p>
<p>Example:</p>
<pre class="literal-block">
from processing import Pool

def f(x):
    return x*x

if __name__ == '__main__':
    pool = Pool(processes=2)
    result1 = pool.apply_async(f, (10,))
    result2 = pool.map_async(f, range(5))
    print result1.get()               # =&gt; &quot;100&quot;
    print result2.get(timeout=1)      # =&gt; &quot;[0, 1, 4, 9, 16]&quot;
</pre>
<p class="last">Requires support for native semaphores from <tt class="docutils literal"><span class="pre">_processing</span></tt>.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="logging" name="logging">Logging</a></h1>
<p>Some support for logging is available.  Note, however, that the
<tt class="docutils literal"><span class="pre">logging</span></tt> package does not use process shared locks so it is possible
(depending on the handler type) for messages from different processes
to get mixed up.</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">enableLogging(level,</span> <span class="pre">HandlerType=None,</span> <span class="pre">handlerArgs=(),</span> <span class="pre">format=None)</span></tt></dt>
<dd><p class="first">Enables logging and sets the debug level to <tt class="docutils literal"><span class="pre">level</span></tt> -- see
documentation for the <tt class="docutils literal"><span class="pre">logging</span></tt> package in the standard
library.</p>
<p>If <tt class="docutils literal"><span class="pre">HandlerType</span></tt> is specified then a handler is created using
<tt class="docutils literal"><span class="pre">HandlerType(*handlerArgs)</span></tt> and added to the logger.  If
<tt class="docutils literal"><span class="pre">format</span></tt> is specified then this will be used for the handler
-- <tt class="docutils literal"><span class="pre">format</span></tt> defaults to <tt class="docutils literal"><span class="pre">'[%(levelname)s/%(processName)s]</span>
<span class="pre">%(message)s'</span></tt>.  (The logger used by <tt class="docutils literal"><span class="pre">processing</span></tt> allows use of
the non-standard <tt class="docutils literal"><span class="pre">'%(processName)s'</span></tt> format.)</p>
<p>If <tt class="docutils literal"><span class="pre">HandlerType</span></tt> is not specified and the logger has no
handlers then a default one is created which prints to
<tt class="docutils literal"><span class="pre">sys.stderr</span></tt>.</p>
<p class="last"><em>Note</em>: on Windows a child process does not directly inherit
its parent's logger; instead it will automatically call
<tt class="docutils literal"><span class="pre">enableLogging()</span></tt> with the same arguments which were used when
its parent process last called <tt class="docutils literal"><span class="pre">enableLogging()</span></tt> (if it ever
did).</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">getLogger()</span></tt></dt>
<dd>Returns the logger used by <tt class="docutils literal"><span class="pre">processing</span></tt>.  If <tt class="docutils literal"><span class="pre">enableLogging()</span></tt>
has not yet been called then <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
</dl>
</blockquote>
<p>Below is an example session with logging turned on:</p>
<pre class="literal-block">
&gt;&gt;&gt; import processing, logging
&gt;&gt;&gt; processing.enableLogging(level=logging.INFO)
&gt;&gt;&gt; processing.getLogger().warn('doomed')
[WARNING/MainProcess] doomed
&gt;&gt;&gt; m = processing.Manager()
[INFO/SyncManager-1] process starting up
[INFO/SyncManager-1] manager bound to '\\\\.\\pipe\\pyc-1352-0-r97d0b'
&gt;&gt;&gt; del m
[INFO/MainProcess] sending shutdown message to manager
[INFO/SyncManager-1] manager received shutdown message
[INFO/SyncManager-1] running all &quot;atexit&quot; finalizers
[INFO/SyncManager-1] process exiting with `os.exit(0)`
</pre>
</div>
<div class="section">
<h1><a id="miscellaneous" name="miscellaneous">Miscellaneous</a></h1>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">activeChildren()</span></tt></dt>
<dd><p class="first">Return list of all live children of the current process.</p>
<p class="last">Calling this has the side affect of &quot;joining&quot; any processes
which have already finished.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cpuCount()</span></tt></dt>
<dd>Returns the number of CPUs in the system.  May raise
<tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">currentProcess()</span></tt></dt>
<dd><p class="first">An analogue of <tt class="docutils literal"><span class="pre">threading.currentThread</span></tt></p>
<p class="last">Returns the object corresponding to the current process.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">freezeSupport()</span></tt></dt>
<dd><p class="first">Adds support for when a program which uses the <tt class="docutils literal"><span class="pre">processing</span></tt>
package has been frozen to produce a Windows executable.  (Has
been tested with <tt class="docutils literal"><span class="pre">py2exe</span></tt>, <tt class="docutils literal"><span class="pre">PyInstaller</span></tt> and <tt class="docutils literal"><span class="pre">cx_Freeze</span></tt>.)</p>
<p>One needs to call this function straight after the <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span>
<span class="pre">==</span> <span class="pre">'__main__'</span></tt> line of the main module.  For example</p>
<pre class="literal-block">
from processing import Process, freezeSupport

def f():
    print &quot;hello world!&quot;

if __name__ == '__main__':
    freezeSupport()
    p = Process(target=f)
    p.start()
</pre>
<p>If the <tt class="docutils literal"><span class="pre">freezeSupport()</span></tt> line is missed out then the frozen
executable produced from this module would (on Windows)
recursively create new processes.</p>
<p class="last">If the module is being run normally by the python interpreter
then <tt class="docutils literal"><span class="pre">freezeSupport()</span></tt> has no effect.</p>
</dd>
</dl>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The <tt class="docutils literal"><span class="pre">processing.dummy</span></tt> package replicates the API of <tt class="docutils literal"><span class="pre">processing</span></tt>
but is no more than a wrapper around the <tt class="docutils literal"><span class="pre">threading</span></tt> module.</li>
<li><tt class="docutils literal"><span class="pre">processing</span></tt> contains no analogues of <tt class="docutils literal"><span class="pre">activeCount</span></tt>,
<tt class="docutils literal"><span class="pre">enumerate</span></tt>, <tt class="docutils literal"><span class="pre">settrace</span></tt>, <tt class="docutils literal"><span class="pre">setprofile</span></tt>, <tt class="docutils literal"><span class="pre">Timer</span></tt>, or
<tt class="docutils literal"><span class="pre">local</span></tt> from the <tt class="docutils literal"><span class="pre">threading</span></tt> module.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a id="subsections" name="subsections">Subsections</a></h1>
<ul class="simple">
<li><a class="reference" href="process-objects.html">Process objects</a></li>
<li><a class="reference" href="manager-objects.html">Manager objects</a></li>
<li><a class="reference" href="proxy-objects.html">Proxy objects</a></li>
<li><a class="reference" href="pool-objects.html">Pool objects</a></li>
<li><a class="reference" href="connection-ref.html">connection module</a></li>
</ul>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="intro.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="process-objects.html">Next</a>
</div>
</body>
</html>
