<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Introduction</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="index.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="introduction">
<h1 class="title">Introduction</h1>
<div class="section">
<h1><a id="threads-processes-and-the-gil" name="threads-processes-and-the-gil">Threads, processes and the GIL</a></h1>
<p>To run more than one piece of code at the same time on the same
computer one has the choice of either using multiple processes or
multiple threads.</p>
<p>Although a program can be made up of multiple processes, these
processes are in effect completely independent of one another:
different processes are not able to cooperate with one another unless
one sets up some means of communication between them (such as by using
sockets).  If a lot of data must be transferred between processes then
this can be inefficient.</p>
<p>On the other hand, multiple threads within a single process are
intimately connected: they share their data but often can interfere
badly with one another.  It is often argued that the only way to make
multithreaded programming &quot;easy&quot; is to avoid relying on any shared
state and for the threads to only communicate by passing messages to
each other.</p>
<p>CPython has a <em>Global Interpreter Lock</em> (GIL) which in many ways makes
threading easier than it is in most languages by making sure that only
one thread can manipulate the interpreter's objects at a time.  As a
result, it is often safe to let multiple threads access data without
using any additional locking as one would need to in a language such
as C.</p>
<p>One downside of the GIL is that on multi-processor (or multi-core)
systems a multithreaded Python program can only make use of one
processor at a time.  This is a problem that can be overcome by using
multiple processes instead.</p>
<p>Python gives little direct support for writing programs using multiple
process.  This package allows one to write multi-process programs
using much the same API that one uses for writing threaded programs.</p>
</div>
<div class="section">
<h1><a id="forking-and-spawning" name="forking-and-spawning">Forking and spawning</a></h1>
<p>There are two ways of creating a new process in Python:</p>
<ul>
<li><p class="first">The current process can <em>fork</em> a new child process by using the
<tt class="docutils literal"><span class="pre">os.fork()</span></tt> function.  This effectively creates an identical copy
of the current process which is now able to go off and perform some
task set by the parent process.  This means that the child process
inherits <em>copies</em> of all variables that the parent process had.</p>
<p>However, <tt class="docutils literal"><span class="pre">os.fork()</span></tt> is not available on every platform: in
particular Windows does not support it.</p>
</li>
<li><p class="first">Alternatively, the current process can spawn a completely new Python
interpreter by using the <tt class="docutils literal"><span class="pre">subprocess</span></tt> module or one of the
<tt class="docutils literal"><span class="pre">os.spawn*()</span></tt> functions.</p>
<p>Getting this new interpreter in to a fit state to perform the task
set for it by its parent process is, however, a bit of a challenge.</p>
</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">processing</span></tt> package uses <tt class="docutils literal"><span class="pre">os.fork()</span></tt> if it is available since
it makes life a lot simpler.  Forking the process is also more
efficient in terms of memory usage and the time needed to create the
new process.</p>
</div>
<div class="section">
<h1><a id="the-process-class" name="the-process-class">The Process class</a></h1>
<p>In the <tt class="docutils literal"><span class="pre">processing</span></tt> package processes are spawned by creating a
<tt class="docutils literal"><span class="pre">Process</span></tt> object and then calling its <tt class="docutils literal"><span class="pre">start()</span></tt> method.
<tt class="docutils literal"><span class="pre">processing.Process</span></tt> follows the API of <tt class="docutils literal"><span class="pre">threading.Thread</span></tt>.  A
trivial example of a multiprocess program is</p>
<pre class="literal-block">
from processing import Process

def f():
    print 'hello world'

if __name__ == '__main__':
    p = Process(target=f)
    p.start()
    p.join()
</pre>
<p>Here the function <tt class="docutils literal"><span class="pre">f</span></tt> is run in a child process.</p>
<p>For an explanation of why (on Windows) the <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></tt>
part is necessary see <a class="reference" href="programming-guidelines.html">Programming guidelines</a>.</p>
</div>
<div class="section">
<h1><a id="exchanging-objects-between-processes" name="exchanging-objects-between-processes">Exchanging objects between processes</a></h1>
<p><tt class="docutils literal"><span class="pre">processing</span></tt> contains two main functions for creating a communication
channel between related process:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Queue(maxsize=0)</span></tt></dt>
<dd><p class="first">This is a near clone of <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt>.  For example</p>
<pre class="literal-block">
from processing import Process, Queue

def f(q):
    q.put([42, None, 'hello'])

if __name__ == '__main__':
    q = Queue()
    p = Process(target=f, args=[q])
    p.start()
    print q.get()    # prints &quot;[42, None, 'hello']&quot;
    p.join()
</pre>
<p class="last">Queues are thread and process safe.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Pipe()</span></tt></dt>
<dd><p class="first">This returns a pair of connection objects connected by a
duplex (two-way) pipe, for example</p>
<pre class="literal-block">
from processing import Process, Pipe

def f(conn):
    conn.send([42, None, 'hello'])

if __name__ == '__main__':
    a, b = Pipe()
    p = Process(target=f, args=[b])
    p.start()
    print a.recv()   # prints &quot;[42, None, 'hello']&quot;
    p.join()
</pre>
<p class="last">Note however that the connection object returned by <tt class="docutils literal"><span class="pre">Pipe()</span></tt>
are not thread/process safe: only one thread should write to
or read from a connection object at any time.</p>
</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="synchronization-between-processes" name="synchronization-between-processes">Synchronization between processes</a></h1>
<p><tt class="docutils literal"><span class="pre">processing</span></tt> contains equivalents of all the synchronization
primitives from <tt class="docutils literal"><span class="pre">threading</span></tt>.  For instance one can use a lock to
ensure that only one process prints to standard output at a time:</p>
<pre class="literal-block">
from processing import Process, Lock

def f(l):
    l.acquire()
    print 'hello world', i
    l.release()

if __name__ == '__main__':
    l = Lock()

    for i in range(10):
        Process(target=f, args=[l, i]).start()
</pre>
<p>Without using the lock output from the different processes is liable
to get all mixed up.</p>
</div>
<div class="section">
<h1><a id="sharing-state-between-processes" name="sharing-state-between-processes">Sharing state between processes</a></h1>
<p>As mentioned above, when doing threaded programming it is usually best
to avoid using shared state as far as possible.  This is particularly
true when using multiple processes.</p>
<p>However, if you really do need to use some shared data then you can
create by using a <em>manager</em>.  Managers can store their data in one of
two ways:</p>
<dl class="docutils">
<dt><strong>Shared memory</strong>:</dt>
<dd><p class="first">Data can be stored in a shared memory map managed by an instance of
<tt class="docutils literal"><span class="pre">LocalManager</span></tt>.  Only those data types supported by the <tt class="docutils literal"><span class="pre">struct</span></tt>
and <tt class="docutils literal"><span class="pre">array</span></tt> modules are supported.  For example the following code</p>
<pre class="literal-block">
from processing import Process, LocalManager

def f(n, s, a):
    n.value = 42
    s.value = (0.75, 'hello')
    for i in range(len(a)):
        a[i] = -a[i]

if __name__ == '__main__':
    manager = LocalManager()

    number = manager.SharedValue('i', 0)
    struct = manager.SharedStruct('d256p', (0.0, ''))
    array = manager.SharedArray('i', range(10))

    p = Process(target=f, args=[number, struct, array])
    p.start()
    p.join()

    print number
    print struct
    print array
</pre>
<p>will print</p>
<pre class="literal-block">
SharedValue('i', 42)
SharedStruct('d256p', (0.75, 'hello'))
SharedArray('i', [0, -1, -2, -3, -4, -5, -6, -7, -8, -9])
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">SharedValue</span></tt>, <tt class="docutils literal"><span class="pre">SharedStruct</span></tt> and <tt class="docutils literal"><span class="pre">SharedArray</span></tt> objects
are thread and process safe.  The <tt class="docutils literal"><span class="pre">'i'</span></tt> and <tt class="docutils literal"><span class="pre">'d256p'</span></tt> arguments
used when creating <tt class="docutils literal"><span class="pre">num</span></tt>, <tt class="docutils literal"><span class="pre">struct</span></tt> and <tt class="docutils literal"><span class="pre">array</span></tt> are format strings
of the type used by the <tt class="docutils literal"><span class="pre">struct</span></tt> and <tt class="docutils literal"><span class="pre">array</span></tt> modules: <tt class="docutils literal"><span class="pre">'i'</span></tt>
indicates a signed integer, <tt class="docutils literal"><span class="pre">'d'</span></tt> indicates a double precision
float and <tt class="docutils literal"><span class="pre">'256p'</span></tt> indicates a string of length less than 256.</p>
<p class="last"><em>XXXX Currently the shared memory allocated to a shared value is not
disposed of until the corresponding manager is garbage collected.</em></p>
</dd>
<dt><strong>Server process</strong>:</dt>
<dd><p class="first">A manager object returned by <tt class="docutils literal"><span class="pre">processing.Manager()</span></tt>
represents a server process which holds python objects and allows
other processes to manipulate them using proxies.</p>
<p>In addition to <tt class="docutils literal"><span class="pre">SharedValue</span></tt>, <tt class="docutils literal"><span class="pre">SharedStruct</span></tt> and <tt class="docutils literal"><span class="pre">SharedArray</span></tt> a
manager returned by <tt class="docutils literal"><span class="pre">processing.Manager()</span></tt> will support types
<tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">dict</span></tt>, <tt class="docutils literal"><span class="pre">Namespace</span></tt>, <tt class="docutils literal"><span class="pre">Lock</span></tt>, <tt class="docutils literal"><span class="pre">RLock</span></tt>, <tt class="docutils literal"><span class="pre">Semaphore</span></tt>,
<tt class="docutils literal"><span class="pre">BoundedSemaphore</span></tt>, <tt class="docutils literal"><span class="pre">Condition</span></tt>, <tt class="docutils literal"><span class="pre">Event</span></tt>, <tt class="docutils literal"><span class="pre">Queue</span></tt>.  For example:</p>
<pre class="literal-block">
from processing import Process, Manager

def f(d, l):
    d[1] = '1'
    d['2'] = 2
    d[0.25] = None
    l.reverse()

if __name__ == '__main__':
    manager = Manager()

    d = manager.dict()
    l = manager.list(range(10))

    p = Process(target=f, args=[d, l])
    p.start()
    p.join()

    print d
    print l
</pre>
<p>will print</p>
<pre class="literal-block">
{0.25: None, 1: '1', '2': 2}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</pre>
<p>Creating managers which support other types is not hard --- see
<a class="reference" href="manager-objects.html#customized-managers">Customized managers</a>.</p>
<p>Proxy objects are picklable and can be transferred between
processes.  It is also possible to make use of a manager on a
different computer over a network.</p>
<p class="last">Server process managers are more flexible than shared memory
managers because they support more data types (and can be made to
support many more).  Also, a single server process manager can be
shared by different computers over the network.  They are, however,
slower than using shared memory.</p>
</dd>
</dl>
</div>
<div class="section">
<h1><a id="speed" name="speed">Speed</a></h1>
<p>Passing small objects between processes using <tt class="docutils literal"><span class="pre">processing.Queue</span></tt> is
not significantly slower than passing the same objects between threads
using <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt>.  (In fact on Linux it tends to be faster.)  One
can also use <tt class="docutils literal"><span class="pre">processing.Pipe</span></tt> which at least on Windows is quite a
bit faster than <tt class="docutils literal"><span class="pre">processing.Queue</span></tt>.</p>
<p>The following benchmarks were performed on a single core Pentium 4,
2.5Ghz laptop running Windows XP and Ubuntu Linux 6.10 --- see
<a class="reference" href="../test/test_speed.py">test_speed.py</a>.</p>
<p><em>Number of 256 bytes strings passed between processes/threads per sec</em>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="16%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Connection type</th>
<th class="head">Windows</th>
<th class="head">Linux</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Queue.Queue</td>
<td>49,000</td>
<td>17,000-50,000 <a class="footnote-reference" href="#id4" id="id1" name="id1">[1]</a></td>
</tr>
<tr><td>processing.PosixQueue</td>
<td>n/a</td>
<td>62,000 <a class="footnote-reference" href="#id5" id="id2" name="id2">[2]</a></td>
</tr>
<tr><td>processing.PipeQueue</td>
<td>27,000</td>
<td>37,000 <a class="footnote-reference" href="#id5" id="id3" name="id3">[2]</a></td>
</tr>
<tr><td>Queue managed by server</td>
<td>6,900</td>
<td>6,500</td>
</tr>
<tr><td>processing.Pipe</td>
<td>52,000</td>
<td>57,000</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id4">[1]</a></td><td>For some reason the performance of <tt class="docutils literal"><span class="pre">Queue.Queue</span></tt> is very
variable on Linux.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="id5">[2]</a></td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> <tt class="docutils literal"><span class="pre">processing.Queue</span></tt> is an alias for <tt class="docutils literal"><span class="pre">processing.PosixQueue</span></tt> if
available or <tt class="docutils literal"><span class="pre">processing.PipeQueue</span></tt>.</td></tr>
</tbody>
</table>
<p><em>Number of acquires/releases of a lock per sec</em>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Lock type</th>
<th class="head">Windows</th>
<th class="head">Linux</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>threading.Lock</td>
<td>850,000</td>
<td>560,000</td>
</tr>
<tr><td>processing.Lock</td>
<td>430,000</td>
<td>510,000</td>
</tr>
<tr><td>Lock managed by server</td>
<td>10,000</td>
<td>8,400</td>
</tr>
<tr><td>threading.RLock</td>
<td>93,000</td>
<td>76,000</td>
</tr>
<tr><td>processing.RLock</td>
<td>430,000</td>
<td>500,000</td>
</tr>
<tr><td>RLock managed by server</td>
<td>8,800</td>
<td>7,400</td>
</tr>
</tbody>
</table>
<p><em>Number of interleaved waits/notifies per sec on a
condition variable by two processes</em>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Condition type</th>
<th class="head">Windows</th>
<th class="head">Linux</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>threading.Condition</td>
<td>26,000</td>
<td>28,000</td>
</tr>
<tr><td>processing.Condition</td>
<td>22,000</td>
<td>18,000</td>
</tr>
<tr><td>Condition managed by server</td>
<td>6,600</td>
<td>6,000</td>
</tr>
</tbody>
</table>
<p><em>Number of integers retrieved from a sequence per sec</em>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Sequence type</th>
<th class="head">Windows</th>
<th class="head">Linux</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>list</td>
<td>6,000,000</td>
<td>4,800,000</td>
</tr>
<tr><td>shared memory array</td>
<td>120,000</td>
<td>110,000</td>
</tr>
<tr><td>list managed by server</td>
<td>20,000</td>
<td>17,000</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="index.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Next</a>
</div>
</body>
</html>
