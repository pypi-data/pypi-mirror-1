<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Programming guidelines</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="connection-ref.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="tests.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="programming-guidelines">
<h1 class="title">Programming guidelines</h1>
<p>There are certain guidelines and idioms which should be adhered to
when using the <tt class="docutils literal"><span class="pre">processing</span></tt> package.</p>
<div class="section">
<h1><a id="all-platforms" name="all-platforms">All platforms</a></h1>
<dl class="docutils">
<dt><em>Avoid shared state</em></dt>
<dd><p class="first">As far as possible one should try to avoid shifting large amounts
of data between processes.</p>
<p class="last">It is probably best to stick to using queues or pipes for
communication between processes rather than using the lower level
synchronization primitives from the <tt class="docutils literal"><span class="pre">threading</span></tt> module.</p>
</dd>
<dt><em>Picklability</em>:</dt>
<dd>Ensure that the arguments to the methods of proxies are
picklable.</dd>
<dt><em>Thread safety of proxies</em>:</dt>
<dd><p class="first">Do not use a proxy object from more than one thread unless you
protect it with a lock.</p>
<p>Alternatively another copy of the proxy can be created using the
<tt class="docutils literal"><span class="pre">copy.copy()</span></tt> function.</p>
<p class="last">(There is never a problem with different processes using the
'same' proxy.)</p>
</dd>
<dt><em>Catching</em> <tt class="docutils literal"><span class="pre">ProcessExit</span></tt></dt>
<dd>If a <tt class="docutils literal"><span class="pre">ProcessExit</span></tt> exception is raised in a child process
then that process should end (almost) immediately; otherwise the
<tt class="docutils literal"><span class="pre">stop()</span></tt> method will not work as expected.  Note that
<tt class="docutils literal"><span class="pre">ProcessExit</span></tt> is a subclass of <tt class="docutils literal"><span class="pre">SystemExit</span></tt>.</dd>
<dt><em>Not letting the manager die early</em></dt>
<dd>When the main process terminates any manager process it has
created will also terminate.  Make sure that no child process
still needs the manager when this happens --- the easiest way is
just to join all child processes you create.</dd>
<dt><em>Joining zombie processes</em></dt>
<dd>On Unix when a process finishes but has not been joined it becomes
a zombie.  There should never be very many because each time a new
process starts (or <tt class="docutils literal"><span class="pre">activeChildren()</span></tt> is called) all completed
processes which have not yet been joined will be joined.  Also
calling a finished process's <tt class="docutils literal"><span class="pre">isAlive()</span></tt> will join the process
will already have been joined.  Even so it is probably good
practice to explicitly join all the processes that you start.</dd>
<dt><em>Better to inherit than pickle/unpickle</em></dt>
<dd><p class="first">On Windows many of types from the <tt class="docutils literal"><span class="pre">processing</span></tt> package need to be
picklable so that child processes can use them.  However, on Unix
the following types are not picklable:</p>
<blockquote>
<tt class="docutils literal"><span class="pre">Lock</span></tt>, <tt class="docutils literal"><span class="pre">RLock</span></tt>, <tt class="docutils literal"><span class="pre">Semaphore</span></tt>, <tt class="docutils literal"><span class="pre">BoundedSemaphore</span></tt>,
<tt class="docutils literal"><span class="pre">Condition</span></tt>, <tt class="docutils literal"><span class="pre">Event</span></tt>, <tt class="docutils literal"><span class="pre">Queue</span></tt>, <tt class="docutils literal"><span class="pre">SharedValue</span></tt>,
<tt class="docutils literal"><span class="pre">SharedStruct</span></tt>, <tt class="docutils literal"><span class="pre">SharedArray</span></tt>.</blockquote>
<p class="last">For the sake of compatibility it is better not to rely on these
types being picklable.</p>
</dd>
</dl>
</div>
<div class="section">
<h1><a id="windows" name="windows">Windows</a></h1>
<p>Platforms such as Windows which lack <tt class="docutils literal"><span class="pre">os.fork()</span></tt> have a few extra
restrictions:</p>
<p><em>More picklability</em>:</p>
<blockquote>
<p>Ensure that all arguments to <tt class="docutils literal"><span class="pre">Process.__init__()</span></tt> are picklable.
This means, in particular, that bound or unbound methods cannot be
used directly as the <tt class="docutils literal"><span class="pre">target</span></tt> argument on Windows --- just define
a function and use that instead.</p>
<p>Also, if you subclass <tt class="docutils literal"><span class="pre">Process</span></tt> then make sure that instances
will be picklable when the <tt class="docutils literal"><span class="pre">start()</span></tt> method is called.</p>
</blockquote>
<dl class="docutils">
<dt><em>Global variables</em>:</dt>
<dd><p class="first">Bear in mind that if code run in a child process tries to access a
global variable, then the value it sees (if any) may not be the
same as the value in the parent process at the time that
<tt class="docutils literal"><span class="pre">start()</span></tt> was called.</p>
<p class="last">However, global variables which are just module level constants
cause no problems.</p>
</dd>
<dt><em>Safe importing of main module</em>:</dt>
<dd><p class="first">Make sure that the main module can be safely imported by a new
Python interpreter without causing unintended side effects (such a
starting a new process).</p>
<p>For example, under Windows running the following module would
recursively create new processes until you run out of memory or
get a crash:</p>
<pre class="literal-block">
from processing import Process

def foo():
    print 'hello'

p = Process(target=foo)
p.start()
</pre>
<p>Instead one should protect creation of the new process by using
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></tt> as follows:</p>
<pre class="literal-block">
from processing import Process

def foo():
    print 'hello'

if __name__ == '__main__':
    p = Process(target=foo)
    p.start()
</pre>
<p>This allows the newly spawned Python interpreter to safely import
the module and then run the module's <tt class="docutils literal"><span class="pre">foo()</span></tt> function.</p>
<p class="last">Similar restrictions apply if a pool or manager is created in the
main module.</p>
</dd>
<dt><em>Freezing</em>:</dt>
<dd><p class="first">One can produce Windows executables from a python program by using
<tt class="docutils literal"><span class="pre">py2exe</span></tt>, <tt class="docutils literal"><span class="pre">PyInstaller</span></tt>, <tt class="docutils literal"><span class="pre">cx_Freeze</span></tt> etc.  However, if the program
uses <tt class="docutils literal"><span class="pre">processing</span></tt> then one needs to call <tt class="docutils literal"><span class="pre">freezeSupport()</span></tt>
immediately after the <tt class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></tt> line of the
main module.  Otherwise one will probably get the same problems
mentioned above concerning <em>Safe importing</em>.  For example</p>
<pre class="last literal-block">
from processing import Process, freezeSupport

def foo():
    print 'hello'

if __name__ == '__main__':
    freezeSupport()
    p = Process(target=foo)
    p.start()
</pre>
</dd>
</dl>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="connection-ref.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="index.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="tests.html">Next</a>
</div>
</body>
</html>
