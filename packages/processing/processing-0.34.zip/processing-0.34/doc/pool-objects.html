<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Process Pools</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="header">
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="connection-ref.html">Next</a>
<hr class="header"/>
</div>
<div class="document" id="process-pools">
<h1 class="title">Process Pools</h1>
<p><em>XXX Experimental -- API is liable to change</em></p>
<p>The <tt class="docutils literal"><span class="pre">processing.pool</span></tt> module has one public class:</p>
<blockquote>
<dl class="docutils">
<dt><strong>class</strong> <tt class="docutils literal"><span class="pre">Pool(processes=None)</span></tt></dt>
<dd><p class="first">A class representing a pool of worker processes.</p>
<p class="last">Tasks can be offloaded to the pool and the results dealt with
when they become available.</p>
</dd>
</dl>
</blockquote>
<div class="section">
<h1><a id="pool-objects" name="pool-objects">Pool objects</a></h1>
<p><tt class="docutils literal"><span class="pre">Pool</span></tt> has the following public methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">__init__(processes=None)</span></tt></dt>
<dd>The constructor creates and starts <tt class="docutils literal"><span class="pre">processes</span></tt> worker
processes.  If <tt class="docutils literal"><span class="pre">processes</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> then <tt class="docutils literal"><span class="pre">cpuCount()</span></tt> is used
to find a default or 1 if <tt class="docutils literal"><span class="pre">cpuCount()</span></tt> raises <tt class="docutils literal"><span class="pre">NotImplemented</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">apply(func,</span> <span class="pre">args,</span> <span class="pre">kwds)</span></tt></dt>
<dd>Equivalent of the <tt class="docutils literal"><span class="pre">apply()</span></tt> builtin function.  It blocks till
the result is ready.</dd>
<dt><tt class="docutils literal"><span class="pre">apply_async(func,</span> <span class="pre">args,</span> <span class="pre">kwds)</span></tt></dt>
<dd>A variant of the <tt class="docutils literal"><span class="pre">apply()</span></tt> method which returns a
result object --- see <a class="reference" href="#asynchronous-result-objects">Asynchronous result objects</a>.</dd>
<dt><tt class="docutils literal"><span class="pre">map(func,</span> <span class="pre">iterable,</span> <span class="pre">chunksize=None)</span></tt></dt>
<dd><p class="first">A parallel equivalent of the <tt class="docutils literal"><span class="pre">map()</span></tt> builtin function.  It
blocks till the result is ready.</p>
<p class="last">This method chops the iterable into a number of chunks which
it submits to the process pool as separate tasks.  The
(maximum) size of these chunks can be specified by setting
<tt class="docutils literal"><span class="pre">chunksize</span></tt> to a positive integer.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">map_async(func,</span> <span class="pre">iterable,</span> <span class="pre">chunksize=None)</span></tt></dt>
<dd>A variant of the <tt class="docutils literal"><span class="pre">map()</span></tt> method which returns a result object
--- see <a class="reference" href="#asynchronous-result-objects">Asynchronous result objects</a>.</dd>
<dt><tt class="docutils literal"><span class="pre">imap(func,</span> <span class="pre">iterable)</span></tt></dt>
<dd><p class="first">An equivalent of <tt class="docutils literal"><span class="pre">itertools.imap()</span></tt>.</p>
<p>Note that this treats each element of the iterable as a
separate task, so for a long iterable where the function is
cheap to evaluate this likely to be <strong>much</strong> slower than using
<tt class="docutils literal"><span class="pre">map()</span></tt>.</p>
<p class="last">Also notice that the <tt class="docutils literal"><span class="pre">next(timeout=None)</span></tt> method of the
iterator returned by the <tt class="docutils literal"><span class="pre">imap()</span></tt> method has a timeout
parameter.  <tt class="docutils literal"><span class="pre">next(timeout)</span></tt> will raise
<tt class="docutils literal"><span class="pre">processing.TimeoutError</span></tt> if the result cannot be returned
with <tt class="docutils literal"><span class="pre">timeout</span></tt> seconds.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">imap_unordered(func,</span> <span class="pre">iterable)</span></tt></dt>
<dd>The same as <tt class="docutils literal"><span class="pre">imap()</span></tt> except that the ordering of the results
from the returned iterator should be considered arbitrary.
(Only when there is only one worker process is the order
guaranteed to be &quot;correct&quot;.)</dd>
<dt><tt class="docutils literal"><span class="pre">shutdown()</span></tt></dt>
<dd>Tells the worker processes to shutdown.  Gets called
automatically when the pool object is garbage collected or
when the process shuts down.</dd>
<dt><tt class="docutils literal"><span class="pre">join()</span></tt></dt>
<dd>Tells the worker processes to shutdown and waits for them to
finish.</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="asynchronous-result-objects" name="asynchronous-result-objects">Asynchronous result objects</a></h1>
<p>The result objects returns by <tt class="docutils literal"><span class="pre">apply_async()</span></tt> and <tt class="docutils literal"><span class="pre">map_async()</span></tt> have
the following public methods:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">get(timeout=None)</span></tt></dt>
<dd>Returns the result when it arrives.  If <tt class="docutils literal"><span class="pre">timeout</span></tt> is not
<tt class="docutils literal"><span class="pre">None</span></tt> and the result does not arrive within <tt class="docutils literal"><span class="pre">timeout</span></tt> seconds
then <tt class="docutils literal"><span class="pre">processing.TimeoutError</span></tt> is raised.  If the remote call
raised an exception then that exception will be reraised by <tt class="docutils literal"><span class="pre">get()</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">wait(timeout=None)</span></tt></dt>
<dd>Waits until the result is available or until <tt class="docutils literal"><span class="pre">timeout</span></tt> seconds
pass.</dd>
<dt><tt class="docutils literal"><span class="pre">ready()</span></tt></dt>
<dd>Returns whether the call has completed.</dd>
<dt><tt class="docutils literal"><span class="pre">successful()</span></tt></dt>
<dd>Returns whether the call completed without raising an
exception.  Will raise <tt class="docutils literal"><span class="pre">AssertionError</span></tt> if the result is not
ready.</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h1><a id="examples" name="examples">Examples</a></h1>
<p>The following example demonstrates the use of a pool:</p>
<pre class="literal-block">
&gt;&gt;&gt; from processing import Pool
&gt;&gt;&gt; def square(x): return x*x
...
&gt;&gt;&gt; p = Pool(4)
&gt;&gt;&gt; r = p.apply_async(square, [4])
&gt;&gt;&gt; r.ready()
True
&gt;&gt;&gt; r.successful()
True
&gt;&gt;&gt; r.get()
16
&gt;&gt;&gt; p.map(square, range(10))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; it = p.imap(square, range(10))
&gt;&gt;&gt; it.next(timeout=1)
0
&gt;&gt;&gt; it.next(timeout=1)
1
</pre>
<p>Note that on windows the example will fail because the worker
processes are not forks of the original process and they will not know
about the <tt class="docutils literal"><span class="pre">square()</span></tt> function.</p>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="proxy-objects.html">Prev</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="processing-ref.html">Up</a> &nbsp; &nbsp; &nbsp; &nbsp; <a class="reference" href="connection-ref.html">Next</a>
</div>
</body>
</html>
