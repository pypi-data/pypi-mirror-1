.. include:: header.txt

===============
 Queue objects
===============

The queue type provided by `processing` is a multi-producer,
multi-consumer FIFO queue modelled on the `Queue.Queue` class in the
standard library.

`Queue(maxsize=0)`
    Returns a process shared queue implemented using a pipe and a few
    locks/semaphores.  When a process first puts an item on the queue
    a background thread is started which transfers objects from a
    buffer into the pipe.

    `Queue.Queue` implements all the methods of `Queue.Queue` except for
    `qsize()`, `task_done()` and `join()`.

        `empty()` 
            Return `True` if the queue is empty, `False`
            otherwise. Because of multithreading/multiprocessing
            semantics, this is not reliable.

        `full()`
            Return `True` if the queue is full, `False` otherwise. Because
            of multithreading/multiprocessing semantics, this is not
            reliable.

        `put(item, block=True, timeout=None)`
            Put item into the queue. If optional args `block` is true
            and `timeout` is `None` (the default), block if necessary
            until a free slot is available. If `timeout` is a positive
            number, it blocks at most `timeout` seconds and raises the
            `Full` exception if no free slot was available within that
            time. Otherwise (`block` is false), put an item on the queue
            if a free slot is immediately available, else raise the
            `Full` exception (`timeout` is ignored in that case).

        `put_nowait(item)`
            Equivalent to `put(item, False)`. 

        `get(block=True, timeout=None)`
            Remove and return an item from the queue. If optional args
            `block` is true and `timeout` is `None` (the default),
            block if necessary until an item is available. If
            `timeout` is a positive number, it blocks at most
            `timeout` seconds and raises the `Empty` exception if no
            item was available within that time. Otherwise (block is
            false), return an item if one is immediately available,
            else raise the `Empty` exception (`timeout` is ignored in
            that case).

        `get_nowait()`
            Equivalent to `get(False)`. 

    `processing.Queue` has a few additional methods not found in
    `Queue.Queue` which are usually unnecessary:

        `putmany(iterable)` 
            If the queue has infinite size then this adds all
            items in the iterable to the queue's buffer.  So
            `q.putmany(X)` is a faster alternative to `for x in X:
            q.put(x)`.  Raises an error if the queue has finite
            size.

        `close()`
            Indicates that no more data will be put on this queue by
            the current process.  The background thread will quit once
            it has flushed all buffered data to the pipe.  This is
            called automatically when the queue is garbage collected.

        `jointhread()`
            This joins the background thread and can only be used
            after `close()` has been called.  This blocks until
            the background thread exits, ensuring that all data in
            the buffer has been flushed to the pipe.  

            By default if a process is not the creator of the
            queue then on exit it will attempt to join the queue's
            background thread.  The process can call
            `canceljoin()` to prevent this behaviour.

        `canceljoin()`
            Prevents the background thread from being joined
            automatically when the process exits.  Unnecessary if
            the current process created the queue.

.. admonition:: `Empty` and `Full`

    `processing` uses the usual `Queue.Empty` and `Queue.Full` 
    exceptions to signal a timeout.  They are not available in the 
    `processing` namespace so you need to import them from `Queue`.


.. warning::    

    If a process is killed while it is trying to use a `Queue` or
    `SimpleQueue` then the data in the queue is likely to become
    corrupted because it may become impossible to be sure where the
    message boundaries lie.


.. _Prev: process-objects.html
.. _Up: processing-ref.html
.. _Next: connection-objects.html
