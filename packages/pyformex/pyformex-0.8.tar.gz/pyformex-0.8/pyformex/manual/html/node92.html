<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="pyformex.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../favicon.ico" />
<link rel='start' href='http://pyformex.berlios.de' title='pyFormex home Page' />
<link rel="first" href="pyformex.html" title='pyFormex manual' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="next" href="node93.html" />
<link rel="prev" href="module-coords.html" />
<link rel="parent" href="module-coords.html" />
<link rel="next" href="node93.html" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name='aesop' content='information' />
<title>8.2.1 Coords class: A structured collection of 3D coordinates.</title>
</head>
<body>
<div class="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.2 coords  "
  href="module-coords.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.2 coords  "
  href="module-coords.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.2.2 functions defined in"
  href="node93.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="module-coords.html">8.2 coords  </a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-coords.html">8.2 coords  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node93.html">8.2.2 Functions defined in</a>
</div>
<hr /></div>
</div>
<!--End of Navigation Panel-->

<h2><a name="SECTION009210000000000000000">
8.2.1 Coords class: A structured collection of 3D coordinates.</a>
</h2>

<p>
The Coords class is the basic data structure used throughout pyFormex
    to store coordinates of points in a 3D space.

<p>
The <tt class="class">Coords</tt> class is used by other classes, such as <tt class="class">Formex</tt>
    and <tt class="class">Surface</tt>, which thus inherit the same transformation
    capabilities. Applications will mostly use the higher level
    classes, which usually have more elaborated consistency checking
    and error handling.

<p>
Coords is implemented as a floating point numpy (Numerical Python) array
    whose last axis has a length equal to 3.
    Each set of 3 values along the last axis thus represents a single point
    in 3D cartesian space.

<p>
The datatype should be a float type; the default is Float, which is
    equivalent to numpy's float32.
    These restrictions are currently only checked at creation time.
    It is the responsibility of the user to keep consistency. 

<p>
The Coords class has this constructor: 

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<tt id='l2h-115' xml:id='l2h-115' class="class">Coords</tt></b>(</nobr></td>
  <td><var>cls,data=None,dtyp=Float,copy=False</var>)</td></tr></table></dt>
<dd>
Create a new instance of class Coords.

<p>
If no data are given, a single point (0.,0.,0.) will be created.
        If specified, data should evaluate to an (...,3) shaped array of floats.
        If copy==True, the data are copied.
        If no dtyp is given that of data are used, or float32 by default.

<p>
</dl>

<p>
Coords objects have the following methods:

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-116' xml:id='l2h-116' class="function">points</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the data as a simple set of points.

<p>
This reshapes the array to a 2-dimensional array, flattening
        the structure of the points.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-117' xml:id='l2h-117' class="function">pshape</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the shape of the points array.

<p>
This is the shape of the Coords array with last axis removed.
        The full shape of the <tt class="class">Coords</tt> array can be obtained from
        its <var>shape</var> attribute.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-118' xml:id='l2h-118' class="function">npoints</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the total number of points.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-119' xml:id='l2h-119' class="function">x</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the x-plane
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-120' xml:id='l2h-120' class="function">y</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the y-plane
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-121' xml:id='l2h-121' class="function">z</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the z-plane
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-122' xml:id='l2h-122' class="function">bbox</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the bounding box of a set of points.

<p>
The bounding box is the smallest rectangular volume in global
        coordinates, such at no points are outside the box.
        It is returned as a Coords object with shape (2,3): the first row
        holds the minimal coordinates and the second row the maximal.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-123' xml:id='l2h-123' class="function">center</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the center of the Coords.

<p>
The center of a Coords is the center of its bbox().
        The return value is a (3,) shaped Coords object.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-124' xml:id='l2h-124' class="function">centroid</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the centroid of the Coords.

<p>
The centroid of a Coords is the point whose coordinates
        are the mean values of all points.
        The return value is a (3,) shaped Coords object.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-125' xml:id='l2h-125' class="function">sizes</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the sizes of the Coords.

<p>
Return an array with the length of the bbox along the 3 axes.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-126' xml:id='l2h-126' class="function">dsize</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return an estimate of the global size of the Coords.

<p>
This estimate is the length of the diagonal of the bbox().
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-127' xml:id='l2h-127' class="function">bsphere</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the diameter of the bounding sphere of the Coords.

<p>
The bounding sphere is the smallest sphere with center in the
        center() of the Coords, and such that no points of the Coords
        are lying outside the sphere.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-128' xml:id='l2h-128' class="function">distanceFromPlane</tt></b>(</nobr></td>
  <td><var>p,n</var>)</td></tr></table></dt>
<dd>
Return the distance of points f from the plane (p,n).

<p>
p is a point specified by 3 coordinates.
        n is the normal vector to a plane, specified by 3 components.

<p>
The return value is a [...] shaped array with the distance of
        each point to the plane through p and having normal n.
        Distance values are positive if the point is on the side of the
        plane indicated by the positive normal.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-129' xml:id='l2h-129' class="function">distanceFromLine</tt></b>(</nobr></td>
  <td><var>p,n</var>)</td></tr></table></dt>
<dd>
Return the distance of points f from the line (p,n).

<p>
p is a point on the line specified by 3 coordinates.
        n is a vector specifying the direction of the line through p.

<p>
The return value is a [...] shaped array with the distance of
        each point to the line through p with direction n.
        All distance values are positive or zero.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-130' xml:id='l2h-130' class="function">distanceFromPoint</tt></b>(</nobr></td>
  <td><var>p</var>)</td></tr></table></dt>
<dd>
Return the distance of points f from the point p.

<p>
p is a single point specified by 3 coordinates.

<p>
The return value is a [...] shaped array with the distance of
        each point to point p.
        All distance values are positive or zero.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-131' xml:id='l2h-131' class="function">test</tt></b>(</nobr></td>
  <td><var>dir=0,min=None,max=None,atol=0.</var>)</td></tr></table></dt>
<dd>
Flag points having coordinates between min and max.

<p>
This function is very convenient in clipping a Coords in a specified
        direction. It returns a 1D integer array flagging (with a value 1 or
        True) the elements having nodal coordinates in the required range.
        Use where(result) to get a list of element numbers passing the test.
        Or directly use clip() or cclip() to create the clipped Coords.

<p>
The test plane can be define in two ways depending on the value of dir.
        If dir == 0, 1 or 2, it specifies a global axis and min and max are
        the minimum and maximum values for the coordinates along that axis.
        Default is the 0 (or x) direction.

<p>
Else, dir should be compatible with a (3,) shaped array and specifies
        the direction of the normal on the planes. In this case, min and max
        are points and should also evaluate to (3,) shaped arrays.

<p>
One of the two clipping planes may be left unspecified.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-132' xml:id='l2h-132' class="function">fprint</tt></b>(</nobr></td>
  <td><var>fmt="%10.3e %10.3e %10.3e"</var>)</td></tr></table></dt>
<dd>
Formatted printing of a Coords.

<p>
The supplied format should contain 3 formatting sequences for the
        three coordinates of a point.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-133' xml:id='l2h-133' class="function">set</tt></b>(</nobr></td>
  <td><var>f</var>)</td></tr></table></dt>
<dd>
Set the coordinates from those in the given array.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-134' xml:id='l2h-134' class="function">scale</tt></b>(</nobr></td>
  <td><var>scale,dir=None,inplace=False</var>)</td></tr></table></dt>
<dd>
Return a copy scaled with scale[i] in direction i.

<p>
The scale should be a list of 3 scaling factors for the 3 axis
        directions, or a single scaling factor.
        In the latter case, dir (a single axis number or a list) may be given
        to specify the direction(s) to scale. The default is to produce a
        homothetic scaling.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-135' xml:id='l2h-135' class="function">translate</tt></b>(</nobr></td>
  <td><var>vector,distance=None,inplace=False</var>)</td></tr></table></dt>
<dd>
Translate a Coords object.

<p>
The translation vector can be specified in one of the following ways:
        - an axis number (0,1,2),
        - a single translation vector,
        - an array of translation vectors.
        If an axis number is given, a unit vector in the direction of the
        specified axis will be used.
        If an array of translation vectors is given, it should be
        broadcastable to the size of the Coords array.
        If a distance value is given, the translation vector is multiplied
        with this value before it is added to the coordinates.

<p>
Thus, the following are all equivalent:
          F.translate(1)
          F.translate(1,1)
          F.translate([0,1,0])
          F.translate([0,2,0],0.5)

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-136' xml:id='l2h-136' class="function">rotate</tt></b>(</nobr></td>
  <td><var>angle,axis=2,around=None,inplace=False</var>)</td></tr></table></dt>
<dd>
Return a copy rotated over angle around axis.

<p>
The angle is specified in degrees.
        The axis is either one of (0,1,2) designating the global axes,
        or a vector specifying an axis through the origin.
        If no axis is specified, rotation is around the 2(z)-axis. This is
        convenient for working on 2D-structures.

<p>
As a convenience, the user may also specify a 3x3 rotation matrix,
        in which case the function rotate(mat) is equivalent to affine(mat).

<p>
All rotations are performed around the point [0,0,0], unless a
        rotation origin is specified in the argument 'around'. 

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-137' xml:id='l2h-137' class="function">shear</tt></b>(</nobr></td>
  <td><var>dir,dir1,skew,inplace=False</var>)</td></tr></table></dt>
<dd>
Return a copy skewed in the direction dir of plane (dir,dir1).

<p>
The coordinate dir is replaced with (dir + skew * dir1).

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-138' xml:id='l2h-138' class="function">reflect</tt></b>(</nobr></td>
  <td><var>dir=2,pos=0,inplace=False</var>)</td></tr></table></dt>
<dd>
Mirror the coordinates in direction dir against plane at pos.

<p>
Default position of the plane is through the origin.
        Default mirror direction is the z-direction.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-139' xml:id='l2h-139' class="function">affine</tt></b>(</nobr></td>
  <td><var>mat,vec=None,inplace=False</var>)</td></tr></table></dt>
<dd>
Return a general affine transform of the Coords.

<p>
The returned Coords has coordinates given by xorig * mat + vec,
        where mat is a 3x3 matrix and vec a length 3 list.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-140' xml:id='l2h-140' class="function">cylindrical</tt></b>(</nobr></td>
  <td><var>dir=[0,1,2],scale=[1.,1.,1.]</var>)</td></tr></table></dt>
<dd>
Converts from cylindrical to cartesian after scaling.

<p>
dir specifies which coordinates are interpreted as resp.
        distance(r), angle(theta) and height(z). Default order is [r,theta,z].
        scale will scale the coordinate values prior to the transformation.
        (scale is given in order r,theta,z).
        The resulting angle is interpreted in degrees.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-141' xml:id='l2h-141' class="function">toCylindrical</tt></b>(</nobr></td>
  <td><var>dir=[0,1,2]</var>)</td></tr></table></dt>
<dd>
Converts from cartesian to cylindrical coordinates.

<p>
dir specifies which coordinates axes are parallel to respectively the
        cylindrical axes distance(r), angle(theta) and height(z). Default
        order is [x,y,z].
        The angle value is given in degrees.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-142' xml:id='l2h-142' class="function">spherical</tt></b>(</nobr></td>
  <td><var>dir=[0,1,2],scale=[1.,1.,1.],colat=False</var>)</td></tr></table></dt>
<dd>
Converts from spherical to cartesian after scaling.

<p>
&lt;dir&gt; specifies which coordinates are interpreted as resp.
        longitude(theta), latitude(phi) and distance(r).
        &lt;scale&gt; will scale the coordinate values prior to the transformation.
        Angles are then interpreted in degrees.
        Latitude, i.e. the elevation angle, is measured from equator in
        direction of north pole(90). South pole is -90.
        If colat=True, the third coordinate is the colatitude (90-lat) instead.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-143' xml:id='l2h-143' class="function">superSpherical</tt></b>(</nobr></td>
  <td><var>n=1.0,e=1.0,k=0.0,dir=[0,1,2],scale=[1.,1.,1.],colat=False</var>)</td></tr></table></dt>
<dd>
Performs a superspherical transformation.

<p>
superSpherical is much like spherical, but adds some extra
        parameters to enable the creation of virtually any surface.

<p>
Just like with spherical(), the input coordinates are interpreted as
        the longitude, latitude and distance in a spherical coordinate system.
        &lt;dir&gt; specifies which coordinates are interpreted as resp.
        longitude(theta), latitude(phi) and distance(r).
        Angles are then interpreted in degrees.
        Latitude, i.e. the elevation angle, is measured from equator in
        direction of north pole(90). South pole is -90.
        If colat=True, the third coordinate is the colatitude (90-lat) instead.
        &lt;scale&gt; will scale the coordinate values prior to the transformation.

<p>
The n and e parameters define exponential transformations of the
        north_south (latitude), resp. the east_west (longitude) coordinates.
        Default values of 1 result in a circle.

<p>
k adds 'eggness' to the shape: a difference between the northern and
        southern hemisphere. Values &gt; 0 enlarge the southern hemishpere and
        shrink the northern.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-144' xml:id='l2h-144' class="function">toSpherical</tt></b>(</nobr></td>
  <td><var>dir=[0,1,2]</var>)</td></tr></table></dt>
<dd>
Converts from cartesian to spherical coordinates.

<p>
dir specifies which coordinates axes are parallel to respectively
        the spherical axes distance(r), longitude(theta) and latitude(phi).
        Latitude is the elevation angle measured from equator in direction
        of north pole(90). South pole is -90.
        Default order is [0,1,2], thus the equator plane is the (x,y)-plane.
        The returned angle values are given in degrees.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-145' xml:id='l2h-145' class="function">bump1</tt></b>(</nobr></td>
  <td><var>dir,a,func,dist</var>)</td></tr></table></dt>
<dd>
Return a Coords with a one-dimensional bump.

<p>
dir specifies the axis of the modified coordinates;
        a is the point that forces the bumping;
        dist specifies the direction in which the distance is measured;
        func is a function that calculates the bump intensity from distance
        !! func(0) should be different from 0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-146' xml:id='l2h-146' class="function">bump2</tt></b>(</nobr></td>
  <td><var>dir,a,func</var>)</td></tr></table></dt>
<dd>
Return a Coords with a two-dimensional bump.

<p>
dir specifies the axis of the modified coordinates;
        a is the point that forces the bumping;
        func is a function that calculates the bump intensity from distance
        !! func(0) should be different from 0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-147' xml:id='l2h-147' class="function">bump</tt></b>(</nobr></td>
  <td><var>dir,a,func,dist=None</var>)</td></tr></table></dt>
<dd>
Return a Coords with a bump.

<p>
A bump is a modification of a set of coordinates by a non-matching
        point. It can produce various effects, but one of the most common
        uses is to force a surface to be indented by some point.

<p>
dir specifies the axis of the modified coordinates;
        a is the point that forces the bumping;
        func is a function that calculates the bump intensity from distance
        (!! func(0) should be different from 0)
        dist is the direction in which the distance is measured : this can
        be one of the axes, or a list of one or more axes.
        If only 1 axis is specified, the effect is like function bump1
        If 2 axes are specified, the effect is like bump2
        This function can take 3 axes however.
        Default value is the set of 3 axes minus the direction of modification.
        This function is then equivalent to bump2.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-148' xml:id='l2h-148' class="function">newmap</tt></b>(</nobr></td>
  <td><var>func</var>)</td></tr></table></dt>
<dd>
Return a Coords mapped by a 3-D function.

<p>
This is one of the versatile mapping functions.
        func is a numerical function which takes three arguments and produces
        a list of three output values. The coordinates [x,y,z] will be
        replaced by func(x,y,z).
        The function must be applicable to arrays, so it should
        only include numerical operations and functions understood by the
        numpy module.
        This method is one of several mapping methods. See also map1 and mapd.
        Example: E.map(lambda x,y,z: [2*x,3*y,4*z])
        is equivalent with E.scale([2,3,4])

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-149' xml:id='l2h-149' class="function">map</tt></b>(</nobr></td>
  <td><var>func</var>)</td></tr></table></dt>
<dd>
Return a Coords mapped by a 3-D function.

<p>
This is one of the versatile mapping functions.
        func is a numerical function which takes three arguments and produces
        a list of three output values. The coordinates [x,y,z] will be
        replaced by func(x,y,z).
        The function must be applicable to arrays, so it should
        only include numerical operations and functions understood by the
        numpy module.
        This method is one of several mapping methods. See also map1 and mapd.
        Example: E.map(lambda x,y,z: [2*x,3*y,4*z])
        is equivalent with E.scale([2,3,4])

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-150' xml:id='l2h-150' class="function">map1</tt></b>(</nobr></td>
  <td><var>dir,func,x=None</var>)</td></tr></table></dt>
<dd>
Return a Coords where coordinate i is mapped by a 1-D function.

<p>
&lt;func&gt; is a numerical function which takes one argument and produces
        one result. The coordinate dir will be replaced by func(coord[x]).
        If no x is specified, x is taken equal to dir. 
        The function must be applicable on arrays, so it should only
        include numerical operations and functions understood by the
        numpy module.
        This method is one of several mapping methods. See also map and mapd.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-151' xml:id='l2h-151' class="function">mapd</tt></b>(</nobr></td>
  <td><var>dir,func,point,dist=None</var>)</td></tr></table></dt>
<dd>
Maps one coordinate by a function of the distance to a point.

<p>
&lt;func&gt; is a numerical function which takes one argument and produces
        one result. The coordinate dir will be replaced by func(d), where &lt;d&gt;
        is calculated as the distance to &lt;point&gt;.
        The function must be applicable on arrays, so it should only
        include numerical operations and functions understood by the
        numpy module.
        By default, the distance d is calculated in 3-D, but one can specify
        a limited set of axes to calculate a 2-D or 1-D distance.
        This method is one of several mapping methods. See also map3 and map1.
        Example: E.mapd(2,lambda d:sqrt(10**2-d**2),f.center(),[0,1])
        maps E on a sphere with radius 10

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-152' xml:id='l2h-152' class="function">egg</tt></b>(</nobr></td>
  <td><var>k</var>)</td></tr></table></dt>
<dd>
Maps the coordinates to an egg-shape
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-153' xml:id='l2h-153' class="function">replace</tt></b>(</nobr></td>
  <td><var>i,j,other=None</var>)</td></tr></table></dt>
<dd>
Replace the coordinates along the axes i by those along j.

<p>
i and j are lists of axis numbers or single axis numbers.
        replace ([0,1,2],[1,2,0]) will roll the axes by 1.
        replace ([0,1],[1,0]) will swap axes 0 and 1.
        An optionally third argument may specify another Coords object to take
        the coordinates from. It should have the same dimensions.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-154' xml:id='l2h-154' class="function">swapAxes</tt></b>(</nobr></td>
  <td><var>i,j</var>)</td></tr></table></dt>
<dd>
Swap coordinate axes i and j.

<p>
Beware! This is different from numpy's swapaxes() method !

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-155' xml:id='l2h-155' class="function">rollAxes</tt></b>(</nobr></td>
  <td><var>n=1</var>)</td></tr></table></dt>
<dd>
Roll the axes over the given amount.

<p>
Default is 1, thus axis 0 becomes the new 1 axis, 1 becomes 2 and
        2 becomes 0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-156' xml:id='l2h-156' class="function">projectOnSphere</tt></b>(</nobr></td>
  <td><var>radius=1.,center=[0.,0.,0.]</var>)</td></tr></table></dt>
<dd>
Project Coords on a sphere.

<p>
The default sphere is a unit sphere at the origin.
        The center of the sphere should not be part of the Coords.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-157' xml:id='l2h-157' class="function">projectOnCylinder</tt></b>(</nobr></td>
  <td><var>radius=1.,dir=0,center=[0.,0.,0.]</var>)</td></tr></table></dt>
<dd>
Project Coords on a cylinder with axis parallel to a global axis.

<p>
The default cylinder has its axis along the x-axis and a unit radius.
        No points of the Coords should belong to the axis..

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-158' xml:id='l2h-158' class="function">split</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Split the coordinate array in blocks along first axis.

<p>
The result is a sequence of arrays with shape self.shape[1:].
        Raises an error if self.ndim &lt; 2.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-159' xml:id='l2h-159' class="function">fuse</tt></b>(</nobr></td>
  <td><var>nodesperbox=1,shift=0.5,rtol=1.e-5,atol=1.e-5</var>)</td></tr></table></dt>
<dd>
Find (almost) identical nodes and return a compressed set.

<p>
This method finds the points that are very close and replaces them
        with a single point. The return value is a tuple of two arrays:
        - the unique points as a Coords object,
        - an integer (nnod) array holding an index in the unique
        coordinates array for each of the original nodes. This index will
        have the same shape as the pshape() of the coords array.

<p>
The procedure works by first dividing the 3D space in a number of
        equally sized boxes, with a mean population of nodesperbox.
        The boxes are numbered in the 3 directions and a unique integer scalar
        is computed, that is then used to sort the nodes.
        Then only nodes inside the same box are compared on almost equal
        coordinates, using the numpy allclose() function. Two coordinates are
        considered close if they are within a relative tolerance rtol or absolute
        tolerance atol. See numpy for detail. The default atol is set larger than
        in numpy, because pyformex typically runs with single precision.
        Close nodes are replaced by a single one.

<p>
Currently the procedure does not guarantee to find all close nodes:
        two close nodes might be in adjacent boxes. The performance hit for
        testing adjacent boxes is rather high, and the probability of separating
        two close nodes with the computed box limits is very small. Nevertheless
        we intend to access this problem by repeating the procedure with the
        boxes shifted in space.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-160' xml:id='l2h-160' class="function">concatenate</tt></b>(</nobr></td>
  <td><var>cls,L</var>)</td></tr></table></dt>
<dd>
Concatenate a list of Coords object.

<p>
All Coords object in the list L should have the same shape
        except for the length of the first axis.
        This function is equivalent to the numpy concatenate, but makes
        sure the result is a Coords object.

<p>
<em>This is a class method, not an instance method.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-161' xml:id='l2h-161' class="function">fromfile</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Read a Coords from file.

<p>
This convenience function uses the numpy fromfile function to read
        the coordinates from file.
        You just have to make sure that the coordinates are read in order
        (X,Y,Z) for subsequent points, and that the total number of
        coordinates read is a multiple of 3.

<p>
<em>This is a class method, not an instance method.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-162' xml:id='l2h-162' class="function">interpolate</tt></b>(</nobr></td>
  <td><var>clas,F,G,div</var>)</td></tr></table></dt>
<dd>
Create interpolations between two Coords.

<p>
F and G are two Coords with the same shape.
        v is a list of floating point values.
        The result is the concatenation of the interpolations of F and G at all
        the values in div.
        An interpolation of F and G at value v is a Coords H where each
        coordinate Hijk is obtained from:  Hijk = Fijk + v * (Gijk-Fijk).
        Thus, a Coords interpolate(F,G,[0.,0.5,1.0]) will contain all points of
        F and G and all points with mean coordinates between those of F and G.

<p>
As a convenience, if an integer is specified for div, it is taken as a
        number of divisions for the interval [0..1].
        Thus, interpolate(F,G,n) is equivalent with
        interpolate(F,G,arange(0,n+1)/float(n))

<p>
The resulting Coords array has an extra axis (the first). Its shape is
        (n,) + F.shape, where n is the number of divisions.

<p>
<em>This is a class method, not an instance method.</em>
</dl>

<p>

<div class="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.2 coords  "
  href="module-coords.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.2 coords  "
  href="module-coords.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.2.2 functions defined in"
  href="node93.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="module-coords.html">8.2 coords  </a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-coords.html">8.2 coords  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node93.html">8.2.2 Functions defined in</a>
</div>
</div>
<hr />
<span class="release-info">Release 0.8-a1, documentation updated on 9 June 2009.</span>
</div>
<!--End of Navigation Panel-->

</body>
</html>
