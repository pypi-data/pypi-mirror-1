<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="pyformex.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../favicon.ico" />
<link rel='start' href='http://pyformex.berlios.de' title='pyFormex home Page' />
<link rel="first" href="pyformex.html" title='pyFormex manual' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="prev" href="node89.html" />
<link rel="parent" href="module-formex.html" />
<link rel="next" href="module-coords.html" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name='aesop' content='information' />
<title>8.1.14 Non-member functions</title>
</head>
<body>
<div class="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.1.13 write to file,"
  href="node89.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.1 formex  "
  href="module-formex.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.2 coords  "
  href="module-coords.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node89.html">8.1.13 Write to file,</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-formex.html">8.1 formex  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="module-coords.html">8.2 coords  </a>
</div>
<hr /></div>
</div>
<!--End of Navigation Panel-->

<h2><a name="SECTION0091140000000000000000">
8.1.14 Non-member functions</a>
</h2>
The following functions operate on or return Formex objects, but are not part of the Formex class.<a name="tex2html50"
  href="#foot2832"><sup>8.2</sup></a>
<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-102' xml:id='l2h-102' class="function">connect</tt></b>(</nobr></td>
  <td><var>Flist,nodid=None,bias=None,loop=False</var>)</td></tr></table></dt>
<dd>
Return a Formex which connects the formices in <var>Flist</var>.

<p>
<var>Flist</var> is a list of formices, <var>nodid</var> is an optional list of nod ids and <var>bias</var> is an optional list of element bias values. All lists should have the same length. The returned Formex has a plexitude equal to the number of formices in <var>Flist</var>. Each element of the Formex consist of a node from the corresponding element of each of the Formices in <var>Flist</var>. By default this will be the first node of that element, but a <var>nodid</var> list may be given to specify the node ids to be used for each of the formices. Finally, a list of bias values may be given to specify an offset in element number for the subsequent Formices.

<p>
If <var>loop</var> is False, the length of the Formex will be the minimum length of the formices in <var>Flist</var>, each minus its respective bias. By setting <var>loop</var> True however, each Formex will loop around when its end is encountered, and the length of the resulting Formex is the maximum length in <var>Flist</var>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-103' xml:id='l2h-103' class="function">interpolate</tt></b>(</nobr></td>
  <td><var>F,G,div,swap=False</var>)</td></tr></table></dt>
<dd>
Create interpolations between two formices.

<p>
<var>F</var> and <var>G</var> are two Formices with the same shape.
<var>v</var> is a list of floating point values.
The result is the concatenation of the interpolations of <var>F</var> and <var>G</var> at all the values in <var>div</var>.

<p>
An interpolation of <var>F</var> and <var>G</var> at value <var>v</var> is a Formex <var>H</var> where each coordinate <var>Hijk</var> is obtained from  <tt><small class="SMALL">Hijk = Fijk + v * (Gijk-Fijk)</small></tt>.
Thus, a Formex <tt><small class="SMALL">interpolate(F,G,[0.,0.5,1.0])</small></tt> will contain all elements
of <var>F</var> and <var>G</var> and all elements with mean coordinates between those of <var>F</var> and <var>G</var>.

<p>
As a convenience, if an integer is specified for <var>div</var>, it is taken as a
number of division for the interval [0..1].
Thus, <tt><small class="SMALL">interpolate(F,G,n)</small></tt> is equivalent with
<tt><small class="SMALL">interpolate(F,G,arange(0,n+1)/float(n))</small></tt>

<p>
The swap argument sets the order of the elements in the resulting Formex.
By default, if <span class="MATH"><IMG
 WIDTH="13" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></span> interpolations are created of an <span class="MATH"><IMG
 WIDTH="18" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="$m$"></span>-element Formex, the element order is in-Formex first (<span class="MATH"><IMG
 WIDTH="13" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></span> sequences of <span class="MATH"><IMG
 WIDTH="18" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="$m$"></span> elements).
If <tt><small class="SMALL">swap==True</small></tt>, the order is swapped and you get <span class="MATH"><IMG
 WIDTH="18" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="$m$"></span> sequences of <span class="MATH"><IMG
 WIDTH="13" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></span>
interpolations.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-104' xml:id='l2h-104' class="function">readfile</tt></b>(</nobr></td>
  <td><var>file,sep=',',plexitude=1,dimension=3</var>)</td></tr></table></dt>
<dd>
Read a Formex from file.

<p>
This convenience function uses the numpy fromfile function to read the coordinates of a Formex from file. 

<p>
<var>file</var> is either an open file object or a string with the name of the file to be read.
<var>sep</var> is the separator string between subsequent coordinates. There can be extra blanks around the separator, and the separator can be omitted at the end of line. If an empty string is specified, the file is read in binary mode.

<p>
The file is read as a single stream of coordinates; the arguments <var>plexitude</var> and <var>dimension</var> determine how these are structured into a Formex.
<var>plexitude</var> is the number of points that make up an element. The default is to return a plex-1 Formex (unconnected points).
<var>dimension</var> is the number of coordinates that make up a point (2 or 3). As always, the resulting Formex will be 3D.
The total number of coordinates on the file should be a multiple of <tt><small class="SMALL">plexitude * dimension</small></tt>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-105' xml:id='l2h-105' class="function">vectorPairAreaNormals</tt></b>(</nobr></td>
  <td><var>vec1,vec2</var>)</td></tr></table></dt>
<dd>
Compute area of and normals on parallellograms formed by two vectors.

<p>
<var>vec1</var> and <var>vec2</var> are (n,3)-shaped arrays holding collections of vectors. 
The result is a tuple of two arrays:

<ul>
<li><var>area</var>, with shape (n): the area of the parallellogram formed by corresponding vectors of <var>vec1</var> and <var>vec2</var>.
</li>
<li><var>normal</var>, with shape (n,3): unit-length normal vectors to each pair of vectors. The positive direction of the normals is thus that a rotation of <var>vec1</var> to <var>vec2</var> corresponds to a positive rotation around the normal.
</li>
</ul>
Both values are calculated from the cross prduct of <var>vec1</var> and <var>vec2</var>, which indeed results in <var>area</var> * <var>normal</var>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-106' xml:id='l2h-106' class="function">vectorPairArea</tt></b>(</nobr></td>
  <td><var>vec1,vec2</var>)</td></tr></table></dt>
<dd>
Compute the area of the parallellogram formed by two vectors.

<p>
This returns the first part of <tt><small class="SMALL">vectorPairAreaNormals(vec1,vec2)</small></tt>.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-107' xml:id='l2h-107' class="function">vectorPairNormals</tt></b>(</nobr></td>
  <td><var>vec1,vec2,normalized=True</var>)</td></tr></table></dt>
<dd>
Compute the normal vectors to pairs of two vectors.

<p>
With <tt><small class="SMALL">normalized=True</small></tt>, this returns the second part of <tt><small class="SMALL">vectorPairAreaNormals(vec1,vec2)</small></tt>.

<p>
With <tt><small class="SMALL">normalized=False</small></tt>, returns unnormalized normal vectors. This does not use the <tt><small class="SMALL">vectorPairAreaNormals</small></tt> function and is provided only to save computing time with very large arrays when normalization is not required. It is equivalent to <tt><small class="SMALL">cross(vec1,vec2)</small></tt>.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-108' xml:id='l2h-108' class="function">def polygonNormals</tt></b>(</nobr></td>
  <td><var>x</var>)</td></tr></table></dt>
<dd>
    Compute normals in all points of polygons in <var>x</var>.

<p>
<var>x</var> is an <tt><small class="SMALL">(nel,nplex,3)</small></tt> coordinate array representing a (possibly not plane)
    polygon.

<p>
The return value is an <tt><small class="SMALL">(nel,nplex,3)</small></tt> array with the unit normals on the
    two edges ending in each point.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-109' xml:id='l2h-109' class="function">pattern</tt></b>(</nobr></td>
  <td><var>s</var>)</td></tr></table></dt>
<dd>
Return a line segment pattern created from a string.

<p>
This function creates a list of line segments where all nodes lie on the gridpoints of a regular grid with unit step.
The first point of the list is [0,0,0]. Each character from the given string is interpreted as a code specifying how to move to the next node.
<br>
Currently defined are the following codes:
<br>
0 = goto origin [0,0,0]
<br>
1..8 move in the x,y plane
<br>
9 remains at the same place
<br>
When looking at the plane with the x-axis to the right,
<br>
1 = East, 2 = North, 3 = West, 4 = South, 5 = NE, 6 = NW, 7 = SW, 8 = SE.
<br>
Adding 16 to the ordinal of the character causes an extra move of +1 in the z-direction. Adding 48 causes an extra move of -1. This means that 'ABCDEFGHI', resp. 'abcdefghi', correspond with '123456789' with an extra z +/-= 1. This gives the following schema:
<div class="verbatim"><pre>
                 z+=1             z unchanged            z -= 1
            
             F    B    E          6    2    5         f    b    e 
                  |                    |                   |     
                  |                    |                   |     
             C----I----A          3----9----1         c----i----a  
                  |                    |                   |     
                  |                    |                   |     
             G    D    H          7    4    8         g    d    h
</pre></div>             
The special character '<code>\</code>' can be put before any character to make the move without making a connection. The effect of any other character is undefined. The resulting list is directly suited to initialize a Formex.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-110' xml:id='l2h-110' class="function">translationVector</tt></b>(</nobr></td>
  <td><var>dir,dist</var>)</td></tr></table></dt>
<dd>
    Return a translation vector in direction dir over distance dist
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-111' xml:id='l2h-111' class="function">rotationMatrix</tt></b>(</nobr></td>
  <td><var>angle,axis=None</var>)</td></tr></table></dt>
<dd>
    Return a rotation matrix over angle, optionally around axis.

<p>
The angle is specified in degrees.
    If axis==None (default), a 2x2 rotation matrix is returned.
    Else, axis should be one of [ 0,1,2] and specifies the rotation axis
    in a 3D world. A 3x3 rotation matrix is returned.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-112' xml:id='l2h-112' class="function">rotationAboutMatrix</tt></b>(</nobr></td>
  <td><var>angle,axis</var>)</td></tr></table></dt>
<dd>
    Return a rotation matrix over angle around an axis thru the origin.

<p>
The angle is specified in degrees.
    Axis is a list of three components specifying the axis.
    The result is a 3x3 rotation matrix in list format.
    Note that:
      rotationAboutMatrix(angle,[1,0,0]) == rotationMatrix(angle,0) 
      rotationAboutMatrix(angle,[0,1,0]) == rotationMatrix(angle,1) 
      rotationAboutMatrix(angle,[0,0,1]) == rotationMatrix(angle,2)
    but the latter functions are more efficient.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-113' xml:id='l2h-113' class="function">equivalence</tt></b>(</nobr></td>
  <td><var>x,nodesperbox=1,shift=0.5,rtol=1.e-5,atol=1.e-5</var>)</td></tr></table></dt>
<dd>
    Finds (almost) identical nodes and returns a compressed list.

<p>
The input x is an (nnod,3) array of nodal coordinates. This functions finds
    the nodes that are very close and replaces them with a single node.
    The return value is a tuple of two arrays: the remaining (nunique,3) nodal
    coordinates, and an integer (nnod) array holding an index in the unique
    coordinates array for each of the original nodes.

<p>
The procedure works by first dividing the 3D space in a number of
    equally sized boxes, with a mean population of nodesperbox.
    The boxes are numbered in the 3 directions and a unique integer scalar
    is computed, that is then used to sort the nodes.
    Then only nodes inside the same box are compared on almost equal
    coordinates, using the numpy allclose() function. Two coordinates are
    considered close if they are within a relative tolerance rtol or absolute
    tolerance atol. See numpy for detail. The default atol is set larger than
    in numpy, because pyformex typically runs with single precision.
    Close nodes are replaced by a single one.

<p>
Currently the procedure does not guarantee to find all close nodes:
    two close nodes might be in adjacent boxes. The performance hit for
    testing adjacent boxes is rather high, and the probability of separating
    two close nodes with the computed box limits is very small. Nevertheless
    we intend to access this problem by repeating the procedure with the
    boxes shifted in space.
</dl>

<p>

<p>
<br><hr><h4>Footnotes</h4>
<dl>
<dt><a name="foot2832">... class.</a><A
 HREF="node90.html#tex2html50"><sup>8.2</sup></a></dt>
<dd>They might be implemented as class methods in future releases.

</dd>
</dl>
<div class="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.1.13 write to file,"
  href="node89.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.1 formex  "
  href="module-formex.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.2 coords  "
  href="module-coords.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node89.html">8.1.13 Write to file,</a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-formex.html">8.1 formex  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="module-coords.html">8.2 coords  </a>
</div>
</div>
<hr />
<span class="release-info">Release 0.8-a1, documentation updated on 9 June 2009.</span>
</div>
<!--End of Navigation Panel-->

</body>
</html>
