<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="pyformex.css" type='text/css' />
<link rel="SHORTCUT ICON" href="../favicon.ico" />
<link rel='start' href='http://pyformex.berlios.de' title='pyFormex home Page' />
<link rel="first" href="pyformex.html" title='pyFormex manual' />
<link rel='last' href='about.html' title='About this document...' />
<link rel='help' href='about.html' title='About this document...' />
<link rel="next" href="node188.html" />
<link rel="prev" href="module-surface.html" />
<link rel="parent" href="module-surface.html" />
<link rel="next" href="node188.html" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name='aesop' content='information' />
<title>8.22.1 TriSurface class: A class for handling triangulated 3D surfaces.</title>
</head>
<body>
<div class="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.22 surface  "
  href="module-surface.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.22 surface  "
  href="module-surface.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.22.2 functions defined in"
  href="node188.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="module-surface.html">8.22 surface  </a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-surface.html">8.22 surface  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node188.html">8.22.2 Functions defined in</a>
</div>
<hr /></div>
</div>
<!--End of Navigation Panel-->

<h2><a name="SECTION0092210000000000000000">
8.22.1 TriSurface class: A class for handling triangulated 3D surfaces.</a>
</h2>

<p>
The TriSurface class has this constructor: 

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<tt id='l2h-663' xml:id='l2h-663' class="class">TriSurface</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Create a new surface.

<p>
The surface contains ntri triangles, each having 3 vertices with
        3 coordinates.
        The surface can be initialized from one of the following:
        - a (ntri,3,3) shaped array of floats ;
        - a 3-plex Formex with ntri elements ;
        - an (ncoords,3) float array of vertex coordinates and
          an (ntri,3) integer array of vertex numbers ;
        - an (ncoords,3) float array of vertex coordinates,
          an (nedges,2) integer array of vertex numbers,
          an (ntri,3) integer array of edges numbers.

<p>
Internally, the surface is stored in a (coords,edges,faces) tuple.

<p>
</dl>

<p>
TriSurface objects have the following methods:

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-664' xml:id='l2h-664' class="function">getElems</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Get the elems data.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-665' xml:id='l2h-665' class="function">setElems</tt></b>(</nobr></td>
  <td><var>elems</var>)</td></tr></table></dt>
<dd>
Change the elems data.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-666' xml:id='l2h-666' class="function">refresh</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Make the internal information consistent and complete.

<p>
This function should be called after one of the data fields
        have been changed.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-667' xml:id='l2h-667' class="function">compress</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Remove all nodes which are not used.

<p>
Normally, the surface definition can hold nodes that are not
        used in the edge/facet tables. They do however influence the
        bounding box of the surface.
        This method will remove all the unconnected nodes.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-668' xml:id='l2h-668' class="function">append</tt></b>(</nobr></td>
  <td><var>S</var>)</td></tr></table></dt>
<dd>
Merge another surface with self.

<p>
This just merges the data sets, and does not check
        whether the surfaces intersect or are connected!
        This is intended mostly for use inside higher level functions.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-669' xml:id='l2h-669' class="function">ncoords</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-670' xml:id='l2h-670' class="function">nedges</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-671' xml:id='l2h-671' class="function">nfaces</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-672' xml:id='l2h-672' class="function">nplex</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-673' xml:id='l2h-673' class="function">ndim</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-674' xml:id='l2h-674' class="function">vertices</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-675' xml:id='l2h-675' class="function">shape</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the number of ;points, edges, faces of the TriSurface.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-676' xml:id='l2h-676' class="function">copy</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return a (deep) copy of the surface.

<p>
If an index is given, only the specified faces are retained.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-677' xml:id='l2h-677' class="function">select</tt></b>(</nobr></td>
  <td><var>idx,compress=True</var>)</td></tr></table></dt>
<dd>
Return a TriSurface which holds only elements with numbers in ids.

<p>
idx can be a single element number or a list of numbers or
        any other index mechanism accepted by numpy's ndarray
        By default, the vertex list will be compressed to hold only those
        used in the selected elements.
        Setting compress==False will keep all original nodes in the surface.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-678' xml:id='l2h-678' class="function">setProp</tt></b>(</nobr></td>
  <td><var>p=None</var>)</td></tr></table></dt>
<dd>
Create or delete the property array for the TriSurface.

<p>
A property array is a rank-1 integer array with dimension equal
        to the number of elements in the TriSurface.
        You can specify a single value or a list/array of integer values.
        If the number of passed values is less than the number of elements,
        they wil be repeated. If you give more, they will be ignored.

<p>
If a value None is given, the properties are removed from the TriSurface.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-679' xml:id='l2h-679' class="function">prop</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the properties as a numpy array (ndarray)
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-680' xml:id='l2h-680' class="function">maxprop</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the highest property value used, or None
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-681' xml:id='l2h-681' class="function">propSet</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return a list with unique property values.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-682' xml:id='l2h-682' class="function">x</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-683' xml:id='l2h-683' class="function">y</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-684' xml:id='l2h-684' class="function">z</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-685' xml:id='l2h-685' class="function">bbox</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-686' xml:id='l2h-686' class="function">center</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-687' xml:id='l2h-687' class="function">centroid</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-688' xml:id='l2h-688' class="function">sizes</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-689' xml:id='l2h-689' class="function">dsize</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-690' xml:id='l2h-690' class="function">bsphere</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-691' xml:id='l2h-691' class="function">centroids</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the centroids of all elements of the Formex.

<p>
The centroid of an element is the point whose coordinates
        are the mean values of all points of the element.
        The return value is an (nfaces,3) shaped Coords array.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-692' xml:id='l2h-692' class="function">distanceFromPlane</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-693' xml:id='l2h-693' class="function">distanceFromLine</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-694' xml:id='l2h-694' class="function">distanceFromPoint</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-695' xml:id='l2h-695' class="function">test</tt></b>(</nobr></td>
  <td><var>nodes='all',dir=0,min=None,max=None</var>)</td></tr></table></dt>
<dd>
Flag elements having nodal coordinates between min and max.

<p>
This function is very convenient in clipping a TriSurface in a specified
        direction. It returns a 1D integer array flagging (with a value 1 or
        True) the elements having nodal coordinates in the required range.
        Use where(result) to get a list of element numbers passing the test.
        Or directly use clip() or cclip() to create the clipped TriSurface

<p>
The test plane can be defined in two ways, depending on the value of dir.
        If dir == 0, 1 or 2, it specifies a global axis and min and max are
        the minimum and maximum values for the coordinates along that axis.
        Default is the 0 (or x) direction.

<p>
Else, dir should be compaitble with a (3,) shaped array and specifies
        the direction of the normal on the planes. In this case, min and max
        are points and should also evaluate to (3,) shaped arrays.

<p>
nodes specifies which nodes are taken into account in the comparisons.
        It should be one of the following:
        - a single (integer) point number (&lt; the number of points in the Formex)
        - a list of point numbers
        - one of the special strings: 'all', 'any', 'none'
        The default ('all') will flag all the elements that have all their
        nodes between the planes x=min and x=max, i.e. the elements that
        fall completely between these planes. One of the two clipping planes
        may be left unspecified.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-696' xml:id='l2h-696' class="function">clip</tt></b>(</nobr></td>
  <td><var>t</var>)</td></tr></table></dt>
<dd>
Return a TriSurface with all the elements where t&gt;0.

<p>
t should be a 1-D integer array with length equal to the number
        of elements of the TriSurface.
        The resulting TriSurface will contain all elements where t &gt; 0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-697' xml:id='l2h-697' class="function">cclip</tt></b>(</nobr></td>
  <td><var>t</var>)</td></tr></table></dt>
<dd>
This is the complement of clip, returning a TriSurface where t&lt;=0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-698' xml:id='l2h-698' class="function">pointNormals</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Compute the normal vectors in each point of a collection of triangles.

<p>
The normal vector in a point is the average of the normal vectors of the neighbouring triangles.
        The normal vectors are normalized.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-699' xml:id='l2h-699' class="function">offset</tt></b>(</nobr></td>
  <td><var>distance=1.</var>)</td></tr></table></dt>
<dd>
Offset a surface with a certain distance.

<p>
All the nodes of the surface are translated over a specified distance along their normal vector.
        This creates a new congruent surface.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-700' xml:id='l2h-700' class="function">toMesh</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return a tuple of nodal coordinates and element connectivity.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-701' xml:id='l2h-701' class="function">read</tt></b>(</nobr></td>
  <td><var>clas,fn,ftype=None</var>)</td></tr></table></dt>
<dd>
Read a surface from file.

<p>
If no file type is specified, it is derived from the filename
        extension.
        Currently supported file types:
          - .stl (ASCII or BINARY)
          - .gts
          - .off
          - .neu (Gambit Neutral)
          - .smesh (Tetgen)

<p>
<em>This is a class method, not an instance method.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-702' xml:id='l2h-702' class="function">write</tt></b>(</nobr></td>
  <td><var>fname,ftype=None</var>)</td></tr></table></dt>
<dd>
Write the surface to file.

<p>
If no filetype is given, it is deduced from the filename extension.
        If the filename has no extension, the 'gts' file type is used.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-703' xml:id='l2h-703' class="function">toFormex</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Convert the surface to a Formex.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-704' xml:id='l2h-704' class="function">scale</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-705' xml:id='l2h-705' class="function">translate</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-706' xml:id='l2h-706' class="function">rotate</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-707' xml:id='l2h-707' class="function">shear</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-708' xml:id='l2h-708' class="function">reflect</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-709' xml:id='l2h-709' class="function">affine</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>

<p>
<em>This method is equivalent to the corresponding <tt class="class">Coords</tt> method executed on the objects coordinates.</em>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-710' xml:id='l2h-710' class="function">avgVertexNormals</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Compute the average normals at the vertices.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-711' xml:id='l2h-711' class="function">areaNormals</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Compute the area and normal vectors of the surface triangles.

<p>
The normal vectors are normalized.
        The area is always positive.

<p>
The values are returned and saved in the object.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-712' xml:id='l2h-712' class="function">facetArea</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-713' xml:id='l2h-713' class="function">area</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the area of the surface
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-714' xml:id='l2h-714' class="function">volume</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the enclosed volume of the surface.

<p>
This will only be correct if the surface is a closed manifold.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-715' xml:id='l2h-715' class="function">edgeConnections</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the elems connected to edges.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-716' xml:id='l2h-716' class="function">nodeConnections</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the elems connected to nodes.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-717' xml:id='l2h-717' class="function">nEdgeConnected</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the number of elems connected to edges.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-718' xml:id='l2h-718' class="function">nNodeConnected</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the number of elems connected to nodes.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-719' xml:id='l2h-719' class="function">edgeAdjacency</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the elems adjacent to elems via an edge.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-720' xml:id='l2h-720' class="function">nEdgeAdjacent</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the number of adjacent elems.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-721' xml:id='l2h-721' class="function">nodeAdjacency</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the elems adjacent to elems via one or two nodes.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-722' xml:id='l2h-722' class="function">nNodeAdjacent</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Find the number of adjacent elems.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-723' xml:id='l2h-723' class="function">surfaceType</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-724' xml:id='l2h-724' class="function">borderEdges</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Detect the border elements of TriSurface.

<p>
The border elements are the edges having less than 2 connected elements.
        Returns True where edge is on the border.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-725' xml:id='l2h-725' class="function">borderEdgeNrs</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Returns the numbers of the border edges.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-726' xml:id='l2h-726' class="function">borderNodeNrs</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Detect the border nodes of TriSurface.

<p>
The border nodes are the vertices belonging to the border edges.
        Returns a list of vertex numbers.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-727' xml:id='l2h-727' class="function">isManifold</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-728' xml:id='l2h-728' class="function">isClosedManifold</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-729' xml:id='l2h-729' class="function">checkBorder</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the border of TriSurface as a set of segments.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-730' xml:id='l2h-730' class="function">fillBorder</tt></b>(</nobr></td>
  <td><var>method=0</var>)</td></tr></table></dt>
<dd>
If the surface has a single closed border, fill it.

<p>
Filling the border is done by adding a single point inside
        the border and connectin it with all border segments.
        This works well if the border is smooth and nearly planar.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-731' xml:id='l2h-731' class="function">border</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the border of TriSurface as a Plex-2 Formex.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-732' xml:id='l2h-732' class="function">edgeCosAngles</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the cos of the angles over all edges.

<p>
The surface should be a manifold (max. 2 elements per edge).
        Edges with only one element get angles = 1.0.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-733' xml:id='l2h-733' class="function">edgeAngles</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return the angles over all edges (in degrees).
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-734' xml:id='l2h-734' class="function">data</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Compute data for all edges and faces.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-735' xml:id='l2h-735' class="function">aspectRatio</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-736' xml:id='l2h-736' class="function">smallestAltitude</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-737' xml:id='l2h-737' class="function">longestEdge</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-738' xml:id='l2h-738' class="function">shortestEdge</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-739' xml:id='l2h-739' class="function">stats</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>
Return a text with full statistics.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-740' xml:id='l2h-740' class="function">edgeFront</tt></b>(</nobr></td>
  <td><var>startat=0,okedges=None,front_increment=1</var>)</td></tr></table></dt>
<dd>
Generator function returning the frontal elements.

<p>
startat is an element number or list of numbers of the starting front.
        On first call, this function returns the starting front.
        Each next() call returns the next front.
        front_increment determines haw the property increases at each
        frontal step. There is an extra increment +1 at each start of
        a new part. Thus, the start of a new part can always be detected
        by a front not having the property of the previous plus front_increment.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-741' xml:id='l2h-741' class="function">nodeFront</tt></b>(</nobr></td>
  <td><var>startat=0,front_increment=1</var>)</td></tr></table></dt>
<dd>
Generator function returning the frontal elements.

<p>
startat is an element number or list of numbers of the starting front.
        On first call, this function returns the starting front.
        Each next() call returns the next front.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-742' xml:id='l2h-742' class="function">walkEdgeFront</tt></b>(</nobr></td>
  <td><var>startat=0,nsteps=-1,okedges=None,front_increment=1</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-743' xml:id='l2h-743' class="function">walkNodeFront</tt></b>(</nobr></td>
  <td><var>startat=0,nsteps=-1,front_increment=1</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-744' xml:id='l2h-744' class="function">growSelection</tt></b>(</nobr></td>
  <td><var>sel,mode='node',nsteps=1</var>)</td></tr></table></dt>
<dd>
Grows a selection of a surface.

<p>
p is a single element number or a list of numbers.
        The return value is a list of element numbers obtained by
        growing the front nsteps times.
        The mode argument specifies how a single frontal step is done:
        'node' : include all elements that have a node in common,
        'edge' : include all elements that have an edge in common.

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-745' xml:id='l2h-745' class="function">partitionByEdgeFront</tt></b>(</nobr></td>
  <td><var>okedges,firstprop=0,startat=0</var>)</td></tr></table></dt>
<dd>
Detects different parts of the surface using a frontal method.

<p>
okedges flags the edges where the two adjacent triangles are to be
        in the same part of the surface.
        startat is a list of elements that are in the first part. 
        The partitioning is returned as a property type array having a value
        corresponding to the part number. The lowest property number will be
        firstprop

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-746' xml:id='l2h-746' class="function">partitionByNodeFront</tt></b>(</nobr></td>
  <td><var>firstprop=0,startat=0</var>)</td></tr></table></dt>
<dd>
Detects different parts of the surface using a frontal method.

<p>
okedges flags the edges where the two adjacent triangles are to be
        in the same part of the surface.
        startat is a list of elements that are in the first part. 
        The partitioning is returned as a property type array having a value
        corresponding to the part number. The lowest property number will be
        firstprop

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-747' xml:id='l2h-747' class="function">partitionByConnection</tt></b>(</nobr></td>
  <td><var></var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-748' xml:id='l2h-748' class="function">partitionByAngle</tt></b>(</nobr></td>
  <td><var>angle=180.,firstprop=0,startat=0</var>)</td></tr></table></dt>
<dd>

<p>
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-749' xml:id='l2h-749' class="function">cutWithPlane</tt></b>(</nobr></td>
  <td><var>None</var>)</td></tr></table></dt>
<dd>
Cut a surface with a plane.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-750' xml:id='l2h-750' class="function">connectedElements</tt></b>(</nobr></td>
  <td><var>target,elemlist=None</var>)</td></tr></table></dt>
<dd>
Return the elements from list connected with target
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-751' xml:id='l2h-751' class="function">smoothLowPass</tt></b>(</nobr></td>
  <td><var>n_iterations=2,lambda_value=0.5</var>)</td></tr></table></dt>
<dd>
Smooth the surface using a low-pass filter.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-752' xml:id='l2h-752' class="function">smoothLaplaceHC</tt></b>(</nobr></td>
  <td><var>n_iterations=2,lambda_value=0.5,alpha=0.,beta=0.2</var>)</td></tr></table></dt>
<dd>
Smooth the surface using a Laplace filter and HC algorithm.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-753' xml:id='l2h-753' class="function">check</tt></b>(</nobr></td>
  <td><var>verbose=False</var>)</td></tr></table></dt>
<dd>
Check the surface using gtscheck.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-754' xml:id='l2h-754' class="function">split</tt></b>(</nobr></td>
  <td><var>base,verbose=False</var>)</td></tr></table></dt>
<dd>
Check the surface using gtscheck.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-755' xml:id='l2h-755' class="function">coarsen</tt></b>(</nobr></td>
  <td><var>min_edges=None,max_cost=None,mid_vertex=False,length_cost=False,max_fold=1.0,volume_weight=0.5,boundary_weight=0.5,shape_weight=0.0,progressive=False,log=False,verbose=False</var>)</td></tr></table></dt>
<dd>
Coarsen the surface using gtscoarsen.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-756' xml:id='l2h-756' class="function">refine</tt></b>(</nobr></td>
  <td><var>max_edges=None,min_cost=None,log=False,verbose=False</var>)</td></tr></table></dt>
<dd>
Refine the surface using gtsrefine.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-757' xml:id='l2h-757' class="function">smooth</tt></b>(</nobr></td>
  <td><var>lambda_value=0.5,n_iterations=2,fold_smoothing=None,verbose=False</var>)</td></tr></table></dt>
<dd>
Smooth the surface using gtssmooth.
</dl>

<p>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><tt id='l2h-758' xml:id='l2h-758' class="function">boolean</tt></b>(</nobr></td>
  <td><var>surf,op,inter=False,check=False,verbose=False</var>)</td></tr></table></dt>
<dd>
Perform a boolean operation with surface surf.

<p>
</dl>

<p>

<div class="navigation">
<div class='online-navigation'>
<p></p><hr />
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8.22 surface  "
  href="module-surface.html"><img src='previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></a></td>
<td class='online-navigation'><a rel="parent" title="8.22 surface  "
  href="module-surface.html"><img src='up.png'
  border='0' height='32'  alt='Up one Level' width='32' /></a></td>
<td class='online-navigation'><a rel="next" title="8.22.2 functions defined in"
  href="node188.html"><img src='next.png'
  border='0' height='32'  alt='Next Page' width='32' /></a></td>
<td align="center" width="100%">pyFormex manual</td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><a rel="index" title="Index"
  href="genindex.html"><img src='index.png'
  border='0' height='32'  alt='Index' width='32' /></a></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="module-surface.html">8.22 surface  </a>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="module-surface.html">8.22 surface  </a>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node188.html">8.22.2 Functions defined in</a>
</div>
</div>
<hr />
<span class="release-info">Release 0.8-a1, documentation updated on 9 June 2009.</span>
</div>
<!--End of Navigation Panel-->

</body>
</html>
