<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>


  
  
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />


  
  
  
  
  
  <title>AST Nodes</title><meta name="generator" content="amaya 8.1a, see http://www.w3.org/Amaya/" />


  
  
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>


<h1>AST Nodes</h1>
<p>The analysis package takes standard <a href="http://docs.python.org/lib/module-compiler.ast.html"><code>compiler.ast</code></a>
nodes and annotates them with additional information which is then used
in subsequent activities such as code generation and documentation.
Below are tables showing the annotations used for various AST nodes:</p>
<h2>General</h2>
<table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">*</td>
      <td align="undefined" valign="undefined">_contexts</td>
      <td align="undefined" valign="undefined">Indicates the types that
the node is considered to have, along with the context in which it has
them. A dictionary mapping contexts to types/references.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">*</td>
      <td align="undefined" valign="undefined">_parent</td>
      <td align="undefined" valign="undefined">Indicates
the parent node of a node - useful for adding sibling nodes
(specialisations of functions) or for tracking the processing of
expressions (assignment processing).</td>
    </tr><tr><td align="undefined" valign="undefined">Function<br />For<br />While</td><td align="undefined" valign="undefined">_counter</td><td align="undefined" valign="undefined">Indicates
the number of contexts recorded in the node graph at a particular point
in time, typically upon visiting one of the affected nodes. This number
is checked again and compared to the current number of contexts in the
node graph to see if any additional information has surfaced and
whether it is necessary to analyse the node (and its descendants) again.</td></tr></tbody>
</table>
<h2>Names and Symbols</h2>
<table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">

  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Function<br />
Module<br />
Class<br />
Reference<br />
Stmt</td>
      <td align="undefined" valign="undefined">_namespace</td>
      <td align="undefined" valign="undefined">A
dictionary mapping names to lists of defining nodes for each name.
Some Stmt nodes have _namespace annotations when employed
by conditional or loop nodes.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">Function</td>
      <td align="undefined" valign="undefined">_globals</td>
      <td align="undefined" valign="undefined">Provides a list of globals used in the function.</td>
    </tr>
    <tr><td align="undefined" valign="undefined">Function</td><td align="undefined" valign="undefined">_specials</td><td align="undefined" valign="undefined">Provides
a list of names which are global to the function but which are not
"true" globals. Typically, this affects local classes and functions,
where their names would not be stored in the global namespace but must
still be available within their body.</td></tr><tr>
      <td align="undefined" valign="undefined">Name</td>
      <td align="undefined" valign="undefined">_scope</td>
      <td align="undefined" valign="undefined">Indicates which scope the name uses to refer to a variable.<br />
Examples: "locals", "specials", "globals".</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Name<br />
AssName<br />
Class<br />
Function<br />
Getattr</td>
      <td align="undefined" valign="undefined">_name_context</td>
      <td align="undefined" valign="undefined">Indicates
the kind of local scope in which the name resides, or in the case of
Getattr the kind of scope from which the attribute was retrieved. (This
does not apply to AssAttr since the kind of scope can be inferred from
the type of node involved, whereas Getattr may involve either class or
instance attribute access.)<br />
Examples: "class", "instance".</td>
    </tr>
<tr>
      <td align="undefined" valign="undefined">Module</td>
      <td align="undefined" valign="undefined">_constants_table</td>
      <td align="undefined" valign="undefined">A list of constants in the module.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Module<br />Name<br />Function<br />Import</td>
      <td align="undefined" valign="undefined">_module_name</td>
      <td align="undefined" valign="undefined">The
name of the module within which a name is defined. On Module nodes,
this is the same as _qualified_name. On Function nodes, this is used to
initialise namespaces and to build qualified names for globals
referenced from those namespaces.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Name<br />
AssName<br />
Module<br />
Class<br />
Function</td>
      <td align="undefined" valign="undefined">_qualified_name</td>
      <td align="undefined" valign="undefined">Provides a qualified name for use in generated code (where appropriate) - see _name_context for additional guidance.</td>
    </tr><tr><td align="undefined" valign="undefined">Import</td><td align="undefined" valign="undefined">_names</td><td align="undefined" valign="undefined">Provides
a list of name nodes referring to other modules. Each node contains an
expr attribute referring to the module, along with module_name and
as_name attributes referring to the naming details of the import
operation. Additionally, a name attribute provides the resulting name
to which the module is bound in the current namespace.</td></tr>

  </tbody>
</table>
<h2>Classes and Instantiation</h2>
<table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">


  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Reference</td>
      <td align="undefined" valign="undefined">_class<br />
</td>
      <td align="undefined" valign="undefined">Indicates the class of a particular reference.<br />
</td>
    </tr><tr>
      <td align="undefined" valign="undefined">Class</td>
      <td align="undefined" valign="undefined">_instances</td>
      <td align="undefined" valign="undefined">A list of instances (references) for a given class.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">CallFunc<br />
Const<br />
List<br />
Compare</td>
      <td align="undefined" valign="undefined">_instantiates</td>
      <td align="undefined" valign="undefined">Indicates that the node instantiates a particular reference.</td>
    </tr><tr><td align="undefined" valign="undefined">*</td><td align="undefined" valign="undefined">_raises</td><td align="undefined" valign="undefined">Indicates that the node instantiates a particular reference as a possible exception.</td></tr><tr><td align="undefined" valign="undefined">Class</td><td align="undefined" valign="undefined">_inherited</td><td align="undefined" valign="undefined">A dictionary mapping names to superclasses which contain the definitions of such names for the annotated class.</td></tr>

  </tbody>
</table>
<h2>Additional Symbols</h2><table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">


  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">Slice</td>
      <td align="undefined" valign="undefined">_none<br />
</td>
      <td align="undefined" valign="undefined">A reference to None as a default argument to a __getslice__ method.<br />
</td>
    </tr><tr><td align="undefined" valign="undefined">Compare</td><td align="undefined" valign="undefined">_default</td><td align="undefined" valign="undefined">A reference, typically to False, as a default result of comparisons which cannot be supported by their participants.</td></tr>
    

  </tbody>
</table><h2>Attribute Access</h2><table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">


  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">AssAttr<br />AugAssign<br />Getattr</td>
      <td align="undefined" valign="undefined">_undesirable<br />
</td>
      <td align="undefined" valign="undefined">Indicates object
types which may occur when attempting to obtain the named attribute,
but which do not support access to such an attribute.<br />
</td>
    </tr><tr><td align="undefined" valign="undefined">AssAttr<br />AugAssign<br />Getattr</td><td align="undefined" valign="undefined">_permitted</td><td align="undefined" valign="undefined">Indicates object types which may occur and which do support access to the named attribute.</td></tr>
    

  </tbody>
</table><h2>Operations and Invocations</h2>
<table style="text-align: left; width: 80%;" border="1" cellpadding="5" cellspacing="0">


  <tbody>
    <tr>
      <th width="10%">Node</th>
      <th width="15%">Annotation</th>
      <th>Purpose</th>
    </tr>
    <tr><td align="undefined" valign="undefined">AugAssign</td><td align="undefined" valign="undefined">_op</td><td align="undefined" valign="undefined">The operation which provides support for the augmented assignment.</td></tr><tr>
      <td align="undefined" valign="undefined">Compare</td>
      <td align="undefined" valign="undefined">_ops<br />
</td>
      <td align="undefined" valign="undefined">A list of operator objects summarising the binary operations employed in the comparison.<br />
</td>
    </tr><tr>
      <td align="undefined" valign="undefined">If</td>
      <td align="undefined" valign="undefined">_tests</td>
      <td align="undefined" valign="undefined">A dictionary of helper
nodes used to represent invocations of __true__ methods on tests
associated with an if statement. The dictionary maps test nodes to
their corresponding helper node.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">While</td>
      <td align="undefined" valign="undefined">_test</td>
      <td align="undefined" valign="undefined">A helper node used to represent invocations of __true__ methods on the continuation test of the while statement.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">And<br />
Or</td>
      <td align="undefined" valign="undefined">_nodes</td>
      <td align="undefined" valign="undefined">A list of helper nodes,
corresponding to elements in the nodes attribute of the affected node,
where each represents invocations of __true__ methods on the
corresponding original node.</td>
    </tr>
<tr><td align="undefined" valign="undefined">Not</td><td align="undefined" valign="undefined">_true_call</td><td align="undefined" valign="undefined">A helper node representing an invocation of the __true__ method on the affected expression.</td></tr><tr><td align="undefined" valign="undefined">AssTuple</td><td align="undefined" valign="undefined">_next_call</td><td align="undefined" valign="undefined">A helper node used to represent invocations of next methods on any iterator found through its parent node.</td></tr><tr><td align="undefined" valign="undefined">List<br />Print<br />Printnl<br />Tuple</td><td align="undefined" valign="undefined">_calls</td><td align="undefined" valign="undefined">A
list of helper nodes used to represent invocations of methods that
implement the behaviour of the annotated node. List and Tuple nodes
employ invocations of append methods, whereas Print and Printnl nodes
employ invocations of __str__ methods.</td></tr><tr>
      <td align="undefined" valign="undefined">*</td>
      <td align="undefined" valign="undefined">_ignored</td>
      <td align="undefined" valign="undefined">Indicates that the block
associated with a test in a conditional statement would be ignored due
to the test always yielding a false value.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">*</td>
      <td align="undefined" valign="undefined">_short_circuited</td>
      <td align="undefined" valign="undefined">Indicates that the block
associated with a test in a conditional statement would always be
executed in preference to following blocks and that such following
blocks and their associated test nodes need not be generated.</td>
    </tr>
<tr>
      <td align="undefined" valign="undefined">*</td>
      <td align="undefined" valign="undefined">_original</td>
      <td align="undefined" valign="undefined">Indicates the original node used to produce a node within a specialisation.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">Function<br />(specialisation)</td>
      <td align="undefined" valign="undefined">_specialises</td>
      <td align="undefined" valign="undefined">An attribute whose
presence indicates that the node and its children represent a
specialisation (as opposed to an original function), indicating the original function on which the specialisation is based.</td>
    </tr>
<tr>
      <td align="undefined" valign="undefined">Function<br />(original)</td>
      <td align="undefined" valign="undefined">_signatures</td>
      <td align="undefined" valign="undefined">A
list of signatures each corresponding to a specialisation in the
_specialisations annotation; together, these annotations should be
considered as a table. (See also _signatures for invocation nodes below.)</td>
    </tr><tr>
      <td align="undefined" valign="undefined">Function<br />(original)</td>
      <td align="undefined" valign="undefined">_specialisations</td>
      <td align="undefined" valign="undefined">A list of specialisations created for a particular function.</td>
    </tr><tr><td align="undefined" valign="undefined">Function<br />(specialisation)</td><td align="undefined" valign="undefined">_signature</td><td align="undefined" valign="undefined">A list of type names for each function parameter, used for convenience in finding suitable specialisations for callers.</td></tr><tr><td align="undefined" valign="undefined">Function<br />(specialisation)</td><td align="undefined" valign="undefined">_locals</td><td align="undefined" valign="undefined">A list of locals for each function parameter, similar to _signature but containing actual node information.</td></tr><tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />
AssList<br />
AssAttr<br />
AssName<br />
List<br />
For</td>
      <td align="undefined" valign="undefined">_targets</td>
      <td align="undefined" valign="undefined">A list of specialisations that may be involved in a function or method invocation.</td>
    </tr>
    <tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td>
      <td align="undefined" valign="undefined">_argnames</td>
      <td align="undefined" valign="undefined">A
list of argument name lists
that are associated with each possible specialisation from _targets.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td>
      <td align="undefined" valign="undefined">_argnodes</td>
      <td align="undefined" valign="undefined">A
dictionary mapping argument names to argument nodes. Taking a name from
_argnames and using it as a key in this dictionary should yield the
argument node in the AST.</td>
    </tr><tr><td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td><td align="undefined" valign="undefined">_argnodes_keys</td><td align="undefined" valign="undefined">A
list of keys to the _argnodes dictionary ordered in correspondence with
the _targets, _locals, _argnames and _refcontexts annotations.</td></tr><tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td>
      <td align="undefined" valign="undefined">_locals</td>
      <td align="undefined" valign="undefined">A
list of argument reference lists
that are associated with each possible specialisation from _targets.
This is similar to _signatures (below) but provides actual reference
information.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td>
      <td align="undefined" valign="undefined">_signatures</td>
      <td align="undefined" valign="undefined">A
list of argument signature lists
that are associated with each possible specialisation from _targets.
This provides a list of possible type/reference names for each argument.</td>
    </tr><tr>
      <td align="undefined" valign="undefined">CallFunc<br />
AssTuple<br />

AssList<br />
AssAttr<br />
AssName<br />

List<br />
For</td>
      <td align="undefined" valign="undefined">_refcontexts</td>
      <td align="undefined" valign="undefined">A
list containing the meaning of references employed in the
node's&nbsp;arguments. This is used to generate code for parameters and
also to
generate invocation target selection tests.<br />
Examples: "new" (used in instantiation), "context" (used in method
calls), "top" (used to obtain the current
subexpression).<br />Generally,
such information is not relevant in the analysis phase, since exactly
how generated code remembers arguments and subsequently manipulates
them is strictly a concern for the code generator itself.</td>
    </tr>

    

  </tbody>
</table>

</body></html>