<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>


  
  
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />


  
  
  
  
  
  <title>Instantiation</title><meta name="generator" content="amaya 8.1a, see http://www.w3.org/Amaya/" />


  
  
  <link href="styles.css" rel="stylesheet" type="text/css" /></head>
<body>


<h1>Instantiation</h1>
<p>The instantiation of objects from classes or types is an activity
which affects the behaviour of other parts of the analysis system.
Consider the creation and usage of specialisations; upon specialising a
function the following steps are performed:</p>
<ol>
  <li>The arguments in the function call are used to create a signature.</li>
  <li>The signature is compared against existing signatures, if any.</li>
  <li>If no matching, existing signature can be found, a new specialisation is created and associated with the signature.</li>
  <li>If an existing signature matches, the associated specialisation is obtained.</li>
  <li>The specialisation, whether existing or new, is re-evaluated.</li>
</ol>
<p>In the simplest case, where only a single instance is constructed
for each type, the number of possible signatures is constrained
according to the number of types defined in the program. However, where
multiple instances can be defined for any given type, such guarantees
are less certain.</p>
<h2>Specialisation and Recursion</h2>
<p>Consider the case of a recursive function f(x) which calls itself:</p>
<pre>def f(x):<br />    if len(x) == 1:<br />        return x<br />    else:<br />        y = []<br />        y.append(x[0] + x[1])<br />        for i in x[2:]:<br />            y.append(i)<br />        return f(y)</pre>
<p>Here, a new list is created which contains elements from the
original list supplied as an argument to the function. In the simplest
case, we can say that the recursive call within the function is a call
to a specialisation that already exists, and we can even take steps to
curtail re-evaluation of the specialisation and avoid infinite
recursion in the analysis of this code. However, should we decide to
permit each "instantiation site" to create a new object from a
particular type - in this case, a new list object for the list created
by the function - then unless we have a means to limit this
instantiation, the result will be the following:</p>
<ol>
  <li>Enter f(x) with a list object.</li>
  <li>We must always evaluate both the base and recursive cases, so this results in a new list object being created.</li>
  <li>Examine existing specialisations when considering f(y): since a
different list object is employed, no existing specialisations exist.</li>
  <li>Enter f(y) with the new list object.</li>
  <li>Again, a new list object is created.</li>
  <li>Again, f(y) involves a list object not already registered in the list of signatures.</li>
  <li>And so on.</li>
</ol>
<p>In other words, the program's "natural" constraints no longer apply
and we are effectively executing certain aspects of the program itself.</p>
<h2>Instance Equivalence</h2>
<p>The above problem with recursive functions can be reduced to a
question of equivalence. If each new list cannot be considered
equivalent to previous lists, and thus cannot make each signature
equivalent to those produced before it, then the process of analysis
will continue to produce new specialisations. However, to regard
instances as equivalent is not necessarily a trivial matter; consider
the following instances:</p>
<pre>i = [[[1]]]<br />j = [[["a"]]]</pre>
<p>Whilst both instances are superficially similar at the highest level
(lists) and one level down (lists of lists), one might imagine that to
fully test the equivalence of instances, one would need to test
equivalence to an arbitrary number of levels. Moreover, with recursive
structures the number of levels would tend to infinity. Consider this
example:</p>
<pre>def f(x):<br />    if not isinstance(x, list):<br />        return g(x)<br />    else:<br />        return f(x[0])<br /><br />def g(x):<br />    return x + x<br /><br />f([[[1]]])<br />f([[["a"]]])</pre>
<p>Here, a superficial consideration of all lists being equal would
result in the function g being specialised to accept a list as argument
even though the code is clearly not written to entertain such a
possibility.</p>
</body></html>