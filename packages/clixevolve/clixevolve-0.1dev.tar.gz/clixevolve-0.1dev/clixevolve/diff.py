#!/usr/bin/env python
import sys, time, pprint
import argparse
def main():
    parser = argparse.ArgumentParser(description="Diff two schema evolution files", prog="clixdiff", version='ClixDiff 0.1dev')
    parser.add_argument('left', type=argparse.FileType('r'), metavar='LEFT', help='left file for the diff')
    parser.add_argument('right', type=argparse.FileType('r'), metavar='RIGHT', help='right file for the diff')
    args = parser.parse_args()
    with args.left:
        whole_left = eval(args.left.read())
    with args.right:
        whole_right = eval(args.right.read())
    if whole_left['database'] != whole_right['database']:
        sys.stderr.write("Database names do not match -- aborting diff\n")
        sys.exit(1)
    if 'version' not in whole_left or whole_left['version'] < 2:
        sys.stderr.write("Unable to diff -- left file's version is unsupported!")
        sys.exit(1)
    if 'version' not in whole_right or whole_right['version'] < 2:
        sys.stderr.write("Unable to diff -- left file's version is unsupported!")
        sys.exit(1)
    if whole_left['version'] != whole_right['version']:
        sys.stderr.write("Unable to diff -- version mismatch")
        sys.exit(1)
    left = whole_left['tables']
    right = whole_right['tables']
    right_tables = {}
    for i in range(len(right)):
        right_tables[right[i]['name']] = i
    print "# AUTOGENERATED from clixdiff. Left: %s, Right: %s, Time: %s" % (args.left.name, args.right.name, time.ctime())
    print
    tables_list = []
    output_data = {'database': whole_left['database'], 'tables': tables_list}
    for table in left:
        if table['name'] not in right_tables.keys():
            #entire table has been deleted
            tables_list.append({'name':table['name'], 'action':'drop'})
        else:
            column_list = []
            table_output = {'name' : table['name'], 'columns':column_list}
            right_table = right[right_tables[table['name']]]
            right_columns = {}
            for i in range(len(right_table['columns'])):
                right_columns[right_table['columns'][i]['name']] = i
            columns = table['columns']
            table_clean = True
            for c in columns:
                if c['name'] not in right_columns:
                    column_list.append({'name':c['name'], 'action':'drop'})
                    table_clean = table_clean and False
                else:
                    right_column = right_table['columns'][right_columns[c['name']]]
                    column_output = {'name':c['name'], 'action':'modify'}
                    column_clean = True
                    for prop in c.keys():
                        if prop == 'name': continue
                        if c[prop] == right_column[prop]: continue
                        column_output[prop] = right_column[prop]
                        column_clean = column_clean and False
                        table_clean = table_clean and False
                    if column_clean:
                        continue
                    column_list.append(column_output)
            if table_clean: 
                continue
            tables_list.append(table_output)
    left_tables = [i['name'] for i in left]
    leftover = set(right_tables.keys()) - set(left_tables)
    if len(leftover) > 0:
        for table in leftover:
            tables_list.append(right[right_tables[table]])
    tables_list.sort(key=lambda i: i['name'])
    pprint.pprint(output_data)

if __name__ == "__main__": main()