# -*- coding: utf-8 -*-
"""Recipe openlayers"""

import zc.buildout
import urlparse
import tempfile
import logging
import urllib
import shutil
import md5
import imp
import os

import hexagonit.recipe.download

# class Recipe(object):
#     """zc.buildout recipe"""
# 
#     def __init__(self, buildout, name, options):
#         self.buildout, self.name, self.options = buildout, name, options
# 
#     def install(self):
#         """Installer"""
#         # XXX Implement recipe functionality here
#         
#         # Return files that were created by the recipe. The buildout
#         # will remove all returned files upon reinstall.
#         return tuple()
# 
#     def update(self):
#         """Updater"""
#         pass

class Recipe:
    """zc.buildout recipe for compiling and installing software"""

    def __init__(self, buildout, name, options):
        self.options = options
        self.buildout = buildout
        self.name = name

        log = logging.getLogger(self.name)

        options['location'] = os.path.join(
            buildout['buildout']['parts-directory'],
            self.name)
        options['prefix'] = options['location']
        options['url'] = options.get('url', '').strip()
        options['path'] = options.get('path', '').strip()

        if options['url'] and options['path']:
            raise zc.buildout.UserError('You must use either "url" or "path", not both!')
        if not (options['url'] or options['path']):
            raise zc.buildout.UserError('You must provide either "url" or "path".')

        if options['url']:
            options['compile-directory'] = '%s__compile__' % options['location']
        else:
            options['compile-directory'] = options['path']

    def update(self):
        pass

    def call_script(self, script):
        """This method is copied from z3c.recipe.runscript.

        See http://pypi.python.org/pypi/z3c.recipe.runscript for details.
        """
        filename, callable = script.split(':')
        filename = os.path.abspath(filename)
        module = imp.load_source('script', filename)
        # Run the script with all options
        getattr(module, callable.strip())(self.options, self.buildout)

    def run(self, cmd):
        log = logging.getLogger(self.name)
        if os.system(cmd):
            log.error('Error executing command: %s' % cmd)
            raise zc.buildout.UserError('System error')

    def install(self):
        log = logging.getLogger(self.name)
        parts = []

        # make_cmd = self.options.get('make-binary', 'make').strip()
        # make_targets = ' '.join(self.options.get('make-targets', 'install').split())
        # 
        # configure_options = ' '.join(self.options.get('configure-options','').split())

        patch_cmd = self.options.get('patch-binary', 'patch').strip()
        patch_options = ' '.join(self.options.get('patch-options', '-p0').split())
        patches = self.options.get('patches', '').split()

        # Download the source using hexagonit.recipe.download
        if self.options['url']:
            compile_dir = self.options['compile-directory']
            os.mkdir(compile_dir)
        
            try:
                opt = self.options.copy()
                opt['destination'] = compile_dir
                hexagonit.recipe.download.Recipe(
                    self.buildout, self.name, opt).install()
            except:
                shutil.rmtree(compile_dir)
                raise
        else:
            log.info('Using local source directory: %s' \
                     % self.options['path']
                     )
            compile_dir = self.options['path']

        os.mkdir(self.options['location'])
        os.chdir(compile_dir)
        
        try:
            if patches:
                log.info('Applying patches')
                for patch in patches:
                    self.run('%s %s < %s' % (patch_cmd, patch_options, patch))

            # Build
            contents = os.listdir(compile_dir)
            if 'build' in contents:
                os.chdir('build')
            else:
                os.chdir(contents[0])
                os.chdir('build')
            
            cfg = """# Generated by zgeo.recipe.openlayers
[first]
OpenLayers/SingleFile.js
OpenLayers.js
OpenLayers/BaseTypes.js
OpenLayers/BaseTypes/Class.js
OpenLayers/Util.js

[last]

[include]
%s

[exclude]
""" % self.options['include']

            f = open('recipe.cfg', 'w')
            f.write(cfg)
            f.close()
            
            self.run('./build.py recipe')
            
            shutil.copy(
                'OpenLayers.js', 
                os.path.join(
                    self.options['location'], 'OpenLayers.js'
                    )
                )
            shutil.copytree(
                '../img',
                os.path.join(
                    self.options['location'], 'img'
                    )
                )
            shutil.copytree(
                '../theme',
                os.path.join(
                    self.options['location'], 'theme'
                    )
                )

        except:
            log.error('Build error. The package is left as is at %s where '
                      'you can inspect what went wrong' % os.getcwd())
            raise

        if self.options['url']:
            if self.options.get('keep-compile-dir', '').lower() in ('true', 'yes', '1', 'on'):
                # If we're keeping the compile directory around, add it to
                # the parts so that it's also removed when this recipe is
                # uninstalled.
                parts.append(self.options['compile-directory'])
            else:
                shutil.rmtree(compile_dir)
                del self.options['compile-directory']

        parts.append(self.options['location'])
        return parts
