=========================
plone.behavior: Behaviors
=========================

Please see README.txt at the root of this egg for more details on what
behaviors are and how to use them.

See directives.txt in this directory for details on how to register new
types of behaviors using ZCML.

Example
-------

As an example, let's create a basic behavior that's described by the
interface ILockingSupport:

    >>> from zope.interface import implements
    >>> from zope.interface import Interface

    >>> class ILockingSupport(Interface):
    ...     def lock():
    ...         "Lock the context"
    ...     
    ...     def unlock():
    ...         "Unlock the context"

    >>> class LockingSupport(object):
    ...     implements(ILockingSupport)
    ...     def __init__(self, context):
    ...         self.context = context
    ...         
    ...     def lock(self):
    ...         print 'Locked', repr(self.context)
    ...     
    ...     def unlock(self):
    ...         print 'Unlocked', repr(self.context)

The availability of this new behavior is indicated by registering a named
utility providing IBehavior. There is a default implementation of this
interface that makes this easy:

    >>> from plone.behavior.registration import BehaviorRegistration
    >>> registration = BehaviorRegistration(
    ...     title=u"Locking support", 
    ...     description=u"Provides content-level locking",
    ...     interface=ILockingSupport,
    ...     factory=LockingSupport)

    >>> from zope.component import provideUtility
    >>> provideUtility(registration, name=u"example.mybehavior")

We also need to register an adapter factory that can create an instance of
an ILockingSupport for any context. This is a bit different to a standard
adapter factory (which is normally just a class with a constructor that
takes the context as an argument), because we want this factory to be
able to adapt almost anything, but which will return None if the behavior
isn't actually enabled.

To get these semantics, we can use the BehaviorAdapterFactory helper
class.

    >>> from plone.behavior.factory import BehaviorAdapterFactory
    >>> factory = BehaviorAdapterFactory(registration)

    >>> from zope.interface import implements
    >>> from zope.component import provideAdapter
    >>> provideAdapter(factory=factory, adapts=(Interface,), provides=ILockingSupport)

One this is registered, it will be possible to adapt any context to 
ILockingSupport, if:

  - The context can be adapted to IBehaviorAssignable. This is an 
    interface that is used to determine if a particular object supports
    a particular behavior.
    
  - The behavior is enabled, i.e. the IBehaviorAssignable implementation 
    says it is.

Right now, neither of those things are true, so we'll get a TypeError when
trying to adapt:

    >>> class SomeContext(object):
    ...     def __repr__(self):
    ...         return "<sample context>"

    >>> context = SomeContext()
    >>> behavior = ILockingSupport(context) # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    TypeError: ('Could not adapt', ...)

Of course, we are more likely to want to code defensively:

    >>> behavior = ILockingSupport(context, None)
    >>> behavior is None
    True

Let's solve that. We'll start by defining the IBehaviorAssignable adapter.
Note that there is no default implementation of this, because the means
of registering behaviors should be application specific. One scenario
may be a per-type registration. Let's simulate that here with a crude
global variable.


    >>> from plone.behavior.interfaces import IBehaviorAssignable
    >>> BEHAVIORS = {} # dict of class -> set of enabled behavior interfaces
    >>> from zope.component import adapts
    >>> class DefaultBehaviorAssignable(object):
    ...     implements(IBehaviorAssignable)
    ...     adapts(Interface)
    ...
    ...     def __init__(self, context):
    ...         global BEHAVIORS
    ...         self.context = context
    ...         self.enabled = BEHAVIORS.get(context.__class__, set())
    ...
    ...     def supports(self, behavior_interface):
    ...         return behavior_interface in self.enabled
    ... 
    ...     def enumerate_behaviors(self):
    ...         return self.enabled
    ... 

    >>> provideAdapter(factory=DefaultBehaviorAssignable)

At this point, we know that the context support behavior assignment (since
there is an adapter for it), but it's not yet enabled, so we still can't 
adapt.

    >>> behavior = ILockingSupport(context, None)
    >>> behavior is None
    True

However, if we enable the behavior for this type:

    >>> BEHAVIORS[SomeContext] = set([ILockingSupport])

Then we can adapt and use the behavior adapter:

    >>> behavior = ILockingSupport(context, None)
    >>> behavior is None
    False
    
    >>> behavior.lock()
    Locked <sample context>