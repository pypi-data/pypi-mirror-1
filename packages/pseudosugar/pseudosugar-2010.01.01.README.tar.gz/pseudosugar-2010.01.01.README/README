Metadata-Version: 1.0
Name: pseudosugar
Version: 2010.01.01.README
Summary: DESCRIPTION: pseudosugar - extend python with functional programming language features
Home-page: http://pypi.python.org/pypi/pseudosugar
Author: kai zhu
Author-email: kaizhu256@gmail.com
License: gpl
Description: DESCRIPTION: pseudosugar - extend python with functional programming language features
        
        REQUIRES: LINUX OS AND PYTHON3.1
        
        QUICK TEST: $ python3.1 setup.py build dev --quicktest
        
        SUMMARY:
        pseudosugar is a pure python module.
        pseudosugar is a python ast tree hack, adding the following syntax sugars:
        
        function<<<< aa, bb, cc, ... -> function(aa, bb, cc, ...)
        aa, bb, cc, ... >>>>function -> function(aa, bb, cc, ...)
        
        xx ..function(aa, bb, cc) -> function(xx, aa, bb, cc)
        xx ...function(aa, bb, cc) -> function(aa, xx, bb, cc)
        xx ....function(aa, bb, cc) -> function(aa, bb, xx, cc)
        
        RECENT CHANGELOG:
        20091231 - added <<<< and >>>> sugar
        20091224 - added pseudomethod interactive console - revamped pseudomethod import hook
        20091224 - modularized package - fix install issues - added sdist check
        20091209 - improved documentation
        20091205 - moved source code to c++
        20091116 - package integrated
        
        DEMO USAGE:
        
        >>> ## start up the interactive console
        >>> from pseudosugar import *
        >>> pseudo_console().interact()
        
        Python 3.1.1 (r311:74480, Sep 13 2009, 17:17:12)
        [GCC 4.3.2] on linux2
        Type "help", "copyright", "credits" or "license" for more information.
        (pseudo_console)
        pseudo_importer - adding hook <pseudosugar.pseudo_importer object at 0xb7a3254c> to sys.meta_path
        >>> from pseudosugar import *
        
        >>> #### QUICK EXAMPLES
        >>> ## prefix operator
        >>> print<<<< 'hello', 'world'
        hello world
        
        >>> ## postfix operator
        >>> 'hello', 'world' >>>>print
        hello world
        
        >>> ## pseudomethod
        >>> def function(aa, bb, cc): return (aa, bb, cc)
        >>> 1 ..function(0, 0) >>>>print
        (1, 0, 0)
        >>> 2 ...function(0, 0) >>>>print
        (0, 2, 0)
        >>> 3 ....function(0, 0) >>>>print
        (0, 0, 3)
        
        
        
        
        
        
        
        >>> ## '<<<<' CONVERTS FUNCTIONS INTO PREFIX OPERATORS
        >>> ## foo<<<< turns foo into a prefix operator
        >>> ## foo<<<< will take in everything to its right that is comma delimited
        >>> ## print<<<< is useful for making print statements
        >>> print<<<< 'bob says', 'hello ' + re.sub<<<< re.compile('(\w+)'), '\\1!', 'world'
        bob says hello world!
        
        >>> ## '>>>>' CONVERTS FUNCTIONS INTO POSTFIX OPERATORS
        >>> ## it behaves almost exactly like '>>>>' except in reverse
        >>> ## it is useful for chaining together multiple operators
        >>> 'qwerty' >>>>list >>>>sorted >>>>enumerate >>>>dict >>>>print
        {0: 'e', 1: 'q', 2: 'r', 3: 't', 4: 'w', 5: 'y'}
        
        >>> ## OPERATOR PRECEDENCE
        >>> ## '>>>>' has higher operator precedence than '<<<<'
        >>> print( list<<<< 'abcd' >>>>tuple ) ## list(tuple('abcd'))
        ['a', 'b', 'c', 'd']
        
        
        
        
        
        
        
        >>> #### PSEUDOMETHOD SYNTAX
        >>> ## DYNAMICALLY BIND FUNCTION CALLS TO OBJECTS
        >>> ## bind the function call print() to 'hello'
        >>> print('hello')
        hello
        >>> 'hello' ..print()
        hello
        >>> 'hello' ..print('world')
        hello world
        >>> 'hello' ..print('world', '!')
        hello world !
        >>> 'hello' ..print('world', '!', file = sys.stdout)
        hello world !
        
        >>> ## create a string pseudomethod which adds an exclamation or other endings
        >>> def add_ending(self, end = '!'): return self + end
        >>> 'hello' ..add_ending() ..print()
        hello!
        >>> 'hello'.upper() ..add_ending() ..print()
        HELLO!
        >>> 'hello'.upper() ..add_ending(' world') ..print()
        HELLO world
        >>> 'hello'.upper() ..add_ending(' world').lower() ..print()
        hello world
        >>> 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..print()
        hello world!
        >>> 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..add_ending(end = '!') ..print()
        hello world!!
        
        
        
        >>> ## OPERATOR PRECEDENCE
        >>> ## 'aa ..bb()' has the same operator precedence as the attribute operator 'a.b'
        >>> def add(aa, bb): return aa + bb
        >>> print( 2 * 3 ..add(4) + 5 == 2 * (3 + 4) + 5 )
        True
        >>> print( 3 == 1 ..add(2) )
        True
        >>> print( 0, 0 ..add(1), 0 )
        0 1 0
        
        
        
        >>> ## EXTEND RESTRICTED TYPES
        >>> ## the python code object type <class 'code'> cannot be subtyped nor will it accept any method binding.
        >>> ## however, we can extend it by dynamically binding ordinary functions.
        >>> ## here's a pseudomethod which disassembles an instance of the type to a specified output
        >>> import dis, io, sys
        >>> def disassemble(self, file):
        ...   backup_stdout = sys.stdout ## backup sys.stdout
        ...   try:
        ...     sys.stdout = file
        ...     dis.dis(self) ## disassemble self
        ...     return file
        ...   finally:
        ...     sys.stdout = backup_stdout ## restore sys.stdout
        
        >>> code_source = 'print( "hello" )'; code_object = compile(code_source, '', 'exec'); exec( code_object )
        hello
        >>> code_object ..disassemble(file = io.StringIO()).getvalue() ..print()
        1           0 LOAD_NAME                0 (print)
        3 LOAD_CONST               0 ('hello')
        6 CALL_FUNCTION            1
        9 POP_TOP
        10 LOAD_CONST               1 (None)
        13 RETURN_VALUE
        
        
        
        
        >>> ## '...' AND '....' SYNTAX
        >>> ## sometimes we instead want the 2nd or 3rd argument of a function bound to an object.
        >>> ## '...' and '....' will do this respectively
        >>> '2nd' ...print(0, 0)
        0 2nd 0
        >>> '3rd' ....print(0, 0)
        0 0 3rd
        
        >>> ## '....' is useful for chaining re.sub
        >>> ss = 'file = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()'; print( ss )
        file = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()
        
        >>> print(
        ...   re.sub('print (.*?)$', 'print( \\1 )',
        ...          re.sub('print (.*) >> (.*?);', 'print( \\1, file = \\2 );', ss)
        ...          )
        ...   )
        file = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )
        
        >>> ss ....re.sub('print (.*) >> (.*?);', 'print( \\1, file = \\2 );') \
        ...    ....re.sub('print (.*?)$', 'print( \\1 )') \
        ...    ..print()
        file = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )
        
        >>> ## in fact, another primary use of pseudomethod is to flatten ugly, hard-to-read, lisp-like nested function calls
        >>> print( dict( enumerate( zip( 'abc',  sorted( 'abc bca cab'.split(' '), key = lambda x: x[1] ) ) ) ) )
        {0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}
        
        >>> 'abc bca cab'.split(' ') ..sorted(key = lambda x: x[1]) ...zip('abc') ..enumerate() ..dict() ..print()
        {0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}
        
        
        
        >>> ## IMPORT MODULES WRITTEN WITH PSEUDOMETHOD SYNTAX
        >>> ## create test_module.py
        >>> open('test_module.py', 'w').write('"hello" ..print()\n') ..print('bytes written')
        18 bytes written
        
        >>> ## during import, insert the magic prefix 'pseudosugar.' before the last module
        >>> ## import pseudosugar.a
        >>> ## import a.pseudosugar.b
        >>> ## import a.b.pseudosugar.c
        >>> import pseudosugar.test_module
        hello
        
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: End Users/Desktop
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: GNU General Public License (GPL)
Classifier: Natural Language :: English
Classifier: Operating System :: POSIX
Classifier: Operating System :: POSIX :: Linux
Classifier: Programming Language :: C
Classifier: Programming Language :: C++
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.1
Classifier: Topic :: Multimedia
Classifier: Topic :: Multimedia :: Graphics
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Scientific/Engineering :: Visualization
Classifier: Topic :: Software Development
Classifier: Topic :: Software Development :: Code Generators
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Utilities
